// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: Flight.proto

package ipc

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

//
// Describes what type of descriptor is defined.
type FlightDescriptor_DescriptorType int32

const (
	// Protobuf pattern, not used.
	FlightDescriptor_UNKNOWN FlightDescriptor_DescriptorType = 0
	//
	// A named path that identifies a dataset. A path is composed of a string
	// or list of strings describing a particular dataset. This is conceptually
	//  similar to a path inside a filesystem.
	FlightDescriptor_PATH FlightDescriptor_DescriptorType = 1
	//
	// An opaque command to generate a dataset.
	FlightDescriptor_CMD FlightDescriptor_DescriptorType = 2
)

var FlightDescriptor_DescriptorType_name = map[int32]string{
	0: "UNKNOWN",
	1: "PATH",
	2: "CMD",
}

var FlightDescriptor_DescriptorType_value = map[string]int32{
	"UNKNOWN": 0,
	"PATH":    1,
	"CMD":     2,
}

func (x FlightDescriptor_DescriptorType) String() string {
	return proto.EnumName(FlightDescriptor_DescriptorType_name, int32(x))
}

func (FlightDescriptor_DescriptorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{9, 0}
}

//
// The request that a client provides to a server on handshake.
type HandshakeRequest struct {
	//
	// A defined protocol version
	ProtocolVersion uint64 `protobuf:"varint,1,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	//
	// Arbitrary auth/handshake info.
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *HandshakeRequest) Reset()         { *m = HandshakeRequest{} }
func (m *HandshakeRequest) String() string { return proto.CompactTextString(m) }
func (*HandshakeRequest) ProtoMessage()    {}
func (*HandshakeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{0}
}
func (m *HandshakeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HandshakeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HandshakeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HandshakeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandshakeRequest.Merge(m, src)
}
func (m *HandshakeRequest) XXX_Size() int {
	return m.Size()
}
func (m *HandshakeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HandshakeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_HandshakeRequest proto.InternalMessageInfo

type HandshakeResponse struct {
	//
	// A defined protocol version
	ProtocolVersion uint64 `protobuf:"varint,1,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	//
	// Arbitrary auth/handshake info.
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *HandshakeResponse) Reset()         { *m = HandshakeResponse{} }
func (m *HandshakeResponse) String() string { return proto.CompactTextString(m) }
func (*HandshakeResponse) ProtoMessage()    {}
func (*HandshakeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{1}
}
func (m *HandshakeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HandshakeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HandshakeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HandshakeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HandshakeResponse.Merge(m, src)
}
func (m *HandshakeResponse) XXX_Size() int {
	return m.Size()
}
func (m *HandshakeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HandshakeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HandshakeResponse proto.InternalMessageInfo

//
// A message for doing simple auth.
type BasicAuth struct {
	Username string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *BasicAuth) Reset()         { *m = BasicAuth{} }
func (m *BasicAuth) String() string { return proto.CompactTextString(m) }
func (*BasicAuth) ProtoMessage()    {}
func (*BasicAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{2}
}
func (m *BasicAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasicAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasicAuth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasicAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasicAuth.Merge(m, src)
}
func (m *BasicAuth) XXX_Size() int {
	return m.Size()
}
func (m *BasicAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_BasicAuth.DiscardUnknown(m)
}

var xxx_messageInfo_BasicAuth proto.InternalMessageInfo

type Empty struct {
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{3}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

//
// Describes an available action, including both the name used for execution
// along with a short description of the purpose of the action.
type ActionType struct {
	Type        string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *ActionType) Reset()         { *m = ActionType{} }
func (m *ActionType) String() string { return proto.CompactTextString(m) }
func (*ActionType) ProtoMessage()    {}
func (*ActionType) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{4}
}
func (m *ActionType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActionType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActionType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActionType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActionType.Merge(m, src)
}
func (m *ActionType) XXX_Size() int {
	return m.Size()
}
func (m *ActionType) XXX_DiscardUnknown() {
	xxx_messageInfo_ActionType.DiscardUnknown(m)
}

var xxx_messageInfo_ActionType proto.InternalMessageInfo

//
// A service specific expression that can be used to return a limited set
// of available Arrow Flight streams.
type Criteria struct {
	Expression []byte `protobuf:"bytes,1,opt,name=expression,proto3" json:"expression,omitempty"`
}

func (m *Criteria) Reset()         { *m = Criteria{} }
func (m *Criteria) String() string { return proto.CompactTextString(m) }
func (*Criteria) ProtoMessage()    {}
func (*Criteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{5}
}
func (m *Criteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Criteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Criteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Criteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Criteria.Merge(m, src)
}
func (m *Criteria) XXX_Size() int {
	return m.Size()
}
func (m *Criteria) XXX_DiscardUnknown() {
	xxx_messageInfo_Criteria.DiscardUnknown(m)
}

var xxx_messageInfo_Criteria proto.InternalMessageInfo

//
// An opaque action specific for the service.
type Action struct {
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Body []byte `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *Action) Reset()         { *m = Action{} }
func (m *Action) String() string { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()    {}
func (*Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{6}
}
func (m *Action) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Action.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action.Merge(m, src)
}
func (m *Action) XXX_Size() int {
	return m.Size()
}
func (m *Action) XXX_DiscardUnknown() {
	xxx_messageInfo_Action.DiscardUnknown(m)
}

var xxx_messageInfo_Action proto.InternalMessageInfo

//
// An opaque result returned after executing an action.
type Result struct {
	Body []byte `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{7}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

//
// Wrap the result of a getSchema call
type SchemaResult struct {
	// schema of the dataset as described in Schema.fbs::Schema.
	Schema []byte `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
}

func (m *SchemaResult) Reset()         { *m = SchemaResult{} }
func (m *SchemaResult) String() string { return proto.CompactTextString(m) }
func (*SchemaResult) ProtoMessage()    {}
func (*SchemaResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{8}
}
func (m *SchemaResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchemaResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchemaResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchemaResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchemaResult.Merge(m, src)
}
func (m *SchemaResult) XXX_Size() int {
	return m.Size()
}
func (m *SchemaResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SchemaResult.DiscardUnknown(m)
}

var xxx_messageInfo_SchemaResult proto.InternalMessageInfo

//
// The name or tag for a Flight. May be used as a way to retrieve or generate
// a flight or be used to expose a set of previously defined flights.
type FlightDescriptor struct {
	Type FlightDescriptor_DescriptorType `protobuf:"varint,1,opt,name=type,proto3,enum=arrow.flight.protocol.FlightDescriptor_DescriptorType" json:"type,omitempty"`
	//
	// Opaque value used to express a command. Should only be defined when
	// type = CMD.
	Cmd []byte `protobuf:"bytes,2,opt,name=cmd,proto3" json:"cmd,omitempty"`
	//
	// List of strings identifying a particular dataset. Should only be defined
	// when type = PATH.
	Path []string `protobuf:"bytes,3,rep,name=path,proto3" json:"path,omitempty"`
}

func (m *FlightDescriptor) Reset()         { *m = FlightDescriptor{} }
func (m *FlightDescriptor) String() string { return proto.CompactTextString(m) }
func (*FlightDescriptor) ProtoMessage()    {}
func (*FlightDescriptor) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{9}
}
func (m *FlightDescriptor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlightDescriptor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlightDescriptor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlightDescriptor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlightDescriptor.Merge(m, src)
}
func (m *FlightDescriptor) XXX_Size() int {
	return m.Size()
}
func (m *FlightDescriptor) XXX_DiscardUnknown() {
	xxx_messageInfo_FlightDescriptor.DiscardUnknown(m)
}

var xxx_messageInfo_FlightDescriptor proto.InternalMessageInfo

//
// The access coordinates for retrieval of a dataset. With a FlightInfo, a
// consumer is able to determine how to retrieve a dataset.
type FlightInfo struct {
	// schema of the dataset as described in Schema.fbs::Schema.
	Schema []byte `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	//
	// The descriptor associated with this info.
	FlightDescriptor *FlightDescriptor `protobuf:"bytes,2,opt,name=flight_descriptor,json=flightDescriptor,proto3" json:"flight_descriptor,omitempty"`
	//
	// A list of endpoints associated with the flight. To consume the whole
	// flight, all endpoints must be consumed.
	Endpoint []*FlightEndpoint `protobuf:"bytes,3,rep,name=endpoint,proto3" json:"endpoint,omitempty"`
	// Set these to -1 if unknown.
	TotalRecords int64 `protobuf:"varint,4,opt,name=total_records,json=totalRecords,proto3" json:"total_records,omitempty"`
	TotalBytes   int64 `protobuf:"varint,5,opt,name=total_bytes,json=totalBytes,proto3" json:"total_bytes,omitempty"`
}

func (m *FlightInfo) Reset()         { *m = FlightInfo{} }
func (m *FlightInfo) String() string { return proto.CompactTextString(m) }
func (*FlightInfo) ProtoMessage()    {}
func (*FlightInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{10}
}
func (m *FlightInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlightInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlightInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlightInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlightInfo.Merge(m, src)
}
func (m *FlightInfo) XXX_Size() int {
	return m.Size()
}
func (m *FlightInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FlightInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FlightInfo proto.InternalMessageInfo

//
// A particular stream or split associated with a flight.
type FlightEndpoint struct {
	//
	// Token used to retrieve this stream.
	Ticket *Ticket `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	//
	// A list of URIs where this ticket can be redeemed. If the list is
	// empty, the expectation is that the ticket can only be redeemed on the
	// current service where the ticket was generated.
	Location []*Location `protobuf:"bytes,2,rep,name=location,proto3" json:"location,omitempty"`
}

func (m *FlightEndpoint) Reset()         { *m = FlightEndpoint{} }
func (m *FlightEndpoint) String() string { return proto.CompactTextString(m) }
func (*FlightEndpoint) ProtoMessage()    {}
func (*FlightEndpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{11}
}
func (m *FlightEndpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlightEndpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlightEndpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlightEndpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlightEndpoint.Merge(m, src)
}
func (m *FlightEndpoint) XXX_Size() int {
	return m.Size()
}
func (m *FlightEndpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_FlightEndpoint.DiscardUnknown(m)
}

var xxx_messageInfo_FlightEndpoint proto.InternalMessageInfo

//
// A location where a Flight service will accept retrieval of a particular
// stream given a ticket.
type Location struct {
	Uri string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}
func (*Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{12}
}
func (m *Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Location.Merge(m, src)
}
func (m *Location) XXX_Size() int {
	return m.Size()
}
func (m *Location) XXX_DiscardUnknown() {
	xxx_messageInfo_Location.DiscardUnknown(m)
}

var xxx_messageInfo_Location proto.InternalMessageInfo

//
// An opaque identifier that the service can use to retrieve a particular
// portion of a stream.
type Ticket struct {
	Ticket []byte `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
}

func (m *Ticket) Reset()         { *m = Ticket{} }
func (m *Ticket) String() string { return proto.CompactTextString(m) }
func (*Ticket) ProtoMessage()    {}
func (*Ticket) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{13}
}
func (m *Ticket) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ticket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ticket.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ticket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ticket.Merge(m, src)
}
func (m *Ticket) XXX_Size() int {
	return m.Size()
}
func (m *Ticket) XXX_DiscardUnknown() {
	xxx_messageInfo_Ticket.DiscardUnknown(m)
}

var xxx_messageInfo_Ticket proto.InternalMessageInfo

//
// A batch of Arrow data as part of a stream of batches.
type FlightData struct {
	//
	// The descriptor of the data. This is only relevant when a client is
	// starting a new DoPut stream.
	FlightDescriptor *FlightDescriptor `protobuf:"bytes,1,opt,name=flight_descriptor,json=flightDescriptor,proto3" json:"flight_descriptor,omitempty"`
	//
	// Header for message data as described in Message.fbs::Message.
	DataHeader []byte `protobuf:"bytes,2,opt,name=data_header,json=dataHeader,proto3" json:"data_header,omitempty"`
	//
	// Application-defined metadata.
	AppMetadata []byte `protobuf:"bytes,3,opt,name=app_metadata,json=appMetadata,proto3" json:"app_metadata,omitempty"`
	//
	// The actual batch of Arrow data. Preferably handled with minimal-copies
	// coming last in the definition to help with sidecar patterns (it is
	// expected that some implementations will fetch this field off the wire
	// with specialized code to avoid extra memory copies).
	DataBody []byte `protobuf:"bytes,1000,opt,name=data_body,json=dataBody,proto3" json:"data_body,omitempty"`
}

func (m *FlightData) Reset()         { *m = FlightData{} }
func (m *FlightData) String() string { return proto.CompactTextString(m) }
func (*FlightData) ProtoMessage()    {}
func (*FlightData) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{14}
}
func (m *FlightData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlightData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlightData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlightData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlightData.Merge(m, src)
}
func (m *FlightData) XXX_Size() int {
	return m.Size()
}
func (m *FlightData) XXX_DiscardUnknown() {
	xxx_messageInfo_FlightData.DiscardUnknown(m)
}

var xxx_messageInfo_FlightData proto.InternalMessageInfo

//*
// The response message associated with the submission of a DoPut.
type PutResult struct {
	AppMetadata []byte `protobuf:"bytes,1,opt,name=app_metadata,json=appMetadata,proto3" json:"app_metadata,omitempty"`
}

func (m *PutResult) Reset()         { *m = PutResult{} }
func (m *PutResult) String() string { return proto.CompactTextString(m) }
func (*PutResult) ProtoMessage()    {}
func (*PutResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_b9d4235a02d6d6e7, []int{15}
}
func (m *PutResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutResult.Merge(m, src)
}
func (m *PutResult) XXX_Size() int {
	return m.Size()
}
func (m *PutResult) XXX_DiscardUnknown() {
	xxx_messageInfo_PutResult.DiscardUnknown(m)
}

var xxx_messageInfo_PutResult proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("arrow.flight.protocol.FlightDescriptor_DescriptorType", FlightDescriptor_DescriptorType_name, FlightDescriptor_DescriptorType_value)
	proto.RegisterType((*HandshakeRequest)(nil), "arrow.flight.protocol.HandshakeRequest")
	proto.RegisterType((*HandshakeResponse)(nil), "arrow.flight.protocol.HandshakeResponse")
	proto.RegisterType((*BasicAuth)(nil), "arrow.flight.protocol.BasicAuth")
	proto.RegisterType((*Empty)(nil), "arrow.flight.protocol.Empty")
	proto.RegisterType((*ActionType)(nil), "arrow.flight.protocol.ActionType")
	proto.RegisterType((*Criteria)(nil), "arrow.flight.protocol.Criteria")
	proto.RegisterType((*Action)(nil), "arrow.flight.protocol.Action")
	proto.RegisterType((*Result)(nil), "arrow.flight.protocol.Result")
	proto.RegisterType((*SchemaResult)(nil), "arrow.flight.protocol.SchemaResult")
	proto.RegisterType((*FlightDescriptor)(nil), "arrow.flight.protocol.FlightDescriptor")
	proto.RegisterType((*FlightInfo)(nil), "arrow.flight.protocol.FlightInfo")
	proto.RegisterType((*FlightEndpoint)(nil), "arrow.flight.protocol.FlightEndpoint")
	proto.RegisterType((*Location)(nil), "arrow.flight.protocol.Location")
	proto.RegisterType((*Ticket)(nil), "arrow.flight.protocol.Ticket")
	proto.RegisterType((*FlightData)(nil), "arrow.flight.protocol.FlightData")
	proto.RegisterType((*PutResult)(nil), "arrow.flight.protocol.PutResult")
}

func init() { proto.RegisterFile("Flight.proto", fileDescriptor_b9d4235a02d6d6e7) }

var fileDescriptor_b9d4235a02d6d6e7 = []byte{
	// 874 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0x4f, 0x6f, 0x23, 0x35,
	0x14, 0x8f, 0x9b, 0x34, 0x7f, 0xde, 0xa4, 0x25, 0x6b, 0x01, 0x8a, 0xa2, 0x90, 0x66, 0xbd, 0x02,
	0x02, 0x87, 0x50, 0x05, 0xc1, 0x85, 0x03, 0x6a, 0x9a, 0xa5, 0x05, 0xda, 0x52, 0xcd, 0x76, 0x59,
	0x04, 0x42, 0x91, 0x3b, 0xe3, 0x36, 0xa3, 0x4d, 0x62, 0x63, 0x3b, 0xbb, 0xe4, 0x0c, 0x1f, 0x80,
	0x4f, 0xc3, 0x27, 0xe0, 0xb0, 0x17, 0xa4, 0x3d, 0x72, 0x84, 0xf6, 0xc2, 0xc7, 0x40, 0xf6, 0x78,
	0x66, 0xa7, 0xa5, 0xd3, 0x46, 0x82, 0x9b, 0xfd, 0xf3, 0xef, 0xbd, 0xf7, 0x7b, 0x7e, 0xcf, 0xcf,
	0x50, 0xff, 0x6c, 0x1a, 0x9d, 0x4f, 0x74, 0x5f, 0x48, 0xae, 0x39, 0x7e, 0x83, 0x4a, 0xc9, 0x9f,
	0xf7, 0xcf, 0x32, 0x58, 0xc0, 0xa7, 0xad, 0xd7, 0xcf, 0xf9, 0x39, 0xb7, 0xbb, 0x0f, 0xcc, 0x2a,
	0x3e, 0x20, 0x4f, 0xa0, 0xb1, 0x4f, 0xe7, 0xa1, 0x9a, 0xd0, 0xa7, 0xcc, 0x67, 0x3f, 0x2c, 0x98,
	0xd2, 0xf8, 0x3d, 0x68, 0x24, 0x56, 0xe3, 0x67, 0x4c, 0xaa, 0x88, 0xcf, 0x9b, 0xa8, 0x8b, 0x7a,
	0x25, 0xff, 0xb5, 0x04, 0xff, 0x3a, 0x86, 0x71, 0x13, 0x2a, 0x82, 0x2e, 0xa7, 0x9c, 0x86, 0xcd,
	0xb5, 0x2e, 0xea, 0xd5, 0xfd, 0x64, 0x4b, 0xbe, 0x81, 0x7b, 0x19, 0xc7, 0x4a, 0xf0, 0xb9, 0x62,
	0xff, 0x8f, 0xe7, 0x5d, 0xa8, 0x0d, 0xa9, 0x8a, 0x82, 0x9d, 0x85, 0x9e, 0xe0, 0x16, 0x54, 0x17,
	0x8a, 0xc9, 0x39, 0x9d, 0x31, 0xcb, 0xab, 0xf9, 0xe9, 0xde, 0x9c, 0x09, 0xaa, 0xd4, 0x73, 0x2e,
	0xc3, 0x66, 0x31, 0x3e, 0x4b, 0xf6, 0xa4, 0x02, 0xeb, 0x0f, 0x67, 0x42, 0x2f, 0xc9, 0x10, 0x60,
	0x27, 0xd0, 0x11, 0x9f, 0x9f, 0x2c, 0x05, 0xc3, 0x18, 0x4a, 0x7a, 0x29, 0x98, 0x15, 0x55, 0xf3,
	0xed, 0x1a, 0x77, 0xc1, 0x0b, 0x99, 0x0a, 0x64, 0x24, 0x0c, 0xcd, 0x45, 0xc9, 0x42, 0xe4, 0x7d,
	0xa8, 0xee, 0xca, 0x48, 0x33, 0x19, 0x51, 0xdc, 0x01, 0x60, 0x3f, 0x0a, 0xc9, 0x54, 0x9a, 0x5c,
	0xdd, 0xcf, 0x20, 0x64, 0x1b, 0xca, 0x71, 0xbc, 0x1b, 0x63, 0x61, 0x28, 0x9d, 0xf2, 0x70, 0xe9,
	0x52, 0xb6, 0x6b, 0xd2, 0x86, 0xb2, 0xcf, 0xd4, 0x62, 0xaa, 0xd3, 0x53, 0x94, 0x39, 0x7d, 0x07,
	0xea, 0x8f, 0x82, 0x09, 0x9b, 0x51, 0xc7, 0x79, 0x13, 0xca, 0xca, 0xee, 0x1d, 0xcb, 0xed, 0xc8,
	0xaf, 0x08, 0x1a, 0x71, 0x9b, 0x8c, 0x9c, 0x72, 0x2e, 0xf1, 0x17, 0x19, 0x09, 0x9b, 0x83, 0x8f,
	0xfb, 0x37, 0x76, 0x4e, 0xff, 0xba, 0x59, 0xff, 0xd5, 0xd2, 0x5c, 0x9a, 0x93, 0xde, 0x80, 0x62,
	0x30, 0x4b, 0x8a, 0x65, 0x96, 0x46, 0xae, 0xa0, 0x7a, 0xd2, 0x2c, 0x76, 0x8b, 0x26, 0x41, 0xb3,
	0x26, 0xdb, 0xb0, 0x79, 0xd5, 0x1a, 0x7b, 0x50, 0x79, 0x7c, 0xf4, 0xe5, 0xd1, 0x57, 0x4f, 0x8e,
	0x1a, 0x05, 0x5c, 0x85, 0xd2, 0xf1, 0xce, 0xc9, 0x7e, 0x03, 0xe1, 0x0a, 0x14, 0x77, 0x0f, 0x47,
	0x8d, 0x35, 0xf2, 0xd3, 0x1a, 0x40, 0xac, 0xe0, 0xf3, 0xf9, 0x19, 0xcf, 0xcb, 0x0f, 0x9f, 0xc0,
	0xbd, 0x58, 0xf7, 0x38, 0x4c, 0xfd, 0x5b, 0x31, 0xde, 0xe0, 0xdd, 0x15, 0xf3, 0xf2, 0x1b, 0x67,
	0xd7, 0x2f, 0x68, 0x07, 0xaa, 0x6c, 0x1e, 0x0a, 0x1e, 0xcd, 0xb5, 0x4d, 0xc3, 0x1b, 0xbc, 0x7d,
	0xab, 0xb3, 0x87, 0x8e, 0xec, 0xa7, 0x66, 0xf8, 0x01, 0x6c, 0x68, 0xae, 0xe9, 0x74, 0x2c, 0x59,
	0xc0, 0x65, 0xa8, 0x9a, 0xa5, 0x2e, 0xea, 0x15, 0xfd, 0xba, 0x05, 0xfd, 0x18, 0xc3, 0x5b, 0xe0,
	0xc5, 0xa4, 0xd3, 0xa5, 0x66, 0xaa, 0xb9, 0x6e, 0x29, 0x60, 0xa1, 0xa1, 0x41, 0xc8, 0xcf, 0x08,
	0x36, 0xaf, 0x86, 0xc0, 0x1f, 0x41, 0x59, 0x47, 0xc1, 0x53, 0xa6, 0xed, 0x4d, 0x78, 0x83, 0xb7,
	0x72, 0x94, 0x9d, 0x58, 0x92, 0xef, 0xc8, 0xf8, 0x13, 0xa8, 0x4e, 0x79, 0x40, 0x5d, 0x2f, 0x9b,
	0x94, 0xb6, 0x72, 0x0c, 0x0f, 0x1c, 0xcd, 0x4f, 0x0d, 0x48, 0x1b, 0xaa, 0x09, 0x6a, 0x0a, 0xbe,
	0x90, 0x91, 0x6b, 0x5f, 0xb3, 0x24, 0x5d, 0x28, 0xc7, 0xc1, 0x4c, 0x95, 0x32, 0xda, 0xea, 0x49,
	0x70, 0xf2, 0x1b, 0x4a, 0x8a, 0x39, 0xa2, 0x3a, 0xa7, 0x68, 0xe8, 0xbf, 0x16, 0x6d, 0x0b, 0xbc,
	0x90, 0x6a, 0x3a, 0x9e, 0x30, 0x1a, 0x32, 0xe9, 0x3a, 0x12, 0x0c, 0xb4, 0x6f, 0x11, 0x7c, 0x1f,
	0xea, 0x54, 0x88, 0xf1, 0x8c, 0x69, 0x6a, 0x50, 0x3b, 0x1c, 0xea, 0xbe, 0x47, 0x85, 0x38, 0x74,
	0x10, 0x6e, 0x43, 0xcd, 0xfa, 0xb0, 0xef, 0xed, 0xef, 0x8a, 0x25, 0x54, 0x0d, 0x32, 0x34, 0x8f,
	0xae, 0x0f, 0xb5, 0xe3, 0x85, 0x76, 0x2f, 0xee, 0xba, 0x37, 0xf4, 0x2f, 0x6f, 0x83, 0xdf, 0xd7,
	0x61, 0x23, 0x16, 0xfe, 0x88, 0xc9, 0x67, 0x51, 0xc0, 0x70, 0x08, 0xb5, 0x74, 0x3c, 0xe2, 0xbc,
	0x5c, 0xaf, 0x4f, 0xe6, 0x56, 0xef, 0x6e, 0x62, 0x3c, 0x69, 0x49, 0xa1, 0x87, 0xb6, 0x11, 0x7e,
	0x0c, 0xde, 0x41, 0xa4, 0x74, 0x1c, 0x5a, 0xe1, 0xbc, 0x42, 0x27, 0xc3, 0xab, 0x75, 0xff, 0xd6,
	0x4b, 0x37, 0xef, 0x8f, 0x14, 0xb6, 0x11, 0xfe, 0x1e, 0x36, 0xf6, 0x98, 0xce, 0x3c, 0xca, 0x55,
	0x8b, 0xb5, 0x52, 0x00, 0xfc, 0x1d, 0xd4, 0xf6, 0x98, 0x8e, 0xa7, 0xda, 0xea, 0xae, 0x1f, 0xe4,
	0x10, 0xb3, 0xd3, 0x91, 0x14, 0xf0, 0x21, 0xac, 0x8f, 0xf8, 0x1e, 0xd3, 0xf8, 0xf6, 0xe7, 0x72,
	0x87, 0x52, 0xd3, 0xbd, 0xf6, 0x2a, 0x7c, 0xe3, 0xee, 0x78, 0xa1, 0xf1, 0xdd, 0xfc, 0x56, 0x37,
	0x87, 0x92, 0xb6, 0x92, 0xab, 0xda, 0x01, 0x54, 0x47, 0xdc, 0x7d, 0x12, 0x79, 0x2a, 0xe3, 0xe3,
	0x56, 0xde, 0x71, 0xe2, 0xcf, 0x2a, 0xb4, 0x3d, 0x10, 0x1b, 0x28, 0xdc, 0xce, 0xb1, 0xb0, 0xbf,
	0x61, 0x6e, 0xd6, 0xaf, 0xbe, 0x48, 0xe3, 0x73, 0xf8, 0xe9, 0x8b, 0xbf, 0x3a, 0x85, 0x17, 0x17,
	0x1d, 0xf4, 0xf2, 0xa2, 0x83, 0xfe, 0xbc, 0xe8, 0xa0, 0x5f, 0x2e, 0x3b, 0x85, 0x97, 0x97, 0x9d,
	0xc2, 0x1f, 0x97, 0x9d, 0x02, 0xb4, 0xb9, 0x3c, 0xef, 0x53, 0x41, 0x83, 0x09, 0xbb, 0xea, 0x2e,
	0x9a, 0x89, 0xe9, 0xb7, 0xc5, 0x48, 0x04, 0xa7, 0x65, 0xeb, 0xf9, 0xc3, 0x7f, 0x02, 0x00, 0x00,
	0xff, 0xff, 0xe3, 0x7b, 0xcf, 0x2a, 0xba, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FlightServiceClient is the client API for FlightService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FlightServiceClient interface {
	//
	// Handshake between client and server. Depending on the server, the
	// handshake may be required to determine the token that should be used for
	// future operations. Both request and response are streams to allow multiple
	// round-trips depending on auth mechanism.
	Handshake(ctx context.Context, opts ...grpc.CallOption) (FlightService_HandshakeClient, error)
	//
	// Get a list of available streams given a particular criteria. Most flight
	// services will expose one or more streams that are readily available for
	// retrieval. This api allows listing the streams available for
	// consumption. A user can also provide a criteria. The criteria can limit
	// the subset of streams that can be listed via this interface. Each flight
	// service allows its own definition of how to consume criteria.
	ListFlights(ctx context.Context, in *Criteria, opts ...grpc.CallOption) (FlightService_ListFlightsClient, error)
	//
	// For a given FlightDescriptor, get information about how the flight can be
	// consumed. This is a useful interface if the consumer of the interface
	// already can identify the specific flight to consume. This interface can
	// also allow a consumer to generate a flight stream through a specified
	// descriptor. For example, a flight descriptor might be something that
	// includes a SQL statement or a Pickled Python operation that will be
	// executed. In those cases, the descriptor will not be previously available
	// within the list of available streams provided by ListFlights but will be
	// available for consumption for the duration defined by the specific flight
	// service.
	GetFlightInfo(ctx context.Context, in *FlightDescriptor, opts ...grpc.CallOption) (*FlightInfo, error)
	//
	// For a given FlightDescriptor, get the Schema as described in Schema.fbs::Schema
	// This is used when a consumer needs the Schema of flight stream. Similar to
	// GetFlightInfo this interface may generate a new flight that was not previously
	// available in ListFlights.
	GetSchema(ctx context.Context, in *FlightDescriptor, opts ...grpc.CallOption) (*SchemaResult, error)
	//
	// Retrieve a single stream associated with a particular descriptor
	// associated with the referenced ticket. A Flight can be composed of one or
	// more streams where each stream can be retrieved using a separate opaque
	// ticket that the flight service uses for managing a collection of streams.
	DoGet(ctx context.Context, in *Ticket, opts ...grpc.CallOption) (FlightService_DoGetClient, error)
	//
	// Push a stream to the flight service associated with a particular
	// flight stream. This allows a client of a flight service to upload a stream
	// of data. Depending on the particular flight service, a client consumer
	// could be allowed to upload a single stream per descriptor or an unlimited
	// number. In the latter, the service might implement a 'seal' action that
	// can be applied to a descriptor once all streams are uploaded.
	DoPut(ctx context.Context, opts ...grpc.CallOption) (FlightService_DoPutClient, error)
	//
	// Flight services can support an arbitrary number of simple actions in
	// addition to the possible ListFlights, GetFlightInfo, DoGet, DoPut
	// operations that are potentially available. DoAction allows a flight client
	// to do a specific action against a flight service. An action includes
	// opaque request and response objects that are specific to the type action
	// being undertaken.
	DoAction(ctx context.Context, in *Action, opts ...grpc.CallOption) (FlightService_DoActionClient, error)
	//
	// A flight service exposes all of the available action types that it has
	// along with descriptions. This allows different flight consumers to
	// understand the capabilities of the flight service.
	ListActions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (FlightService_ListActionsClient, error)
}

type flightServiceClient struct {
	cc *grpc.ClientConn
}

func NewFlightServiceClient(cc *grpc.ClientConn) FlightServiceClient {
	return &flightServiceClient{cc}
}

func (c *flightServiceClient) Handshake(ctx context.Context, opts ...grpc.CallOption) (FlightService_HandshakeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FlightService_serviceDesc.Streams[0], "/arrow.flight.protocol.FlightService/Handshake", opts...)
	if err != nil {
		return nil, err
	}
	x := &flightServiceHandshakeClient{stream}
	return x, nil
}

type FlightService_HandshakeClient interface {
	Send(*HandshakeRequest) error
	Recv() (*HandshakeResponse, error)
	grpc.ClientStream
}

type flightServiceHandshakeClient struct {
	grpc.ClientStream
}

func (x *flightServiceHandshakeClient) Send(m *HandshakeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *flightServiceHandshakeClient) Recv() (*HandshakeResponse, error) {
	m := new(HandshakeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flightServiceClient) ListFlights(ctx context.Context, in *Criteria, opts ...grpc.CallOption) (FlightService_ListFlightsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FlightService_serviceDesc.Streams[1], "/arrow.flight.protocol.FlightService/ListFlights", opts...)
	if err != nil {
		return nil, err
	}
	x := &flightServiceListFlightsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FlightService_ListFlightsClient interface {
	Recv() (*FlightInfo, error)
	grpc.ClientStream
}

type flightServiceListFlightsClient struct {
	grpc.ClientStream
}

func (x *flightServiceListFlightsClient) Recv() (*FlightInfo, error) {
	m := new(FlightInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flightServiceClient) GetFlightInfo(ctx context.Context, in *FlightDescriptor, opts ...grpc.CallOption) (*FlightInfo, error) {
	out := new(FlightInfo)
	err := c.cc.Invoke(ctx, "/arrow.flight.protocol.FlightService/GetFlightInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flightServiceClient) GetSchema(ctx context.Context, in *FlightDescriptor, opts ...grpc.CallOption) (*SchemaResult, error) {
	out := new(SchemaResult)
	err := c.cc.Invoke(ctx, "/arrow.flight.protocol.FlightService/GetSchema", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flightServiceClient) DoGet(ctx context.Context, in *Ticket, opts ...grpc.CallOption) (FlightService_DoGetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FlightService_serviceDesc.Streams[2], "/arrow.flight.protocol.FlightService/DoGet", opts...)
	if err != nil {
		return nil, err
	}
	x := &flightServiceDoGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FlightService_DoGetClient interface {
	Recv() (*FlightData, error)
	grpc.ClientStream
}

type flightServiceDoGetClient struct {
	grpc.ClientStream
}

func (x *flightServiceDoGetClient) Recv() (*FlightData, error) {
	m := new(FlightData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flightServiceClient) DoPut(ctx context.Context, opts ...grpc.CallOption) (FlightService_DoPutClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FlightService_serviceDesc.Streams[3], "/arrow.flight.protocol.FlightService/DoPut", opts...)
	if err != nil {
		return nil, err
	}
	x := &flightServiceDoPutClient{stream}
	return x, nil
}

type FlightService_DoPutClient interface {
	Send(*FlightData) error
	Recv() (*PutResult, error)
	grpc.ClientStream
}

type flightServiceDoPutClient struct {
	grpc.ClientStream
}

func (x *flightServiceDoPutClient) Send(m *FlightData) error {
	return x.ClientStream.SendMsg(m)
}

func (x *flightServiceDoPutClient) Recv() (*PutResult, error) {
	m := new(PutResult)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flightServiceClient) DoAction(ctx context.Context, in *Action, opts ...grpc.CallOption) (FlightService_DoActionClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FlightService_serviceDesc.Streams[4], "/arrow.flight.protocol.FlightService/DoAction", opts...)
	if err != nil {
		return nil, err
	}
	x := &flightServiceDoActionClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FlightService_DoActionClient interface {
	Recv() (*Result, error)
	grpc.ClientStream
}

type flightServiceDoActionClient struct {
	grpc.ClientStream
}

func (x *flightServiceDoActionClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flightServiceClient) ListActions(ctx context.Context, in *Empty, opts ...grpc.CallOption) (FlightService_ListActionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_FlightService_serviceDesc.Streams[5], "/arrow.flight.protocol.FlightService/ListActions", opts...)
	if err != nil {
		return nil, err
	}
	x := &flightServiceListActionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FlightService_ListActionsClient interface {
	Recv() (*ActionType, error)
	grpc.ClientStream
}

type flightServiceListActionsClient struct {
	grpc.ClientStream
}

func (x *flightServiceListActionsClient) Recv() (*ActionType, error) {
	m := new(ActionType)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// FlightServiceServer is the server API for FlightService service.
type FlightServiceServer interface {
	//
	// Handshake between client and server. Depending on the server, the
	// handshake may be required to determine the token that should be used for
	// future operations. Both request and response are streams to allow multiple
	// round-trips depending on auth mechanism.
	Handshake(FlightService_HandshakeServer) error
	//
	// Get a list of available streams given a particular criteria. Most flight
	// services will expose one or more streams that are readily available for
	// retrieval. This api allows listing the streams available for
	// consumption. A user can also provide a criteria. The criteria can limit
	// the subset of streams that can be listed via this interface. Each flight
	// service allows its own definition of how to consume criteria.
	ListFlights(*Criteria, FlightService_ListFlightsServer) error
	//
	// For a given FlightDescriptor, get information about how the flight can be
	// consumed. This is a useful interface if the consumer of the interface
	// already can identify the specific flight to consume. This interface can
	// also allow a consumer to generate a flight stream through a specified
	// descriptor. For example, a flight descriptor might be something that
	// includes a SQL statement or a Pickled Python operation that will be
	// executed. In those cases, the descriptor will not be previously available
	// within the list of available streams provided by ListFlights but will be
	// available for consumption for the duration defined by the specific flight
	// service.
	GetFlightInfo(context.Context, *FlightDescriptor) (*FlightInfo, error)
	//
	// For a given FlightDescriptor, get the Schema as described in Schema.fbs::Schema
	// This is used when a consumer needs the Schema of flight stream. Similar to
	// GetFlightInfo this interface may generate a new flight that was not previously
	// available in ListFlights.
	GetSchema(context.Context, *FlightDescriptor) (*SchemaResult, error)
	//
	// Retrieve a single stream associated with a particular descriptor
	// associated with the referenced ticket. A Flight can be composed of one or
	// more streams where each stream can be retrieved using a separate opaque
	// ticket that the flight service uses for managing a collection of streams.
	DoGet(*Ticket, FlightService_DoGetServer) error
	//
	// Push a stream to the flight service associated with a particular
	// flight stream. This allows a client of a flight service to upload a stream
	// of data. Depending on the particular flight service, a client consumer
	// could be allowed to upload a single stream per descriptor or an unlimited
	// number. In the latter, the service might implement a 'seal' action that
	// can be applied to a descriptor once all streams are uploaded.
	DoPut(FlightService_DoPutServer) error
	//
	// Flight services can support an arbitrary number of simple actions in
	// addition to the possible ListFlights, GetFlightInfo, DoGet, DoPut
	// operations that are potentially available. DoAction allows a flight client
	// to do a specific action against a flight service. An action includes
	// opaque request and response objects that are specific to the type action
	// being undertaken.
	DoAction(*Action, FlightService_DoActionServer) error
	//
	// A flight service exposes all of the available action types that it has
	// along with descriptions. This allows different flight consumers to
	// understand the capabilities of the flight service.
	ListActions(*Empty, FlightService_ListActionsServer) error
}

func RegisterFlightServiceServer(s *grpc.Server, srv FlightServiceServer) {
	s.RegisterService(&_FlightService_serviceDesc, srv)
}

func _FlightService_Handshake_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FlightServiceServer).Handshake(&flightServiceHandshakeServer{stream})
}

type FlightService_HandshakeServer interface {
	Send(*HandshakeResponse) error
	Recv() (*HandshakeRequest, error)
	grpc.ServerStream
}

type flightServiceHandshakeServer struct {
	grpc.ServerStream
}

func (x *flightServiceHandshakeServer) Send(m *HandshakeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *flightServiceHandshakeServer) Recv() (*HandshakeRequest, error) {
	m := new(HandshakeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FlightService_ListFlights_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Criteria)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlightServiceServer).ListFlights(m, &flightServiceListFlightsServer{stream})
}

type FlightService_ListFlightsServer interface {
	Send(*FlightInfo) error
	grpc.ServerStream
}

type flightServiceListFlightsServer struct {
	grpc.ServerStream
}

func (x *flightServiceListFlightsServer) Send(m *FlightInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _FlightService_GetFlightInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlightDescriptor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlightServiceServer).GetFlightInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arrow.flight.protocol.FlightService/GetFlightInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlightServiceServer).GetFlightInfo(ctx, req.(*FlightDescriptor))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlightService_GetSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FlightDescriptor)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlightServiceServer).GetSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/arrow.flight.protocol.FlightService/GetSchema",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlightServiceServer).GetSchema(ctx, req.(*FlightDescriptor))
	}
	return interceptor(ctx, in, info, handler)
}

func _FlightService_DoGet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Ticket)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlightServiceServer).DoGet(m, &flightServiceDoGetServer{stream})
}

type FlightService_DoGetServer interface {
	Send(*FlightData) error
	grpc.ServerStream
}

type flightServiceDoGetServer struct {
	grpc.ServerStream
}

func (x *flightServiceDoGetServer) Send(m *FlightData) error {
	return x.ServerStream.SendMsg(m)
}

func _FlightService_DoPut_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FlightServiceServer).DoPut(&flightServiceDoPutServer{stream})
}

type FlightService_DoPutServer interface {
	Send(*PutResult) error
	Recv() (*FlightData, error)
	grpc.ServerStream
}

type flightServiceDoPutServer struct {
	grpc.ServerStream
}

func (x *flightServiceDoPutServer) Send(m *PutResult) error {
	return x.ServerStream.SendMsg(m)
}

func (x *flightServiceDoPutServer) Recv() (*FlightData, error) {
	m := new(FlightData)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _FlightService_DoAction_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Action)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlightServiceServer).DoAction(m, &flightServiceDoActionServer{stream})
}

type FlightService_DoActionServer interface {
	Send(*Result) error
	grpc.ServerStream
}

type flightServiceDoActionServer struct {
	grpc.ServerStream
}

func (x *flightServiceDoActionServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func _FlightService_ListActions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlightServiceServer).ListActions(m, &flightServiceListActionsServer{stream})
}

type FlightService_ListActionsServer interface {
	Send(*ActionType) error
	grpc.ServerStream
}

type flightServiceListActionsServer struct {
	grpc.ServerStream
}

func (x *flightServiceListActionsServer) Send(m *ActionType) error {
	return x.ServerStream.SendMsg(m)
}

var _FlightService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "arrow.flight.protocol.FlightService",
	HandlerType: (*FlightServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetFlightInfo",
			Handler:    _FlightService_GetFlightInfo_Handler,
		},
		{
			MethodName: "GetSchema",
			Handler:    _FlightService_GetSchema_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Handshake",
			Handler:       _FlightService_Handshake_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ListFlights",
			Handler:       _FlightService_ListFlights_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DoGet",
			Handler:       _FlightService_DoGet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DoPut",
			Handler:       _FlightService_DoPut_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "DoAction",
			Handler:       _FlightService_DoAction_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListActions",
			Handler:       _FlightService_ListActions_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "Flight.proto",
}

func (m *HandshakeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandshakeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProtocolVersion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFlight(dAtA, i, uint64(m.ProtocolVersion))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	return i, nil
}

func (m *HandshakeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HandshakeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ProtocolVersion != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFlight(dAtA, i, uint64(m.ProtocolVersion))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	return i, nil
}

func (m *BasicAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasicAuth) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ActionType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActionType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Description) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Description)))
		i += copy(dAtA[i:], m.Description)
	}
	return i, nil
}

func (m *Criteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Criteria) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Expression) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Expression)))
		i += copy(dAtA[i:], m.Expression)
	}
	return i, nil
}

func (m *Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Body) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	return i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Body) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Body)))
		i += copy(dAtA[i:], m.Body)
	}
	return i, nil
}

func (m *SchemaResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchemaResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Schema) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Schema)))
		i += copy(dAtA[i:], m.Schema)
	}
	return i, nil
}

func (m *FlightDescriptor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlightDescriptor) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintFlight(dAtA, i, uint64(m.Type))
	}
	if len(m.Cmd) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Cmd)))
		i += copy(dAtA[i:], m.Cmd)
	}
	if len(m.Path) > 0 {
		for _, s := range m.Path {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *FlightInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlightInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Schema) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Schema)))
		i += copy(dAtA[i:], m.Schema)
	}
	if m.FlightDescriptor != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlight(dAtA, i, uint64(m.FlightDescriptor.Size()))
		n1, err := m.FlightDescriptor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Endpoint) > 0 {
		for _, msg := range m.Endpoint {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintFlight(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalRecords != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintFlight(dAtA, i, uint64(m.TotalRecords))
	}
	if m.TotalBytes != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintFlight(dAtA, i, uint64(m.TotalBytes))
	}
	return i, nil
}

func (m *FlightEndpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlightEndpoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ticket != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlight(dAtA, i, uint64(m.Ticket.Size()))
		n2, err := m.Ticket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Location) > 0 {
		for _, msg := range m.Location {
			dAtA[i] = 0x12
			i++
			i = encodeVarintFlight(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Uri) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Uri)))
		i += copy(dAtA[i:], m.Uri)
	}
	return i, nil
}

func (m *Ticket) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ticket) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.Ticket)))
		i += copy(dAtA[i:], m.Ticket)
	}
	return i, nil
}

func (m *FlightData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlightData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.FlightDescriptor != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlight(dAtA, i, uint64(m.FlightDescriptor.Size()))
		n3, err := m.FlightDescriptor.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.DataHeader) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.DataHeader)))
		i += copy(dAtA[i:], m.DataHeader)
	}
	if len(m.AppMetadata) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.AppMetadata)))
		i += copy(dAtA[i:], m.AppMetadata)
	}
	if len(m.DataBody) > 0 {
		dAtA[i] = 0xc2
		i++
		dAtA[i] = 0x3e
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.DataBody)))
		i += copy(dAtA[i:], m.DataBody)
	}
	return i, nil
}

func (m *PutResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutResult) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppMetadata) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintFlight(dAtA, i, uint64(len(m.AppMetadata)))
		i += copy(dAtA[i:], m.AppMetadata)
	}
	return i, nil
}

func encodeVarintFlight(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *HandshakeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProtocolVersion != 0 {
		n += 1 + sovFlight(uint64(m.ProtocolVersion))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	return n
}

func (m *HandshakeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProtocolVersion != 0 {
		n += 1 + sovFlight(uint64(m.ProtocolVersion))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	return n
}

func (m *BasicAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	return n
}

func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ActionType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	return n
}

func (m *Criteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Expression)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	return n
}

func (m *Action) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	return n
}

func (m *Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	return n
}

func (m *SchemaResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	return n
}

func (m *FlightDescriptor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovFlight(uint64(m.Type))
	}
	l = len(m.Cmd)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	if len(m.Path) > 0 {
		for _, s := range m.Path {
			l = len(s)
			n += 1 + l + sovFlight(uint64(l))
		}
	}
	return n
}

func (m *FlightInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Schema)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	if m.FlightDescriptor != nil {
		l = m.FlightDescriptor.Size()
		n += 1 + l + sovFlight(uint64(l))
	}
	if len(m.Endpoint) > 0 {
		for _, e := range m.Endpoint {
			l = e.Size()
			n += 1 + l + sovFlight(uint64(l))
		}
	}
	if m.TotalRecords != 0 {
		n += 1 + sovFlight(uint64(m.TotalRecords))
	}
	if m.TotalBytes != 0 {
		n += 1 + sovFlight(uint64(m.TotalBytes))
	}
	return n
}

func (m *FlightEndpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ticket != nil {
		l = m.Ticket.Size()
		n += 1 + l + sovFlight(uint64(l))
	}
	if len(m.Location) > 0 {
		for _, e := range m.Location {
			l = e.Size()
			n += 1 + l + sovFlight(uint64(l))
		}
	}
	return n
}

func (m *Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	return n
}

func (m *Ticket) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	return n
}

func (m *FlightData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FlightDescriptor != nil {
		l = m.FlightDescriptor.Size()
		n += 1 + l + sovFlight(uint64(l))
	}
	l = len(m.DataHeader)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	l = len(m.AppMetadata)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	l = len(m.DataBody)
	if l > 0 {
		n += 2 + l + sovFlight(uint64(l))
	}
	return n
}

func (m *PutResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppMetadata)
	if l > 0 {
		n += 1 + l + sovFlight(uint64(l))
	}
	return n
}

func sovFlight(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozFlight(x uint64) (n int) {
	return sovFlight(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HandshakeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandshakeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandshakeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			m.ProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HandshakeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HandshakeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HandshakeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			m.ProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasicAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasicAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasicAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActionType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActionType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActionType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Criteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Criteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Criteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expression", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Expression = append(m.Expression[:0], dAtA[iNdEx:postIndex]...)
			if m.Expression == nil {
				m.Expression = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = append(m.Body[:0], dAtA[iNdEx:postIndex]...)
			if m.Body == nil {
				m.Body = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchemaResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchemaResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchemaResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema[:0], dAtA[iNdEx:postIndex]...)
			if m.Schema == nil {
				m.Schema = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlightDescriptor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlightDescriptor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlightDescriptor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FlightDescriptor_DescriptorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = append(m.Cmd[:0], dAtA[iNdEx:postIndex]...)
			if m.Cmd == nil {
				m.Cmd = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = append(m.Path, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlightInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlightInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlightInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Schema", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Schema = append(m.Schema[:0], dAtA[iNdEx:postIndex]...)
			if m.Schema == nil {
				m.Schema = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlightDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlightDescriptor == nil {
				m.FlightDescriptor = &FlightDescriptor{}
			}
			if err := m.FlightDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = append(m.Endpoint, &FlightEndpoint{})
			if err := m.Endpoint[len(m.Endpoint)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRecords", wireType)
			}
			m.TotalRecords = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalRecords |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalBytes", wireType)
			}
			m.TotalBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlightEndpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlightEndpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlightEndpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ticket == nil {
				m.Ticket = &Ticket{}
			}
			if err := m.Ticket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Location = append(m.Location, &Location{})
			if err := m.Location[len(m.Location)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ticket) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ticket: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ticket: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket[:0], dAtA[iNdEx:postIndex]...)
			if m.Ticket == nil {
				m.Ticket = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlightData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlightData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlightData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlightDescriptor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FlightDescriptor == nil {
				m.FlightDescriptor = &FlightDescriptor{}
			}
			if err := m.FlightDescriptor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataHeader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataHeader = append(m.DataHeader[:0], dAtA[iNdEx:postIndex]...)
			if m.DataHeader == nil {
				m.DataHeader = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppMetadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppMetadata = append(m.AppMetadata[:0], dAtA[iNdEx:postIndex]...)
			if m.AppMetadata == nil {
				m.AppMetadata = []byte{}
			}
			iNdEx = postIndex
		case 1000:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataBody", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataBody = append(m.DataBody[:0], dAtA[iNdEx:postIndex]...)
			if m.DataBody == nil {
				m.DataBody = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppMetadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlight
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlight
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppMetadata = append(m.AppMetadata[:0], dAtA[iNdEx:postIndex]...)
			if m.AppMetadata == nil {
				m.AppMetadata = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlight(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthFlight
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlight(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlight
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlight
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlight
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthFlight
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowFlight
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipFlight(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthFlight
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthFlight = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlight   = fmt.Errorf("proto: integer overflow")
)
