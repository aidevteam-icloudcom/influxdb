// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: iterator.gen.go.tmpl

package tsm1

import (
	"fmt"
	"sort"
	"sync"

	"github.com/influxdata/influxdb/influxql"
	"github.com/influxdata/influxdb/tsdb"
)

type cursor interface {
	close() error
	next() (t int64, v interface{})
	seek(t int64)
}

// cursorAt provides a buffered cursor interface.
// This required for literal value cursors which don't have a time value.
type cursorAt interface {
	close() error
	peek() (k int64, v interface{})
	nextAt(seek int64) interface{}
}

// bufCursor implements a buffered cursor.
type bufCursor struct {
	cur cursor
	buf struct {
		key    int64
		value  interface{}
		filled bool
	}
	ascending bool
}

// newBufCursor returns a buffered wrapper for cur.
func newBufCursor(cur cursor, ascending bool) *bufCursor {
	return &bufCursor{cur: cur, ascending: ascending}
}

func (c *bufCursor) close() error {
	err := c.cur.close()
	c.cur = nil
	return err
}

// next returns the buffer, if filled. Otherwise returns the next key/value from the cursor.
func (c *bufCursor) next() (int64, interface{}) {
	if c.buf.filled {
		k, v := c.buf.key, c.buf.value
		c.buf.filled = false
		return k, v
	}
	return c.cur.next()
}

// unread pushes k and v onto the buffer.
func (c *bufCursor) unread(k int64, v interface{}) {
	c.buf.key, c.buf.value = k, v
	c.buf.filled = true
}

// peek reads next next key/value without removing them from the cursor.
func (c *bufCursor) peek() (k int64, v interface{}) {
	k, v = c.next()
	c.unread(k, v)
	return
}

// nextAt returns the next value where key is equal to seek.
// Skips over any keys that are less than seek.
// If the key doesn't exist then a nil value is returned instead.
func (c *bufCursor) nextAt(seek int64) interface{} {
	for {
		k, v := c.next()
		if k != tsdb.EOF {
			if k == seek {
				return v
			} else if c.ascending && k < seek {
				continue
			} else if !c.ascending && k > seek {
				continue
			}
			c.unread(k, v)
		}

		// Return "nil" value for type.
		switch c.cur.(type) {
		case floatCursor:
			return (*float64)(nil)
		case integerCursor:
			return (*int64)(nil)
		case stringCursor:
			return (*string)(nil)
		case booleanCursor:
			return (*bool)(nil)
		default:
			panic("unreachable")
		}
	}
}

// statsBufferCopyIntervalN is the number of points that are read before
// copying the stats buffer to the iterator's stats field. This is used to
// amortize the cost of using a mutex when updating stats.
const statsBufferCopyIntervalN = 100

type floatIterator struct {
	cur   floatCursor
	aux   []cursorAt
	conds struct {
		names []string
		curs  []cursorAt
	}
	opt influxql.IteratorOptions

	m     map[string]interface{} // map used for condition evaluation
	point influxql.FloatPoint    // reusable buffer

	statsLock sync.Mutex
	stats     influxql.IteratorStats
	statsBuf  influxql.IteratorStats
}

func newFloatIterator(name string, tags influxql.Tags, opt influxql.IteratorOptions, cur floatCursor, aux []cursorAt, conds []cursorAt, condNames []string) *floatIterator {
	itr := &floatIterator{
		cur: cur,
		aux: aux,
		opt: opt,
		point: influxql.FloatPoint{
			Name: name,
			Tags: tags,
		},
		statsBuf: influxql.IteratorStats{
			SeriesN: 1,
		},
	}
	itr.stats = itr.statsBuf

	if len(aux) > 0 {
		itr.point.Aux = make([]interface{}, len(aux))
	}

	if opt.Condition != nil {
		itr.m = make(map[string]interface{}, len(aux)+len(conds))
	}
	itr.conds.names = condNames
	itr.conds.curs = conds

	return itr
}

// Next returns the next point from the iterator.
func (itr *floatIterator) Next() (*influxql.FloatPoint, error) {
	for {
		seek := tsdb.EOF

		if itr.cur != nil {
			// Read from the main cursor if we have one.
			itr.point.Time, itr.point.Value = itr.cur.nextFloat()
			seek = itr.point.Time
		} else {
			// Otherwise find lowest aux timestamp.
			for i := range itr.aux {
				if k, _ := itr.aux[i].peek(); k != tsdb.EOF {
					if seek == tsdb.EOF || (itr.opt.Ascending && k < seek) || (!itr.opt.Ascending && k > seek) {
						seek = k
					}
				}
			}
			itr.point.Time = seek
		}

		// Exit if we have no more points or we are outside our time range.
		if itr.point.Time == tsdb.EOF {
			itr.copyStats()
			return nil, nil
		} else if itr.opt.Ascending && itr.point.Time > itr.opt.EndTime {
			itr.copyStats()
			return nil, nil
		} else if !itr.opt.Ascending && itr.point.Time < itr.opt.StartTime {
			itr.copyStats()
			return nil, nil
		}

		// Read from each auxiliary cursor.
		for i := range itr.opt.Aux {
			itr.point.Aux[i] = itr.aux[i].nextAt(seek)
		}

		// Read from condition field cursors.
		for i := range itr.conds.curs {
			itr.m[itr.conds.names[i]] = itr.conds.curs[i].nextAt(seek)
		}

		// Evaluate condition, if one exists. Retry if it fails.
		if itr.opt.Condition != nil && !influxql.EvalBool(itr.opt.Condition, itr.m) {
			continue
		}

		// Track points returned.
		itr.statsBuf.PointN++

		// Copy buffer to stats periodically.
		if itr.statsBuf.PointN%statsBufferCopyIntervalN == 0 {
			itr.copyStats()
		}

		return &itr.point, nil
	}
}

// copyStats copies from the itr stats buffer to the stats under lock.
func (itr *floatIterator) copyStats() {
	itr.statsLock.Lock()
	itr.stats = itr.statsBuf
	itr.statsLock.Unlock()
}

// Stats returns stats on the points processed.
func (itr *floatIterator) Stats() influxql.IteratorStats {
	itr.statsLock.Lock()
	stats := itr.stats
	itr.statsLock.Unlock()
	return stats
}

// bufCursor returns a buffered cursor so seek operations can be performed.
// If the current cursor isn't a buffered cursor, this wraps it in one automatically.
func (itr *floatIterator) bufCursor() (*bufFloatCursor, error) {
	if itr.cur == nil {
		return nil, influxql.ErrSeekUnavailable
	}

	cur, ok := itr.cur.(*bufFloatCursor)
	if !ok {
		cur = newBufFloatCursor(itr.cur, itr.opt.Ascending)
		itr.cur = cur
	}
	return cur, nil
}

func (itr *floatIterator) SeekTo(t int64) error {
	itr.cur.seek(t)
	return nil
}

func (itr *floatIterator) SeekUntil(t int64) (bool, error) {
	cur, err := itr.bufCursor()
	if err != nil {
		return false, err
	}
	cur.seekUntil(t)

	// Check if the next point is before the seek time.
	k, v := cur.nextFloat()
	ok := (itr.opt.Ascending && k < t) || (!itr.opt.Ascending && k > t)
	cur.unread(k, v)
	return ok, nil
}

// Close closes the iterator.
func (itr *floatIterator) Close() error {
	for _, c := range itr.aux {
		c.close()
	}
	itr.aux = nil
	for _, c := range itr.conds.curs {
		c.close()
	}
	itr.conds.curs = nil
	if itr.cur != nil {
		err := itr.cur.close()
		itr.cur = nil
		return err
	}
	return nil
}

// floatLimitIterator
type floatLimitIterator struct {
	input influxql.FloatIterator
	opt   influxql.IteratorOptions
	n     int
}

func newFloatLimitIterator(input influxql.FloatIterator, opt influxql.IteratorOptions) *floatLimitIterator {
	return &floatLimitIterator{
		input: input,
		opt:   opt,
	}
}

func (itr *floatLimitIterator) Stats() influxql.IteratorStats { return itr.input.Stats() }
func (itr *floatLimitIterator) Close() error                  { return itr.input.Close() }

func (itr *floatLimitIterator) Next() (*influxql.FloatPoint, error) {
	for {
		// Check if we are beyond the limit.
		if (itr.n - itr.opt.Offset) > itr.opt.Limit {
			return nil, nil
		}

		// Read the next point.
		p, err := itr.input.Next()
		if p == nil || err != nil {
			return nil, err
		}

		// Increment counter.
		itr.n++

		// Offsets are handled by a higher level iterator so return all points.
		return p, nil
	}
}

// floatCursor represents an object for iterating over a single float field.
type floatCursor interface {
	cursor
	nextFloat() (t int64, v float64)
}

func newFloatCursor(seek int64, ascending bool, cacheValues Values, tsmKeyCursor *KeyCursor) floatCursor {
	if ascending {
		return newFloatAscendingCursor(seek, cacheValues, tsmKeyCursor)
	}
	return newFloatDescendingCursor(seek, cacheValues, tsmKeyCursor)
}

type floatAscendingCursor struct {
	cache struct {
		values Values
		pos    int
	}

	tsm struct {
		buf       []FloatValue
		values    []FloatValue
		pos       int
		keyCursor *KeyCursor
	}
}

func newFloatAscendingCursor(seek int64, cacheValues Values, tsmKeyCursor *KeyCursor) *floatAscendingCursor {
	c := &floatAscendingCursor{}

	c.cache.values = cacheValues
	c.cache.pos = sort.Search(len(c.cache.values), func(i int) bool {
		return c.cache.values[i].UnixNano() >= seek
	})

	c.tsm.keyCursor = tsmKeyCursor
	c.tsm.buf = make([]FloatValue, 10)
	c.tsm.values, _ = c.tsm.keyCursor.ReadFloatBlock(&c.tsm.buf)
	c.tsm.pos = sort.Search(len(c.tsm.values), func(i int) bool {
		return c.tsm.values[i].UnixNano() >= seek
	})

	return c
}

// peekCache returns the current time/value from the cache.
func (c *floatAscendingCursor) peekCache() (t int64, v float64) {
	if c.cache.pos >= len(c.cache.values) {
		return tsdb.EOF, 0
	}

	item := c.cache.values[c.cache.pos]
	return item.UnixNano(), item.(*FloatValue).value
}

// peekTSM returns the current time/value from tsm.
func (c *floatAscendingCursor) peekTSM() (t int64, v float64) {
	if c.tsm.pos < 0 || c.tsm.pos >= len(c.tsm.values) {
		return tsdb.EOF, 0
	}

	item := c.tsm.values[c.tsm.pos]
	return item.UnixNano(), item.value
}

// close closes the cursor and any dependent cursors.
func (c *floatAscendingCursor) close() error {
	c.tsm.keyCursor.Close()
	c.tsm.keyCursor = nil
	c.tsm.buf = nil
	c.cache.values = nil
	c.tsm.values = nil
	return nil
}

// next returns the next key/value for the cursor.
func (c *floatAscendingCursor) next() (int64, interface{}) { return c.nextFloat() }

// nextFloat returns the next key/value for the cursor.
func (c *floatAscendingCursor) nextFloat() (int64, float64) {
	ckey, cvalue := c.peekCache()
	tkey, tvalue := c.peekTSM()

	// No more data in cache or in TSM files.
	if ckey == tsdb.EOF && tkey == tsdb.EOF {
		return tsdb.EOF, 0
	}

	// Both cache and tsm files have the same key, cache takes precedence.
	if ckey == tkey {
		c.nextCache()
		c.nextTSM()
		return ckey, cvalue
	}

	// Buffered cache key precedes that in TSM file.
	if ckey != tsdb.EOF && (ckey < tkey || tkey == tsdb.EOF) {
		c.nextCache()
		return ckey, cvalue
	}

	// Buffered TSM key precedes that in cache.
	c.nextTSM()
	return tkey, tvalue
}

// nextCache returns the next value from the cache.
func (c *floatAscendingCursor) nextCache() {
	if c.cache.pos >= len(c.cache.values) {
		return
	}
	c.cache.pos++
}

func (c *floatAscendingCursor) seekCache(t int64) {
	if c.cache.pos >= len(c.cache.values) {
		return
	}
	values := c.cache.values[c.cache.pos:]
	i := sort.Search(len(values), func(i int) bool {
		return values[i].UnixNano() >= t
	})
	c.cache.pos += i
}

// nextTSM returns the next value from the TSM files.
func (c *floatAscendingCursor) nextTSM() {
	c.tsm.pos++
	if c.tsm.pos >= len(c.tsm.values) {
		c.tsm.keyCursor.Next()
		c.tsm.values, _ = c.tsm.keyCursor.ReadFloatBlock(&c.tsm.buf)
		if len(c.tsm.values) == 0 {
			return
		}
		c.tsm.pos = 0
	}
}

func (c *floatAscendingCursor) seekTSM(t int64) {
	if c.tsm.pos >= len(c.tsm.values) {
		return
	}

	values := c.tsm.values[c.tsm.pos:]
	i, j := 0, len(values)
	for i < j {
		h := i + (j-i)/2
		if values[h].UnixNano() >= t {
			j = h
		} else {
			i = h + 1
		}
	}
	c.tsm.pos += i

	if c.tsm.pos < len(c.tsm.values) {
		return
	}

	// We did not find a value within the current interval.
	// Seek to the appropriate interval.
	c.tsm.keyCursor.seekAscending(t)
	c.tsm.values, _ = c.tsm.keyCursor.ReadFloatBlock(&c.tsm.buf)
	c.tsm.pos = sort.Search(len(c.tsm.values), func(i int) bool {
		return c.tsm.values[i].UnixNano() >= t
	})
}

func (c *floatAscendingCursor) seek(t int64) {
	c.seekCache(t)
	c.seekTSM(t)
}

type floatDescendingCursor struct {
	cache struct {
		values Values
		pos    int
	}

	tsm struct {
		buf       []FloatValue
		values    []FloatValue
		pos       int
		keyCursor *KeyCursor
	}
}

func newFloatDescendingCursor(seek int64, cacheValues Values, tsmKeyCursor *KeyCursor) *floatDescendingCursor {
	c := &floatDescendingCursor{}

	c.cache.values = cacheValues
	c.cache.pos = sort.Search(len(c.cache.values), func(i int) bool {
		return c.cache.values[i].UnixNano() >= seek
	})
	if t, _ := c.peekCache(); t != seek {
		c.cache.pos--
	}

	c.tsm.keyCursor = tsmKeyCursor
	c.tsm.buf = make([]FloatValue, 10)
	c.tsm.values, _ = c.tsm.keyCursor.ReadFloatBlock(&c.tsm.buf)
	c.tsm.pos = sort.Search(len(c.tsm.values), func(i int) bool {
		return c.tsm.values[i].UnixNano() >= seek
	})
	if t, _ := c.peekTSM(); t != seek {
		c.tsm.pos--
	}

	return c
}

// peekCache returns the current time/value from the cache.
func (c *floatDescendingCursor) peekCache() (t int64, v float64) {
	if c.cache.pos < 0 || c.cache.pos >= len(c.cache.values) {
		return tsdb.EOF, 0
	}

	item := c.cache.values[c.cache.pos]
	return item.UnixNano(), item.(*FloatValue).value
}

// peekTSM returns the current time/value from tsm.
func (c *floatDescendingCursor) peekTSM() (t int64, v float64) {
	if c.tsm.pos < 0 || c.tsm.pos >= len(c.tsm.values) {
		return tsdb.EOF, 0
	}

	item := c.tsm.values[c.tsm.pos]
	return item.UnixNano(), item.value
}

// close closes the cursor and any dependent cursors.
func (c *floatDescendingCursor) close() error {
	c.tsm.keyCursor.Close()
	c.tsm.keyCursor = nil
	c.tsm.buf = nil
	c.cache.values = nil
	c.tsm.values = nil
	return nil
}

// next returns the next key/value for the cursor.
func (c *floatDescendingCursor) next() (int64, interface{}) { return c.nextFloat() }

// nextFloat returns the next key/value for the cursor.
func (c *floatDescendingCursor) nextFloat() (int64, float64) {
	ckey, cvalue := c.peekCache()
	tkey, tvalue := c.peekTSM()

	// No more data in cache or in TSM files.
	if ckey == tsdb.EOF && tkey == tsdb.EOF {
		return tsdb.EOF, 0
	}

	// Both cache and tsm files have the same key, cache takes precedence.
	if ckey == tkey {
		c.nextCache()
		c.nextTSM()
		return ckey, cvalue
	}

	// Buffered cache key precedes that in TSM file.
	if ckey != tsdb.EOF && (ckey > tkey || tkey == tsdb.EOF) {
		c.nextCache()
		return ckey, cvalue
	}

	// Buffered TSM key precedes that in cache.
	c.nextTSM()
	return tkey, tvalue
}

// nextCache returns the next value from the cache.
func (c *floatDescendingCursor) nextCache() {
	if c.cache.pos < 0 {
		return
	}
	c.cache.pos--
}

func (c *floatDescendingCursor) seekCache(t int64) {
}

// nextTSM returns the next value from the TSM files.
func (c *floatDescendingCursor) nextTSM() {
	c.tsm.pos--
	if c.tsm.pos < 0 {
		c.tsm.keyCursor.Next()
		c.tsm.values, _ = c.tsm.keyCursor.ReadFloatBlock(&c.tsm.buf)
		if len(c.tsm.values) == 0 {
			return
		}
		c.tsm.pos = len(c.tsm.values) - 1
	}
}

func (c *floatDescendingCursor) seekTSM(t int64) {
}

func (c *floatDescendingCursor) seek(t int64) {
	c.seekCache(t)
	c.seekTSM(t)
}

// bufFloatCursor provides a ring buffer to support seeking in a cursor.
type bufFloatCursor struct {
	cur floatCursor
	buf [2]struct {
		key    int64
		value  float64
		filled bool
	}
	ascending bool
}

// newBufFloatCursor returns a buffered wrapper for cur.
func newBufFloatCursor(cur floatCursor, ascending bool) *bufFloatCursor {
	return &bufFloatCursor{cur: cur, ascending: ascending}
}

func (c *bufFloatCursor) close() error               { return c.cur.close() }
func (c *bufFloatCursor) next() (int64, interface{}) { return c.nextFloat() }

func (c *bufFloatCursor) nextFloat() (int64, float64) {
	if c.buf[0].filled {
		k, v := c.buf[0].key, c.buf[0].value
		c.buf[0] = c.buf[1]
		c.buf[1].filled = false
		return k, v
	}
	return c.cur.nextFloat()
}

func (c *bufFloatCursor) unread(k int64, v float64) {
	c.buf[1] = c.buf[0]
	c.buf[0].key, c.buf[0].value = k, v
	c.buf[0].filled = true
}

func (c *bufFloatCursor) seek(t int64) {
	c.cur.seek(t)
}

func (c *bufFloatCursor) seekAt(seek int64) {
	for {
		k, v := c.nextFloat()
		if k == tsdb.EOF {
			break
		}

		if c.ascending && k < seek {
			continue
		} else if !c.ascending && k > seek {
			continue
		}
		c.unread(k, v)
		return
	}
}

func (c *bufFloatCursor) seekUntil(seek int64) {
	for {
		k, v := c.nextFloat()
		if k == tsdb.EOF {
			break
		}

		if c.ascending && k < seek {
			c.unread(k, v)
			continue
		} else if !c.ascending && k > seek {
			c.unread(k, v)
			continue
		}
		c.unread(k, v)
		return
	}
}

// floatLiteralCursor represents a cursor that always returns a single value.
// It doesn't not have a time value so it can only be used with nextAt().
type floatLiteralCursor struct {
	value float64
}

func (c *floatLiteralCursor) close() error                   { return nil }
func (c *floatLiteralCursor) peek() (t int64, v interface{}) { return tsdb.EOF, c.value }
func (c *floatLiteralCursor) next() (t int64, v interface{}) { return tsdb.EOF, c.value }
func (c *floatLiteralCursor) nextAt(seek int64) interface{}  { return c.value }

// floatNilLiteralCursor represents a cursor that always returns a typed nil value.
// It doesn't not have a time value so it can only be used with nextAt().
type floatNilLiteralCursor struct{}

func (c *floatNilLiteralCursor) close() error                   { return nil }
func (c *floatNilLiteralCursor) peek() (t int64, v interface{}) { return tsdb.EOF, (*float64)(nil) }
func (c *floatNilLiteralCursor) next() (t int64, v interface{}) { return tsdb.EOF, (*float64)(nil) }
func (c *floatNilLiteralCursor) nextAt(seek int64) interface{}  { return (*float64)(nil) }

// firstFloatIterator returns the first value from each window for an iterator.
type firstFloatIterator struct {
	input influxql.SeekFloatIterator
	opt   influxql.IteratorOptions
	point influxql.FloatPoint
}

func newFirstFloatIterator(input influxql.SeekFloatIterator, opt influxql.IteratorOptions) *firstFloatIterator {
	return &firstFloatIterator{
		input: input,
		opt:   opt,
		point: influxql.FloatPoint{Nil: true},
	}
}

func (itr *firstFloatIterator) Close() error                  { return itr.input.Close() }
func (itr *firstFloatIterator) Stats() influxql.IteratorStats { return itr.input.Stats() }

func (itr *firstFloatIterator) Next() (*influxql.FloatPoint, error) {
	// Seek to the next point if we have read a previous point.
	if !itr.point.Nil {
		// If we do not have an interval, return immediately.
		if itr.opt.Interval.IsZero() {
			return nil, nil
		}

		start, _ := itr.opt.Window(itr.point.Time)
		if itr.opt.Ascending {
			// Ascending iterator needs to move to the future interval.
			start += int64(itr.opt.Interval.Duration)
		} else {
			// The start time of the current interval is the end time of the past interval
			// we need to move to. This is intentionally left empty for this comment.
		}

		// Seek to at least the next interval's start time. This may not get us the
		// time interval that is in start, but it will at least get us the next new
		// time interval.
		if err := itr.input.SeekTo(start); err != nil {
			return nil, err
		}
	}

	p, err := itr.input.Next()
	if p == nil || err != nil {
		itr.point.Nil = true
		return p, err
	}
	itr.point = *p
	return p.Clone(), nil
}

// lastFloatIterator returns the first value from each window for an iterator.
type lastFloatIterator struct {
	input influxql.SeekFloatIterator
	opt   influxql.IteratorOptions
	point influxql.FloatPoint
}

func newLastFloatIterator(input influxql.SeekFloatIterator, opt influxql.IteratorOptions) *lastFloatIterator {
	return &lastFloatIterator{
		input: input,
		opt:   opt,
		point: influxql.FloatPoint{Nil: true},
	}
}

func (itr *lastFloatIterator) Close() error                  { return itr.input.Close() }
func (itr *lastFloatIterator) Stats() influxql.IteratorStats { return itr.input.Stats() }

func (itr *lastFloatIterator) Next() (*influxql.FloatPoint, error) {
	// Seek to the next point if we have read a previous point.
	if !itr.point.Nil {
		// If we do not have an interval, return immediately.
		if itr.opt.Interval.IsZero() {
			return nil, nil
		}
	}

	_, end := itr.opt.Window(itr.point.Time)
	if itr.opt.Ascending {
		// Ascending iterator needs to move to the future interval.
		end += int64(itr.opt.Interval.Duration)
	} else {
		// The start time of the current interval is the end time of the past interval
		// we need to move to. This is intentionally left empty for this comment.
	}

	for {
		// Seek to at least the next interval's start time. This may not get us the
		// time interval that is in start, but it will at least get us the next new
		// time interval.
		if ok, err := itr.input.SeekUntil(end); err != nil {
			return nil, err
		} else if ok {
			break
		}

		duration := int64(itr.opt.Interval.Duration)
		if !itr.opt.Ascending {
			duration = -duration
		}
		end += duration
	}

	p, err := itr.input.Next()
	if p == nil || err != nil {
		itr.point.Nil = true
		return p, err
	}
	itr.point = *p
	return &itr.point, nil
}

type integerIterator struct {
	cur   integerCursor
	aux   []cursorAt
	conds struct {
		names []string
		curs  []cursorAt
	}
	opt influxql.IteratorOptions

	m     map[string]interface{} // map used for condition evaluation
	point influxql.IntegerPoint  // reusable buffer

	statsLock sync.Mutex
	stats     influxql.IteratorStats
	statsBuf  influxql.IteratorStats
}

func newIntegerIterator(name string, tags influxql.Tags, opt influxql.IteratorOptions, cur integerCursor, aux []cursorAt, conds []cursorAt, condNames []string) *integerIterator {
	itr := &integerIterator{
		cur: cur,
		aux: aux,
		opt: opt,
		point: influxql.IntegerPoint{
			Name: name,
			Tags: tags,
		},
		statsBuf: influxql.IteratorStats{
			SeriesN: 1,
		},
	}
	itr.stats = itr.statsBuf

	if len(aux) > 0 {
		itr.point.Aux = make([]interface{}, len(aux))
	}

	if opt.Condition != nil {
		itr.m = make(map[string]interface{}, len(aux)+len(conds))
	}
	itr.conds.names = condNames
	itr.conds.curs = conds

	return itr
}

// Next returns the next point from the iterator.
func (itr *integerIterator) Next() (*influxql.IntegerPoint, error) {
	for {
		seek := tsdb.EOF

		if itr.cur != nil {
			// Read from the main cursor if we have one.
			itr.point.Time, itr.point.Value = itr.cur.nextInteger()
			seek = itr.point.Time
		} else {
			// Otherwise find lowest aux timestamp.
			for i := range itr.aux {
				if k, _ := itr.aux[i].peek(); k != tsdb.EOF {
					if seek == tsdb.EOF || (itr.opt.Ascending && k < seek) || (!itr.opt.Ascending && k > seek) {
						seek = k
					}
				}
			}
			itr.point.Time = seek
		}

		// Exit if we have no more points or we are outside our time range.
		if itr.point.Time == tsdb.EOF {
			itr.copyStats()
			return nil, nil
		} else if itr.opt.Ascending && itr.point.Time > itr.opt.EndTime {
			itr.copyStats()
			return nil, nil
		} else if !itr.opt.Ascending && itr.point.Time < itr.opt.StartTime {
			itr.copyStats()
			return nil, nil
		}

		// Read from each auxiliary cursor.
		for i := range itr.opt.Aux {
			itr.point.Aux[i] = itr.aux[i].nextAt(seek)
		}

		// Read from condition field cursors.
		for i := range itr.conds.curs {
			itr.m[itr.conds.names[i]] = itr.conds.curs[i].nextAt(seek)
		}

		// Evaluate condition, if one exists. Retry if it fails.
		if itr.opt.Condition != nil && !influxql.EvalBool(itr.opt.Condition, itr.m) {
			continue
		}

		// Track points returned.
		itr.statsBuf.PointN++

		// Copy buffer to stats periodically.
		if itr.statsBuf.PointN%statsBufferCopyIntervalN == 0 {
			itr.copyStats()
		}

		return &itr.point, nil
	}
}

// copyStats copies from the itr stats buffer to the stats under lock.
func (itr *integerIterator) copyStats() {
	itr.statsLock.Lock()
	itr.stats = itr.statsBuf
	itr.statsLock.Unlock()
}

// Stats returns stats on the points processed.
func (itr *integerIterator) Stats() influxql.IteratorStats {
	itr.statsLock.Lock()
	stats := itr.stats
	itr.statsLock.Unlock()
	return stats
}

// bufCursor returns a buffered cursor so seek operations can be performed.
// If the current cursor isn't a buffered cursor, this wraps it in one automatically.
func (itr *integerIterator) bufCursor() (*bufIntegerCursor, error) {
	if itr.cur == nil {
		return nil, influxql.ErrSeekUnavailable
	}

	cur, ok := itr.cur.(*bufIntegerCursor)
	if !ok {
		cur = newBufIntegerCursor(itr.cur, itr.opt.Ascending)
		itr.cur = cur
	}
	return cur, nil
}

func (itr *integerIterator) SeekTo(t int64) error {
	itr.cur.seek(t)
	return nil
}

func (itr *integerIterator) SeekUntil(t int64) (bool, error) {
	cur, err := itr.bufCursor()
	if err != nil {
		return false, err
	}
	cur.seekUntil(t)

	// Check if the next point is before the seek time.
	k, v := cur.nextInteger()
	ok := (itr.opt.Ascending && k < t) || (!itr.opt.Ascending && k > t)
	cur.unread(k, v)
	return ok, nil
}

// Close closes the iterator.
func (itr *integerIterator) Close() error {
	for _, c := range itr.aux {
		c.close()
	}
	itr.aux = nil
	for _, c := range itr.conds.curs {
		c.close()
	}
	itr.conds.curs = nil
	if itr.cur != nil {
		err := itr.cur.close()
		itr.cur = nil
		return err
	}
	return nil
}

// integerLimitIterator
type integerLimitIterator struct {
	input influxql.IntegerIterator
	opt   influxql.IteratorOptions
	n     int
}

func newIntegerLimitIterator(input influxql.IntegerIterator, opt influxql.IteratorOptions) *integerLimitIterator {
	return &integerLimitIterator{
		input: input,
		opt:   opt,
	}
}

func (itr *integerLimitIterator) Stats() influxql.IteratorStats { return itr.input.Stats() }
func (itr *integerLimitIterator) Close() error                  { return itr.input.Close() }

func (itr *integerLimitIterator) Next() (*influxql.IntegerPoint, error) {
	for {
		// Check if we are beyond the limit.
		if (itr.n - itr.opt.Offset) > itr.opt.Limit {
			return nil, nil
		}

		// Read the next point.
		p, err := itr.input.Next()
		if p == nil || err != nil {
			return nil, err
		}

		// Increment counter.
		itr.n++

		// Offsets are handled by a higher level iterator so return all points.
		return p, nil
	}
}

// integerCursor represents an object for iterating over a single integer field.
type integerCursor interface {
	cursor
	nextInteger() (t int64, v int64)
}

func newIntegerCursor(seek int64, ascending bool, cacheValues Values, tsmKeyCursor *KeyCursor) integerCursor {
	if ascending {
		return newIntegerAscendingCursor(seek, cacheValues, tsmKeyCursor)
	}
	return newIntegerDescendingCursor(seek, cacheValues, tsmKeyCursor)
}

type integerAscendingCursor struct {
	cache struct {
		values Values
		pos    int
	}

	tsm struct {
		buf       []IntegerValue
		values    []IntegerValue
		pos       int
		keyCursor *KeyCursor
	}
}

func newIntegerAscendingCursor(seek int64, cacheValues Values, tsmKeyCursor *KeyCursor) *integerAscendingCursor {
	c := &integerAscendingCursor{}

	c.cache.values = cacheValues
	c.cache.pos = sort.Search(len(c.cache.values), func(i int) bool {
		return c.cache.values[i].UnixNano() >= seek
	})

	c.tsm.keyCursor = tsmKeyCursor
	c.tsm.buf = make([]IntegerValue, 10)
	c.tsm.values, _ = c.tsm.keyCursor.ReadIntegerBlock(&c.tsm.buf)
	c.tsm.pos = sort.Search(len(c.tsm.values), func(i int) bool {
		return c.tsm.values[i].UnixNano() >= seek
	})

	return c
}

// peekCache returns the current time/value from the cache.
func (c *integerAscendingCursor) peekCache() (t int64, v int64) {
	if c.cache.pos >= len(c.cache.values) {
		return tsdb.EOF, 0
	}

	item := c.cache.values[c.cache.pos]
	return item.UnixNano(), item.(*IntegerValue).value
}

// peekTSM returns the current time/value from tsm.
func (c *integerAscendingCursor) peekTSM() (t int64, v int64) {
	if c.tsm.pos < 0 || c.tsm.pos >= len(c.tsm.values) {
		return tsdb.EOF, 0
	}

	item := c.tsm.values[c.tsm.pos]
	return item.UnixNano(), item.value
}

// close closes the cursor and any dependent cursors.
func (c *integerAscendingCursor) close() error {
	c.tsm.keyCursor.Close()
	c.tsm.keyCursor = nil
	c.tsm.buf = nil
	c.cache.values = nil
	c.tsm.values = nil
	return nil
}

// next returns the next key/value for the cursor.
func (c *integerAscendingCursor) next() (int64, interface{}) { return c.nextInteger() }

// nextInteger returns the next key/value for the cursor.
func (c *integerAscendingCursor) nextInteger() (int64, int64) {
	ckey, cvalue := c.peekCache()
	tkey, tvalue := c.peekTSM()

	// No more data in cache or in TSM files.
	if ckey == tsdb.EOF && tkey == tsdb.EOF {
		return tsdb.EOF, 0
	}

	// Both cache and tsm files have the same key, cache takes precedence.
	if ckey == tkey {
		c.nextCache()
		c.nextTSM()
		return ckey, cvalue
	}

	// Buffered cache key precedes that in TSM file.
	if ckey != tsdb.EOF && (ckey < tkey || tkey == tsdb.EOF) {
		c.nextCache()
		return ckey, cvalue
	}

	// Buffered TSM key precedes that in cache.
	c.nextTSM()
	return tkey, tvalue
}

// nextCache returns the next value from the cache.
func (c *integerAscendingCursor) nextCache() {
	if c.cache.pos >= len(c.cache.values) {
		return
	}
	c.cache.pos++
}

func (c *integerAscendingCursor) seekCache(t int64) {
	if c.cache.pos >= len(c.cache.values) {
		return
	}
	values := c.cache.values[c.cache.pos:]
	i := sort.Search(len(values), func(i int) bool {
		return values[i].UnixNano() >= t
	})
	c.cache.pos += i
}

// nextTSM returns the next value from the TSM files.
func (c *integerAscendingCursor) nextTSM() {
	c.tsm.pos++
	if c.tsm.pos >= len(c.tsm.values) {
		c.tsm.keyCursor.Next()
		c.tsm.values, _ = c.tsm.keyCursor.ReadIntegerBlock(&c.tsm.buf)
		if len(c.tsm.values) == 0 {
			return
		}
		c.tsm.pos = 0
	}
}

func (c *integerAscendingCursor) seekTSM(t int64) {
	if c.tsm.pos >= len(c.tsm.values) {
		return
	}

	values := c.tsm.values[c.tsm.pos:]
	tmin, tmax := 0, len(values)
	for tmin < tmax {
		h := tmin + (tmax-tmin)/2
		if values[h].UnixNano() >= t {
			tmax = h
		} else {
			tmin = h + 1
		}
	}
	c.tsm.pos += tmin

	if c.tsm.pos < len(c.tsm.values) {
		return
	}

	// We did not find a value within the current interval.
	// Seek to the appropriate interval.
	c.tsm.keyCursor.seekAscending(t)
	c.tsm.values, _ = c.tsm.keyCursor.ReadIntegerBlock(&c.tsm.buf)
	c.tsm.pos = sort.Search(len(c.tsm.values), func(i int) bool {
		return c.tsm.values[i].UnixNano() >= t
	})
}

func (c *integerAscendingCursor) seek(t int64) {
	c.seekCache(t)
	c.seekTSM(t)
}

type integerDescendingCursor struct {
	cache struct {
		values Values
		pos    int
	}

	tsm struct {
		buf       []IntegerValue
		values    []IntegerValue
		pos       int
		keyCursor *KeyCursor
	}
}

func newIntegerDescendingCursor(seek int64, cacheValues Values, tsmKeyCursor *KeyCursor) *integerDescendingCursor {
	c := &integerDescendingCursor{}

	c.cache.values = cacheValues
	c.cache.pos = sort.Search(len(c.cache.values), func(i int) bool {
		return c.cache.values[i].UnixNano() >= seek
	})
	if t, _ := c.peekCache(); t != seek {
		c.cache.pos--
	}

	c.tsm.keyCursor = tsmKeyCursor
	c.tsm.buf = make([]IntegerValue, 10)
	c.tsm.values, _ = c.tsm.keyCursor.ReadIntegerBlock(&c.tsm.buf)
	c.tsm.pos = sort.Search(len(c.tsm.values), func(i int) bool {
		return c.tsm.values[i].UnixNano() >= seek
	})
	if t, _ := c.peekTSM(); t != seek {
		c.tsm.pos--
	}

	return c
}

// peekCache returns the current time/value from the cache.
func (c *integerDescendingCursor) peekCache() (t int64, v int64) {
	if c.cache.pos < 0 || c.cache.pos >= len(c.cache.values) {
		return tsdb.EOF, 0
	}

	item := c.cache.values[c.cache.pos]
	return item.UnixNano(), item.(*IntegerValue).value
}

// peekTSM returns the current time/value from tsm.
func (c *integerDescendingCursor) peekTSM() (t int64, v int64) {
	if c.tsm.pos < 0 || c.tsm.pos >= len(c.tsm.values) {
		return tsdb.EOF, 0
	}

	item := c.tsm.values[c.tsm.pos]
	return item.UnixNano(), item.value
}

// close closes the cursor and any dependent cursors.
func (c *integerDescendingCursor) close() error {
	c.tsm.keyCursor.Close()
	c.tsm.keyCursor = nil
	c.tsm.buf = nil
	c.cache.values = nil
	c.tsm.values = nil
	return nil
}

// next returns the next key/value for the cursor.
func (c *integerDescendingCursor) next() (int64, interface{}) { return c.nextInteger() }

// nextInteger returns the next key/value for the cursor.
func (c *integerDescendingCursor) nextInteger() (int64, int64) {
	ckey, cvalue := c.peekCache()
	tkey, tvalue := c.peekTSM()

	// No more data in cache or in TSM files.
	if ckey == tsdb.EOF && tkey == tsdb.EOF {
		return tsdb.EOF, 0
	}

	// Both cache and tsm files have the same key, cache takes precedence.
	if ckey == tkey {
		c.nextCache()
		c.nextTSM()
		return ckey, cvalue
	}

	// Buffered cache key precedes that in TSM file.
	if ckey != tsdb.EOF && (ckey > tkey || tkey == tsdb.EOF) {
		c.nextCache()
		return ckey, cvalue
	}

	// Buffered TSM key precedes that in cache.
	c.nextTSM()
	return tkey, tvalue
}

// nextCache returns the next value from the cache.
func (c *integerDescendingCursor) nextCache() {
	if c.cache.pos < 0 {
		return
	}
	c.cache.pos--
}

func (c *integerDescendingCursor) seekCache(t int64) {
}

// nextTSM returns the next value from the TSM files.
func (c *integerDescendingCursor) nextTSM() {
	c.tsm.pos--
	if c.tsm.pos < 0 {
		c.tsm.keyCursor.Next()
		c.tsm.values, _ = c.tsm.keyCursor.ReadIntegerBlock(&c.tsm.buf)
		if len(c.tsm.values) == 0 {
			return
		}
		c.tsm.pos = len(c.tsm.values) - 1
	}
}

func (c *integerDescendingCursor) seekTSM(t int64) {
}

func (c *integerDescendingCursor) seek(t int64) {
	c.seekCache(t)
	c.seekTSM(t)
}

// bufIntegerCursor provides a ring buffer to support seeking in a cursor.
type bufIntegerCursor struct {
	cur integerCursor
	buf [2]struct {
		key    int64
		value  int64
		filled bool
	}
	ascending bool
}

// newBufIntegerCursor returns a buffered wrapper for cur.
func newBufIntegerCursor(cur integerCursor, ascending bool) *bufIntegerCursor {
	return &bufIntegerCursor{cur: cur, ascending: ascending}
}

func (c *bufIntegerCursor) close() error               { return c.cur.close() }
func (c *bufIntegerCursor) next() (int64, interface{}) { return c.nextInteger() }

func (c *bufIntegerCursor) nextInteger() (int64, int64) {
	if c.buf[0].filled {
		k, v := c.buf[0].key, c.buf[0].value
		c.buf[0] = c.buf[1]
		c.buf[1].filled = false
		return k, v
	}
	return c.cur.nextInteger()
}

func (c *bufIntegerCursor) unread(k int64, v int64) {
	c.buf[1] = c.buf[0]
	c.buf[0].key, c.buf[0].value = k, v
	c.buf[0].filled = true
}

func (c *bufIntegerCursor) seek(t int64) {
	c.cur.seek(t)
}

func (c *bufIntegerCursor) seekAt(seek int64) {
	for {
		k, v := c.nextInteger()
		if k == tsdb.EOF {
			break
		}

		if c.ascending && k < seek {
			continue
		} else if !c.ascending && k > seek {
			continue
		}
		c.unread(k, v)
		return
	}
}

func (c *bufIntegerCursor) seekUntil(seek int64) {
	for {
		k, v := c.nextInteger()
		if k == tsdb.EOF {
			break
		}

		if c.ascending && k < seek {
			c.unread(k, v)
			continue
		} else if !c.ascending && k > seek {
			c.unread(k, v)
			continue
		}
		c.unread(k, v)
		return
	}
}

// integerLiteralCursor represents a cursor that always returns a single value.
// It doesn't not have a time value so it can only be used with nextAt().
type integerLiteralCursor struct {
	value int64
}

func (c *integerLiteralCursor) close() error                   { return nil }
func (c *integerLiteralCursor) peek() (t int64, v interface{}) { return tsdb.EOF, c.value }
func (c *integerLiteralCursor) next() (t int64, v interface{}) { return tsdb.EOF, c.value }
func (c *integerLiteralCursor) nextAt(seek int64) interface{}  { return c.value }

// integerNilLiteralCursor represents a cursor that always returns a typed nil value.
// It doesn't not have a time value so it can only be used with nextAt().
type integerNilLiteralCursor struct{}

func (c *integerNilLiteralCursor) close() error                   { return nil }
func (c *integerNilLiteralCursor) peek() (t int64, v interface{}) { return tsdb.EOF, (*int64)(nil) }
func (c *integerNilLiteralCursor) next() (t int64, v interface{}) { return tsdb.EOF, (*int64)(nil) }
func (c *integerNilLiteralCursor) nextAt(seek int64) interface{}  { return (*int64)(nil) }

// firstIntegerIterator returns the first value from each window for an iterator.
type firstIntegerIterator struct {
	input influxql.SeekIntegerIterator
	opt   influxql.IteratorOptions
	point influxql.IntegerPoint
}

func newFirstIntegerIterator(input influxql.SeekIntegerIterator, opt influxql.IteratorOptions) *firstIntegerIterator {
	return &firstIntegerIterator{
		input: input,
		opt:   opt,
		point: influxql.IntegerPoint{Nil: true},
	}
}

func (itr *firstIntegerIterator) Close() error                  { return itr.input.Close() }
func (itr *firstIntegerIterator) Stats() influxql.IteratorStats { return itr.input.Stats() }

func (itr *firstIntegerIterator) Next() (*influxql.IntegerPoint, error) {
	// Seek to the next point if we have read a previous point.
	if !itr.point.Nil {
		// If we do not have an interval, return immediately.
		if itr.opt.Interval.IsZero() {
			return nil, nil
		}

		start, _ := itr.opt.Window(itr.point.Time)
		if itr.opt.Ascending {
			// Ascending iterator needs to move to the future interval.
			start += int64(itr.opt.Interval.Duration)
		} else {
			// The start time of the current interval is the end time of the past interval
			// we need to move to. This is intentionally left empty for this comment.
		}

		// Seek to at least the next interval's start time. This may not get us the
		// time interval that is in start, but it will at least get us the next new
		// time interval.
		if err := itr.input.SeekTo(start); err != nil {
			return nil, err
		}
	}

	p, err := itr.input.Next()
	if p == nil || err != nil {
		itr.point.Nil = true
		return p, err
	}
	itr.point = *p
	return p.Clone(), nil
}

// lastIntegerIterator returns the first value from each window for an iterator.
type lastIntegerIterator struct {
	input influxql.SeekIntegerIterator
	opt   influxql.IteratorOptions
	point influxql.IntegerPoint
}

func newLastIntegerIterator(input influxql.SeekIntegerIterator, opt influxql.IteratorOptions) *lastIntegerIterator {
	return &lastIntegerIterator{
		input: input,
		opt:   opt,
		point: influxql.IntegerPoint{Nil: true},
	}
}

func (itr *lastIntegerIterator) Close() error                  { return itr.input.Close() }
func (itr *lastIntegerIterator) Stats() influxql.IteratorStats { return itr.input.Stats() }

func (itr *lastIntegerIterator) Next() (*influxql.IntegerPoint, error) {
	// Seek to the next point if we have read a previous point.
	if !itr.point.Nil {
		// If we do not have an interval, return immediately.
		if itr.opt.Interval.IsZero() {
			return nil, nil
		}
	}

	_, end := itr.opt.Window(itr.point.Time)
	if itr.opt.Ascending {
		// Ascending iterator needs to move to the future interval.
		end += int64(itr.opt.Interval.Duration)
	} else {
		// The start time of the current interval is the end time of the past interval
		// we need to move to. This is intentionally left empty for this comment.
	}

	for {
		// Seek to at least the next interval's start time. This may not get us the
		// time interval that is in start, but it will at least get us the next new
		// time interval.
		if ok, err := itr.input.SeekUntil(end); err != nil {
			return nil, err
		} else if ok {
			break
		}

		duration := int64(itr.opt.Interval.Duration)
		if !itr.opt.Ascending {
			duration = -duration
		}
		end += duration
	}

	p, err := itr.input.Next()
	if p == nil || err != nil {
		itr.point.Nil = true
		return p, err
	}
	itr.point = *p
	return &itr.point, nil
}

type stringIterator struct {
	cur   stringCursor
	aux   []cursorAt
	conds struct {
		names []string
		curs  []cursorAt
	}
	opt influxql.IteratorOptions

	m     map[string]interface{} // map used for condition evaluation
	point influxql.StringPoint   // reusable buffer

	statsLock sync.Mutex
	stats     influxql.IteratorStats
	statsBuf  influxql.IteratorStats
}

func newStringIterator(name string, tags influxql.Tags, opt influxql.IteratorOptions, cur stringCursor, aux []cursorAt, conds []cursorAt, condNames []string) *stringIterator {
	itr := &stringIterator{
		cur: cur,
		aux: aux,
		opt: opt,
		point: influxql.StringPoint{
			Name: name,
			Tags: tags,
		},
		statsBuf: influxql.IteratorStats{
			SeriesN: 1,
		},
	}
	itr.stats = itr.statsBuf

	if len(aux) > 0 {
		itr.point.Aux = make([]interface{}, len(aux))
	}

	if opt.Condition != nil {
		itr.m = make(map[string]interface{}, len(aux)+len(conds))
	}
	itr.conds.names = condNames
	itr.conds.curs = conds

	return itr
}

// Next returns the next point from the iterator.
func (itr *stringIterator) Next() (*influxql.StringPoint, error) {
	for {
		seek := tsdb.EOF

		if itr.cur != nil {
			// Read from the main cursor if we have one.
			itr.point.Time, itr.point.Value = itr.cur.nextString()
			seek = itr.point.Time
		} else {
			// Otherwise find lowest aux timestamp.
			for i := range itr.aux {
				if k, _ := itr.aux[i].peek(); k != tsdb.EOF {
					if seek == tsdb.EOF || (itr.opt.Ascending && k < seek) || (!itr.opt.Ascending && k > seek) {
						seek = k
					}
				}
			}
			itr.point.Time = seek
		}

		// Exit if we have no more points or we are outside our time range.
		if itr.point.Time == tsdb.EOF {
			itr.copyStats()
			return nil, nil
		} else if itr.opt.Ascending && itr.point.Time > itr.opt.EndTime {
			itr.copyStats()
			return nil, nil
		} else if !itr.opt.Ascending && itr.point.Time < itr.opt.StartTime {
			itr.copyStats()
			return nil, nil
		}

		// Read from each auxiliary cursor.
		for i := range itr.opt.Aux {
			itr.point.Aux[i] = itr.aux[i].nextAt(seek)
		}

		// Read from condition field cursors.
		for i := range itr.conds.curs {
			itr.m[itr.conds.names[i]] = itr.conds.curs[i].nextAt(seek)
		}

		// Evaluate condition, if one exists. Retry if it fails.
		if itr.opt.Condition != nil && !influxql.EvalBool(itr.opt.Condition, itr.m) {
			continue
		}

		// Track points returned.
		itr.statsBuf.PointN++

		// Copy buffer to stats periodically.
		if itr.statsBuf.PointN%statsBufferCopyIntervalN == 0 {
			itr.copyStats()
		}

		return &itr.point, nil
	}
}

// copyStats copies from the itr stats buffer to the stats under lock.
func (itr *stringIterator) copyStats() {
	itr.statsLock.Lock()
	itr.stats = itr.statsBuf
	itr.statsLock.Unlock()
}

// Stats returns stats on the points processed.
func (itr *stringIterator) Stats() influxql.IteratorStats {
	itr.statsLock.Lock()
	stats := itr.stats
	itr.statsLock.Unlock()
	return stats
}

// bufCursor returns a buffered cursor so seek operations can be performed.
// If the current cursor isn't a buffered cursor, this wraps it in one automatically.
func (itr *stringIterator) bufCursor() (*bufStringCursor, error) {
	if itr.cur == nil {
		return nil, influxql.ErrSeekUnavailable
	}

	cur, ok := itr.cur.(*bufStringCursor)
	if !ok {
		cur = newBufStringCursor(itr.cur, itr.opt.Ascending)
		itr.cur = cur
	}
	return cur, nil
}

func (itr *stringIterator) SeekTo(t int64) error {
	itr.cur.seek(t)
	return nil
}

func (itr *stringIterator) SeekUntil(t int64) (bool, error) {
	cur, err := itr.bufCursor()
	if err != nil {
		return false, err
	}
	cur.seekUntil(t)

	// Check if the next point is before the seek time.
	k, v := cur.nextString()
	ok := (itr.opt.Ascending && k < t) || (!itr.opt.Ascending && k > t)
	cur.unread(k, v)
	return ok, nil
}

// Close closes the iterator.
func (itr *stringIterator) Close() error {
	for _, c := range itr.aux {
		c.close()
	}
	itr.aux = nil
	for _, c := range itr.conds.curs {
		c.close()
	}
	itr.conds.curs = nil
	if itr.cur != nil {
		err := itr.cur.close()
		itr.cur = nil
		return err
	}
	return nil
}

// stringLimitIterator
type stringLimitIterator struct {
	input influxql.StringIterator
	opt   influxql.IteratorOptions
	n     int
}

func newStringLimitIterator(input influxql.StringIterator, opt influxql.IteratorOptions) *stringLimitIterator {
	return &stringLimitIterator{
		input: input,
		opt:   opt,
	}
}

func (itr *stringLimitIterator) Stats() influxql.IteratorStats { return itr.input.Stats() }
func (itr *stringLimitIterator) Close() error                  { return itr.input.Close() }

func (itr *stringLimitIterator) Next() (*influxql.StringPoint, error) {
	for {
		// Check if we are beyond the limit.
		if (itr.n - itr.opt.Offset) > itr.opt.Limit {
			return nil, nil
		}

		// Read the next point.
		p, err := itr.input.Next()
		if p == nil || err != nil {
			return nil, err
		}

		// Increment counter.
		itr.n++

		// Offsets are handled by a higher level iterator so return all points.
		return p, nil
	}
}

// stringCursor represents an object for iterating over a single string field.
type stringCursor interface {
	cursor
	nextString() (t int64, v string)
}

func newStringCursor(seek int64, ascending bool, cacheValues Values, tsmKeyCursor *KeyCursor) stringCursor {
	if ascending {
		return newStringAscendingCursor(seek, cacheValues, tsmKeyCursor)
	}
	return newStringDescendingCursor(seek, cacheValues, tsmKeyCursor)
}

type stringAscendingCursor struct {
	cache struct {
		values Values
		pos    int
	}

	tsm struct {
		buf       []StringValue
		values    []StringValue
		pos       int
		keyCursor *KeyCursor
	}
}

func newStringAscendingCursor(seek int64, cacheValues Values, tsmKeyCursor *KeyCursor) *stringAscendingCursor {
	c := &stringAscendingCursor{}

	c.cache.values = cacheValues
	c.cache.pos = sort.Search(len(c.cache.values), func(i int) bool {
		return c.cache.values[i].UnixNano() >= seek
	})

	c.tsm.keyCursor = tsmKeyCursor
	c.tsm.buf = make([]StringValue, 10)
	c.tsm.values, _ = c.tsm.keyCursor.ReadStringBlock(&c.tsm.buf)
	c.tsm.pos = sort.Search(len(c.tsm.values), func(i int) bool {
		return c.tsm.values[i].UnixNano() >= seek
	})

	return c
}

// peekCache returns the current time/value from the cache.
func (c *stringAscendingCursor) peekCache() (t int64, v string) {
	if c.cache.pos >= len(c.cache.values) {
		return tsdb.EOF, ""
	}

	item := c.cache.values[c.cache.pos]
	return item.UnixNano(), item.(*StringValue).value
}

// peekTSM returns the current time/value from tsm.
func (c *stringAscendingCursor) peekTSM() (t int64, v string) {
	if c.tsm.pos < 0 || c.tsm.pos >= len(c.tsm.values) {
		return tsdb.EOF, ""
	}

	item := c.tsm.values[c.tsm.pos]
	return item.UnixNano(), item.value
}

// close closes the cursor and any dependent cursors.
func (c *stringAscendingCursor) close() error {
	c.tsm.keyCursor.Close()
	c.tsm.keyCursor = nil
	c.tsm.buf = nil
	c.cache.values = nil
	c.tsm.values = nil
	return nil
}

// next returns the next key/value for the cursor.
func (c *stringAscendingCursor) next() (int64, interface{}) { return c.nextString() }

// nextString returns the next key/value for the cursor.
func (c *stringAscendingCursor) nextString() (int64, string) {
	ckey, cvalue := c.peekCache()
	tkey, tvalue := c.peekTSM()

	// No more data in cache or in TSM files.
	if ckey == tsdb.EOF && tkey == tsdb.EOF {
		return tsdb.EOF, ""
	}

	// Both cache and tsm files have the same key, cache takes precedence.
	if ckey == tkey {
		c.nextCache()
		c.nextTSM()
		return ckey, cvalue
	}

	// Buffered cache key precedes that in TSM file.
	if ckey != tsdb.EOF && (ckey < tkey || tkey == tsdb.EOF) {
		c.nextCache()
		return ckey, cvalue
	}

	// Buffered TSM key precedes that in cache.
	c.nextTSM()
	return tkey, tvalue
}

// nextCache returns the next value from the cache.
func (c *stringAscendingCursor) nextCache() {
	if c.cache.pos >= len(c.cache.values) {
		return
	}
	c.cache.pos++
}

func (c *stringAscendingCursor) seekCache(t int64) {
	if c.cache.pos >= len(c.cache.values) {
		return
	}
	values := c.cache.values[c.cache.pos:]
	i := sort.Search(len(values), func(i int) bool {
		return values[i].UnixNano() >= t
	})
	c.cache.pos += i
}

// nextTSM returns the next value from the TSM files.
func (c *stringAscendingCursor) nextTSM() {
	c.tsm.pos++
	if c.tsm.pos >= len(c.tsm.values) {
		c.tsm.keyCursor.Next()
		c.tsm.values, _ = c.tsm.keyCursor.ReadStringBlock(&c.tsm.buf)
		if len(c.tsm.values) == 0 {
			return
		}
		c.tsm.pos = 0
	}
}

func (c *stringAscendingCursor) seekTSM(t int64) {
	if c.tsm.pos >= len(c.tsm.values) {
		return
	}

	values := c.tsm.values[c.tsm.pos:]
	tmin, tmax := 0, len(values)
	for tmin < tmax {
		h := tmin + (tmax-tmin)/2
		if values[h].UnixNano() >= t {
			tmax = h
		} else {
			tmin = h + 1
		}
	}
	c.tsm.pos += tmin

	if c.tsm.pos < len(c.tsm.values) {
		return
	}

	// We did not find a value within the current interval.
	// Seek to the appropriate interval.
	c.tsm.keyCursor.seekAscending(t)
	c.tsm.values, _ = c.tsm.keyCursor.ReadStringBlock(&c.tsm.buf)
	c.tsm.pos = sort.Search(len(c.tsm.values), func(i int) bool {
		return c.tsm.values[i].UnixNano() >= t
	})
}

func (c *stringAscendingCursor) seek(t int64) {
	c.seekCache(t)
	c.seekTSM(t)
}

type stringDescendingCursor struct {
	cache struct {
		values Values
		pos    int
	}

	tsm struct {
		buf       []StringValue
		values    []StringValue
		pos       int
		keyCursor *KeyCursor
	}
}

func newStringDescendingCursor(seek int64, cacheValues Values, tsmKeyCursor *KeyCursor) *stringDescendingCursor {
	c := &stringDescendingCursor{}

	c.cache.values = cacheValues
	c.cache.pos = sort.Search(len(c.cache.values), func(i int) bool {
		return c.cache.values[i].UnixNano() >= seek
	})
	if t, _ := c.peekCache(); t != seek {
		c.cache.pos--
	}

	c.tsm.keyCursor = tsmKeyCursor
	c.tsm.buf = make([]StringValue, 10)
	c.tsm.values, _ = c.tsm.keyCursor.ReadStringBlock(&c.tsm.buf)
	c.tsm.pos = sort.Search(len(c.tsm.values), func(i int) bool {
		return c.tsm.values[i].UnixNano() >= seek
	})
	if t, _ := c.peekTSM(); t != seek {
		c.tsm.pos--
	}

	return c
}

// peekCache returns the current time/value from the cache.
func (c *stringDescendingCursor) peekCache() (t int64, v string) {
	if c.cache.pos < 0 || c.cache.pos >= len(c.cache.values) {
		return tsdb.EOF, ""
	}

	item := c.cache.values[c.cache.pos]
	return item.UnixNano(), item.(*StringValue).value
}

// peekTSM returns the current time/value from tsm.
func (c *stringDescendingCursor) peekTSM() (t int64, v string) {
	if c.tsm.pos < 0 || c.tsm.pos >= len(c.tsm.values) {
		return tsdb.EOF, ""
	}

	item := c.tsm.values[c.tsm.pos]
	return item.UnixNano(), item.value
}

// close closes the cursor and any dependent cursors.
func (c *stringDescendingCursor) close() error {
	c.tsm.keyCursor.Close()
	c.tsm.keyCursor = nil
	c.tsm.buf = nil
	c.cache.values = nil
	c.tsm.values = nil
	return nil
}

// next returns the next key/value for the cursor.
func (c *stringDescendingCursor) next() (int64, interface{}) { return c.nextString() }

// nextString returns the next key/value for the cursor.
func (c *stringDescendingCursor) nextString() (int64, string) {
	ckey, cvalue := c.peekCache()
	tkey, tvalue := c.peekTSM()

	// No more data in cache or in TSM files.
	if ckey == tsdb.EOF && tkey == tsdb.EOF {
		return tsdb.EOF, ""
	}

	// Both cache and tsm files have the same key, cache takes precedence.
	if ckey == tkey {
		c.nextCache()
		c.nextTSM()
		return ckey, cvalue
	}

	// Buffered cache key precedes that in TSM file.
	if ckey != tsdb.EOF && (ckey > tkey || tkey == tsdb.EOF) {
		c.nextCache()
		return ckey, cvalue
	}

	// Buffered TSM key precedes that in cache.
	c.nextTSM()
	return tkey, tvalue
}

// nextCache returns the next value from the cache.
func (c *stringDescendingCursor) nextCache() {
	if c.cache.pos < 0 {
		return
	}
	c.cache.pos--
}

func (c *stringDescendingCursor) seekCache(t int64) {
}

// nextTSM returns the next value from the TSM files.
func (c *stringDescendingCursor) nextTSM() {
	c.tsm.pos--
	if c.tsm.pos < 0 {
		c.tsm.keyCursor.Next()
		c.tsm.values, _ = c.tsm.keyCursor.ReadStringBlock(&c.tsm.buf)
		if len(c.tsm.values) == 0 {
			return
		}
		c.tsm.pos = len(c.tsm.values) - 1
	}
}

func (c *stringDescendingCursor) seekTSM(t int64) {
}

func (c *stringDescendingCursor) seek(t int64) {
	c.seekCache(t)
	c.seekTSM(t)
}

// bufStringCursor provides a ring buffer to support seeking in a cursor.
type bufStringCursor struct {
	cur stringCursor
	buf [2]struct {
		key    int64
		value  string
		filled bool
	}
	ascending bool
}

// newBufStringCursor returns a buffered wrapper for cur.
func newBufStringCursor(cur stringCursor, ascending bool) *bufStringCursor {
	return &bufStringCursor{cur: cur, ascending: ascending}
}

func (c *bufStringCursor) close() error               { return c.cur.close() }
func (c *bufStringCursor) next() (int64, interface{}) { return c.nextString() }

func (c *bufStringCursor) nextString() (int64, string) {
	if c.buf[0].filled {
		k, v := c.buf[0].key, c.buf[0].value
		c.buf[0] = c.buf[1]
		c.buf[1].filled = false
		return k, v
	}
	return c.cur.nextString()
}

func (c *bufStringCursor) unread(k int64, v string) {
	c.buf[1] = c.buf[0]
	c.buf[0].key, c.buf[0].value = k, v
	c.buf[0].filled = true
}

func (c *bufStringCursor) seek(t int64) {
	c.cur.seek(t)
}

func (c *bufStringCursor) seekAt(seek int64) {
	for {
		k, v := c.nextString()
		if k == tsdb.EOF {
			break
		}

		if c.ascending && k < seek {
			continue
		} else if !c.ascending && k > seek {
			continue
		}
		c.unread(k, v)
		return
	}
}

func (c *bufStringCursor) seekUntil(seek int64) {
	for {
		k, v := c.nextString()
		if k == tsdb.EOF {
			break
		}

		if c.ascending && k < seek {
			c.unread(k, v)
			continue
		} else if !c.ascending && k > seek {
			c.unread(k, v)
			continue
		}
		c.unread(k, v)
		return
	}
}

// stringLiteralCursor represents a cursor that always returns a single value.
// It doesn't not have a time value so it can only be used with nextAt().
type stringLiteralCursor struct {
	value string
}

func (c *stringLiteralCursor) close() error                   { return nil }
func (c *stringLiteralCursor) peek() (t int64, v interface{}) { return tsdb.EOF, c.value }
func (c *stringLiteralCursor) next() (t int64, v interface{}) { return tsdb.EOF, c.value }
func (c *stringLiteralCursor) nextAt(seek int64) interface{}  { return c.value }

// stringNilLiteralCursor represents a cursor that always returns a typed nil value.
// It doesn't not have a time value so it can only be used with nextAt().
type stringNilLiteralCursor struct{}

func (c *stringNilLiteralCursor) close() error                   { return nil }
func (c *stringNilLiteralCursor) peek() (t int64, v interface{}) { return tsdb.EOF, (*string)(nil) }
func (c *stringNilLiteralCursor) next() (t int64, v interface{}) { return tsdb.EOF, (*string)(nil) }
func (c *stringNilLiteralCursor) nextAt(seek int64) interface{}  { return (*string)(nil) }

// firstStringIterator returns the first value from each window for an iterator.
type firstStringIterator struct {
	input influxql.SeekStringIterator
	opt   influxql.IteratorOptions
	point influxql.StringPoint
}

func newFirstStringIterator(input influxql.SeekStringIterator, opt influxql.IteratorOptions) *firstStringIterator {
	return &firstStringIterator{
		input: input,
		opt:   opt,
		point: influxql.StringPoint{Nil: true},
	}
}

func (itr *firstStringIterator) Close() error                  { return itr.input.Close() }
func (itr *firstStringIterator) Stats() influxql.IteratorStats { return itr.input.Stats() }

func (itr *firstStringIterator) Next() (*influxql.StringPoint, error) {
	// Seek to the next point if we have read a previous point.
	if !itr.point.Nil {
		// If we do not have an interval, return immediately.
		if itr.opt.Interval.IsZero() {
			return nil, nil
		}

		start, _ := itr.opt.Window(itr.point.Time)
		if itr.opt.Ascending {
			// Ascending iterator needs to move to the future interval.
			start += int64(itr.opt.Interval.Duration)
		} else {
			// The start time of the current interval is the end time of the past interval
			// we need to move to. This is intentionally left empty for this comment.
		}

		// Seek to at least the next interval's start time. This may not get us the
		// time interval that is in start, but it will at least get us the next new
		// time interval.
		if err := itr.input.SeekTo(start); err != nil {
			return nil, err
		}
	}

	p, err := itr.input.Next()
	if p == nil || err != nil {
		itr.point.Nil = true
		return p, err
	}
	itr.point = *p
	return p.Clone(), nil
}

// lastStringIterator returns the first value from each window for an iterator.
type lastStringIterator struct {
	input influxql.SeekStringIterator
	opt   influxql.IteratorOptions
	point influxql.StringPoint
}

func newLastStringIterator(input influxql.SeekStringIterator, opt influxql.IteratorOptions) *lastStringIterator {
	return &lastStringIterator{
		input: input,
		opt:   opt,
		point: influxql.StringPoint{Nil: true},
	}
}

func (itr *lastStringIterator) Close() error                  { return itr.input.Close() }
func (itr *lastStringIterator) Stats() influxql.IteratorStats { return itr.input.Stats() }

func (itr *lastStringIterator) Next() (*influxql.StringPoint, error) {
	// Seek to the next point if we have read a previous point.
	if !itr.point.Nil {
		// If we do not have an interval, return immediately.
		if itr.opt.Interval.IsZero() {
			return nil, nil
		}
	}

	_, end := itr.opt.Window(itr.point.Time)
	if itr.opt.Ascending {
		// Ascending iterator needs to move to the future interval.
		end += int64(itr.opt.Interval.Duration)
	} else {
		// The start time of the current interval is the end time of the past interval
		// we need to move to. This is intentionally left empty for this comment.
	}

	for {
		// Seek to at least the next interval's start time. This may not get us the
		// time interval that is in start, but it will at least get us the next new
		// time interval.
		if ok, err := itr.input.SeekUntil(end); err != nil {
			return nil, err
		} else if ok {
			break
		}

		duration := int64(itr.opt.Interval.Duration)
		if !itr.opt.Ascending {
			duration = -duration
		}
		end += duration
	}

	p, err := itr.input.Next()
	if p == nil || err != nil {
		itr.point.Nil = true
		return p, err
	}
	itr.point = *p
	return &itr.point, nil
}

type booleanIterator struct {
	cur   booleanCursor
	aux   []cursorAt
	conds struct {
		names []string
		curs  []cursorAt
	}
	opt influxql.IteratorOptions

	m     map[string]interface{} // map used for condition evaluation
	point influxql.BooleanPoint  // reusable buffer

	statsLock sync.Mutex
	stats     influxql.IteratorStats
	statsBuf  influxql.IteratorStats
}

func newBooleanIterator(name string, tags influxql.Tags, opt influxql.IteratorOptions, cur booleanCursor, aux []cursorAt, conds []cursorAt, condNames []string) *booleanIterator {
	itr := &booleanIterator{
		cur: cur,
		aux: aux,
		opt: opt,
		point: influxql.BooleanPoint{
			Name: name,
			Tags: tags,
		},
		statsBuf: influxql.IteratorStats{
			SeriesN: 1,
		},
	}
	itr.stats = itr.statsBuf

	if len(aux) > 0 {
		itr.point.Aux = make([]interface{}, len(aux))
	}

	if opt.Condition != nil {
		itr.m = make(map[string]interface{}, len(aux)+len(conds))
	}
	itr.conds.names = condNames
	itr.conds.curs = conds

	return itr
}

// Next returns the next point from the iterator.
func (itr *booleanIterator) Next() (*influxql.BooleanPoint, error) {
	for {
		seek := tsdb.EOF

		if itr.cur != nil {
			// Read from the main cursor if we have one.
			itr.point.Time, itr.point.Value = itr.cur.nextBoolean()
			seek = itr.point.Time
		} else {
			// Otherwise find lowest aux timestamp.
			for i := range itr.aux {
				if k, _ := itr.aux[i].peek(); k != tsdb.EOF {
					if seek == tsdb.EOF || (itr.opt.Ascending && k < seek) || (!itr.opt.Ascending && k > seek) {
						seek = k
					}
				}
			}
			itr.point.Time = seek
		}

		// Exit if we have no more points or we are outside our time range.
		if itr.point.Time == tsdb.EOF {
			itr.copyStats()
			return nil, nil
		} else if itr.opt.Ascending && itr.point.Time > itr.opt.EndTime {
			itr.copyStats()
			return nil, nil
		} else if !itr.opt.Ascending && itr.point.Time < itr.opt.StartTime {
			itr.copyStats()
			return nil, nil
		}

		// Read from each auxiliary cursor.
		for i := range itr.opt.Aux {
			itr.point.Aux[i] = itr.aux[i].nextAt(seek)
		}

		// Read from condition field cursors.
		for i := range itr.conds.curs {
			itr.m[itr.conds.names[i]] = itr.conds.curs[i].nextAt(seek)
		}

		// Evaluate condition, if one exists. Retry if it fails.
		if itr.opt.Condition != nil && !influxql.EvalBool(itr.opt.Condition, itr.m) {
			continue
		}

		// Track points returned.
		itr.statsBuf.PointN++

		// Copy buffer to stats periodically.
		if itr.statsBuf.PointN%statsBufferCopyIntervalN == 0 {
			itr.copyStats()
		}

		return &itr.point, nil
	}
}

// copyStats copies from the itr stats buffer to the stats under lock.
func (itr *booleanIterator) copyStats() {
	itr.statsLock.Lock()
	itr.stats = itr.statsBuf
	itr.statsLock.Unlock()
}

// Stats returns stats on the points processed.
func (itr *booleanIterator) Stats() influxql.IteratorStats {
	itr.statsLock.Lock()
	stats := itr.stats
	itr.statsLock.Unlock()
	return stats
}

// bufCursor returns a buffered cursor so seek operations can be performed.
// If the current cursor isn't a buffered cursor, this wraps it in one automatically.
func (itr *booleanIterator) bufCursor() (*bufBooleanCursor, error) {
	if itr.cur == nil {
		return nil, influxql.ErrSeekUnavailable
	}

	cur, ok := itr.cur.(*bufBooleanCursor)
	if !ok {
		cur = newBufBooleanCursor(itr.cur, itr.opt.Ascending)
		itr.cur = cur
	}
	return cur, nil
}

func (itr *booleanIterator) SeekTo(t int64) error {
	itr.cur.seek(t)
	return nil
}

func (itr *booleanIterator) SeekUntil(t int64) (bool, error) {
	cur, err := itr.bufCursor()
	if err != nil {
		return false, err
	}
	cur.seekUntil(t)

	// Check if the next point is before the seek time.
	k, v := cur.nextBoolean()
	ok := (itr.opt.Ascending && k < t) || (!itr.opt.Ascending && k > t)
	cur.unread(k, v)
	return ok, nil
}

// Close closes the iterator.
func (itr *booleanIterator) Close() error {
	for _, c := range itr.aux {
		c.close()
	}
	itr.aux = nil
	for _, c := range itr.conds.curs {
		c.close()
	}
	itr.conds.curs = nil
	if itr.cur != nil {
		err := itr.cur.close()
		itr.cur = nil
		return err
	}
	return nil
}

// booleanLimitIterator
type booleanLimitIterator struct {
	input influxql.BooleanIterator
	opt   influxql.IteratorOptions
	n     int
}

func newBooleanLimitIterator(input influxql.BooleanIterator, opt influxql.IteratorOptions) *booleanLimitIterator {
	return &booleanLimitIterator{
		input: input,
		opt:   opt,
	}
}

func (itr *booleanLimitIterator) Stats() influxql.IteratorStats { return itr.input.Stats() }
func (itr *booleanLimitIterator) Close() error                  { return itr.input.Close() }

func (itr *booleanLimitIterator) Next() (*influxql.BooleanPoint, error) {
	for {
		// Check if we are beyond the limit.
		if (itr.n - itr.opt.Offset) > itr.opt.Limit {
			return nil, nil
		}

		// Read the next point.
		p, err := itr.input.Next()
		if p == nil || err != nil {
			return nil, err
		}

		// Increment counter.
		itr.n++

		// Offsets are handled by a higher level iterator so return all points.
		return p, nil
	}
}

// booleanCursor represents an object for iterating over a single boolean field.
type booleanCursor interface {
	cursor
	nextBoolean() (t int64, v bool)
}

func newBooleanCursor(seek int64, ascending bool, cacheValues Values, tsmKeyCursor *KeyCursor) booleanCursor {
	if ascending {
		return newBooleanAscendingCursor(seek, cacheValues, tsmKeyCursor)
	}
	return newBooleanDescendingCursor(seek, cacheValues, tsmKeyCursor)
}

type booleanAscendingCursor struct {
	cache struct {
		values Values
		pos    int
	}

	tsm struct {
		buf       []BooleanValue
		values    []BooleanValue
		pos       int
		keyCursor *KeyCursor
	}
}

func newBooleanAscendingCursor(seek int64, cacheValues Values, tsmKeyCursor *KeyCursor) *booleanAscendingCursor {
	c := &booleanAscendingCursor{}

	c.cache.values = cacheValues
	c.cache.pos = sort.Search(len(c.cache.values), func(i int) bool {
		return c.cache.values[i].UnixNano() >= seek
	})

	c.tsm.keyCursor = tsmKeyCursor
	c.tsm.buf = make([]BooleanValue, 10)
	c.tsm.values, _ = c.tsm.keyCursor.ReadBooleanBlock(&c.tsm.buf)
	c.tsm.pos = sort.Search(len(c.tsm.values), func(i int) bool {
		return c.tsm.values[i].UnixNano() >= seek
	})

	return c
}

// peekCache returns the current time/value from the cache.
func (c *booleanAscendingCursor) peekCache() (t int64, v bool) {
	if c.cache.pos >= len(c.cache.values) {
		return tsdb.EOF, false
	}

	item := c.cache.values[c.cache.pos]
	return item.UnixNano(), item.(*BooleanValue).value
}

// peekTSM returns the current time/value from tsm.
func (c *booleanAscendingCursor) peekTSM() (t int64, v bool) {
	if c.tsm.pos < 0 || c.tsm.pos >= len(c.tsm.values) {
		return tsdb.EOF, false
	}

	item := c.tsm.values[c.tsm.pos]
	return item.UnixNano(), item.value
}

// close closes the cursor and any dependent cursors.
func (c *booleanAscendingCursor) close() error {
	c.tsm.keyCursor.Close()
	c.tsm.keyCursor = nil
	c.tsm.buf = nil
	c.cache.values = nil
	c.tsm.values = nil
	return nil
}

// next returns the next key/value for the cursor.
func (c *booleanAscendingCursor) next() (int64, interface{}) { return c.nextBoolean() }

// nextBoolean returns the next key/value for the cursor.
func (c *booleanAscendingCursor) nextBoolean() (int64, bool) {
	ckey, cvalue := c.peekCache()
	tkey, tvalue := c.peekTSM()

	// No more data in cache or in TSM files.
	if ckey == tsdb.EOF && tkey == tsdb.EOF {
		return tsdb.EOF, false
	}

	// Both cache and tsm files have the same key, cache takes precedence.
	if ckey == tkey {
		c.nextCache()
		c.nextTSM()
		return ckey, cvalue
	}

	// Buffered cache key precedes that in TSM file.
	if ckey != tsdb.EOF && (ckey < tkey || tkey == tsdb.EOF) {
		c.nextCache()
		return ckey, cvalue
	}

	// Buffered TSM key precedes that in cache.
	c.nextTSM()
	return tkey, tvalue
}

// nextCache returns the next value from the cache.
func (c *booleanAscendingCursor) nextCache() {
	if c.cache.pos >= len(c.cache.values) {
		return
	}
	c.cache.pos++
}

func (c *booleanAscendingCursor) seekCache(t int64) {
	if c.cache.pos >= len(c.cache.values) {
		return
	}
	values := c.cache.values[c.cache.pos:]
	i := sort.Search(len(values), func(i int) bool {
		return values[i].UnixNano() >= t
	})
	c.cache.pos += i
}

// nextTSM returns the next value from the TSM files.
func (c *booleanAscendingCursor) nextTSM() {
	c.tsm.pos++
	if c.tsm.pos >= len(c.tsm.values) {
		c.tsm.keyCursor.Next()
		c.tsm.values, _ = c.tsm.keyCursor.ReadBooleanBlock(&c.tsm.buf)
		if len(c.tsm.values) == 0 {
			return
		}
		c.tsm.pos = 0
	}
}

func (c *booleanAscendingCursor) seekTSM(t int64) {
	if c.tsm.pos >= len(c.tsm.values) {
		return
	}

	values := c.tsm.values[c.tsm.pos:]
	tmin, tmax := 0, len(values)
	for tmin < tmax {
		h := tmin + (tmax-tmin)/2
		if values[h].UnixNano() >= t {
			tmax = h
		} else {
			tmin = h + 1
		}
	}
	c.tsm.pos += tmin

	if c.tsm.pos < len(c.tsm.values) {
		return
	}

	// We did not find a value within the current interval.
	// Seek to the appropriate interval.
	c.tsm.keyCursor.seekAscending(t)
	c.tsm.values, _ = c.tsm.keyCursor.ReadBooleanBlock(&c.tsm.buf)
	c.tsm.pos = sort.Search(len(c.tsm.values), func(i int) bool {
		return c.tsm.values[i].UnixNano() >= t
	})
}

func (c *booleanAscendingCursor) seek(t int64) {
	c.seekCache(t)
	c.seekTSM(t)
}

type booleanDescendingCursor struct {
	cache struct {
		values Values
		pos    int
	}

	tsm struct {
		buf       []BooleanValue
		values    []BooleanValue
		pos       int
		keyCursor *KeyCursor
	}
}

func newBooleanDescendingCursor(seek int64, cacheValues Values, tsmKeyCursor *KeyCursor) *booleanDescendingCursor {
	c := &booleanDescendingCursor{}

	c.cache.values = cacheValues
	c.cache.pos = sort.Search(len(c.cache.values), func(i int) bool {
		return c.cache.values[i].UnixNano() >= seek
	})
	if t, _ := c.peekCache(); t != seek {
		c.cache.pos--
	}

	c.tsm.keyCursor = tsmKeyCursor
	c.tsm.buf = make([]BooleanValue, 10)
	c.tsm.values, _ = c.tsm.keyCursor.ReadBooleanBlock(&c.tsm.buf)
	c.tsm.pos = sort.Search(len(c.tsm.values), func(i int) bool {
		return c.tsm.values[i].UnixNano() >= seek
	})
	if t, _ := c.peekTSM(); t != seek {
		c.tsm.pos--
	}

	return c
}

// peekCache returns the current time/value from the cache.
func (c *booleanDescendingCursor) peekCache() (t int64, v bool) {
	if c.cache.pos < 0 || c.cache.pos >= len(c.cache.values) {
		return tsdb.EOF, false
	}

	item := c.cache.values[c.cache.pos]
	return item.UnixNano(), item.(*BooleanValue).value
}

// peekTSM returns the current time/value from tsm.
func (c *booleanDescendingCursor) peekTSM() (t int64, v bool) {
	if c.tsm.pos < 0 || c.tsm.pos >= len(c.tsm.values) {
		return tsdb.EOF, false
	}

	item := c.tsm.values[c.tsm.pos]
	return item.UnixNano(), item.value
}

// close closes the cursor and any dependent cursors.
func (c *booleanDescendingCursor) close() error {
	c.tsm.keyCursor.Close()
	c.tsm.keyCursor = nil
	c.tsm.buf = nil
	c.cache.values = nil
	c.tsm.values = nil
	return nil
}

// next returns the next key/value for the cursor.
func (c *booleanDescendingCursor) next() (int64, interface{}) { return c.nextBoolean() }

// nextBoolean returns the next key/value for the cursor.
func (c *booleanDescendingCursor) nextBoolean() (int64, bool) {
	ckey, cvalue := c.peekCache()
	tkey, tvalue := c.peekTSM()

	// No more data in cache or in TSM files.
	if ckey == tsdb.EOF && tkey == tsdb.EOF {
		return tsdb.EOF, false
	}

	// Both cache and tsm files have the same key, cache takes precedence.
	if ckey == tkey {
		c.nextCache()
		c.nextTSM()
		return ckey, cvalue
	}

	// Buffered cache key precedes that in TSM file.
	if ckey != tsdb.EOF && (ckey > tkey || tkey == tsdb.EOF) {
		c.nextCache()
		return ckey, cvalue
	}

	// Buffered TSM key precedes that in cache.
	c.nextTSM()
	return tkey, tvalue
}

// nextCache returns the next value from the cache.
func (c *booleanDescendingCursor) nextCache() {
	if c.cache.pos < 0 {
		return
	}
	c.cache.pos--
}

func (c *booleanDescendingCursor) seekCache(t int64) {
}

// nextTSM returns the next value from the TSM files.
func (c *booleanDescendingCursor) nextTSM() {
	c.tsm.pos--
	if c.tsm.pos < 0 {
		c.tsm.keyCursor.Next()
		c.tsm.values, _ = c.tsm.keyCursor.ReadBooleanBlock(&c.tsm.buf)
		if len(c.tsm.values) == 0 {
			return
		}
		c.tsm.pos = len(c.tsm.values) - 1
	}
}

func (c *booleanDescendingCursor) seekTSM(t int64) {
}

func (c *booleanDescendingCursor) seek(t int64) {
	c.seekCache(t)
	c.seekTSM(t)
}

// bufBooleanCursor provides a ring buffer to support seeking in a cursor.
type bufBooleanCursor struct {
	cur booleanCursor
	buf [2]struct {
		key    int64
		value  bool
		filled bool
	}
	ascending bool
}

// newBufBooleanCursor returns a buffered wrapper for cur.
func newBufBooleanCursor(cur booleanCursor, ascending bool) *bufBooleanCursor {
	return &bufBooleanCursor{cur: cur, ascending: ascending}
}

func (c *bufBooleanCursor) close() error               { return c.cur.close() }
func (c *bufBooleanCursor) next() (int64, interface{}) { return c.nextBoolean() }

func (c *bufBooleanCursor) nextBoolean() (int64, bool) {
	if c.buf[0].filled {
		k, v := c.buf[0].key, c.buf[0].value
		c.buf[0] = c.buf[1]
		c.buf[1].filled = false
		return k, v
	}
	return c.cur.nextBoolean()
}

func (c *bufBooleanCursor) unread(k int64, v bool) {
	c.buf[1] = c.buf[0]
	c.buf[0].key, c.buf[0].value = k, v
	c.buf[0].filled = true
}

func (c *bufBooleanCursor) seek(t int64) {
	c.cur.seek(t)
}

func (c *bufBooleanCursor) seekAt(seek int64) {
	for {
		k, v := c.nextBoolean()
		if k == tsdb.EOF {
			break
		}

		if c.ascending && k < seek {
			continue
		} else if !c.ascending && k > seek {
			continue
		}
		c.unread(k, v)
		return
	}
}

func (c *bufBooleanCursor) seekUntil(seek int64) {
	for {
		k, v := c.nextBoolean()
		if k == tsdb.EOF {
			break
		}

		if c.ascending && k < seek {
			c.unread(k, v)
			continue
		} else if !c.ascending && k > seek {
			c.unread(k, v)
			continue
		}
		c.unread(k, v)
		return
	}
}

// booleanLiteralCursor represents a cursor that always returns a single value.
// It doesn't not have a time value so it can only be used with nextAt().
type booleanLiteralCursor struct {
	value bool
}

func (c *booleanLiteralCursor) close() error                   { return nil }
func (c *booleanLiteralCursor) peek() (t int64, v interface{}) { return tsdb.EOF, c.value }
func (c *booleanLiteralCursor) next() (t int64, v interface{}) { return tsdb.EOF, c.value }
func (c *booleanLiteralCursor) nextAt(seek int64) interface{}  { return c.value }

// booleanNilLiteralCursor represents a cursor that always returns a typed nil value.
// It doesn't not have a time value so it can only be used with nextAt().
type booleanNilLiteralCursor struct{}

func (c *booleanNilLiteralCursor) close() error                   { return nil }
func (c *booleanNilLiteralCursor) peek() (t int64, v interface{}) { return tsdb.EOF, (*bool)(nil) }
func (c *booleanNilLiteralCursor) next() (t int64, v interface{}) { return tsdb.EOF, (*bool)(nil) }
func (c *booleanNilLiteralCursor) nextAt(seek int64) interface{}  { return (*bool)(nil) }

// firstBooleanIterator returns the first value from each window for an iterator.
type firstBooleanIterator struct {
	input influxql.SeekBooleanIterator
	opt   influxql.IteratorOptions
	point influxql.BooleanPoint
}

func newFirstBooleanIterator(input influxql.SeekBooleanIterator, opt influxql.IteratorOptions) *firstBooleanIterator {
	return &firstBooleanIterator{
		input: input,
		opt:   opt,
		point: influxql.BooleanPoint{Nil: true},
	}
}

func (itr *firstBooleanIterator) Close() error                  { return itr.input.Close() }
func (itr *firstBooleanIterator) Stats() influxql.IteratorStats { return itr.input.Stats() }

func (itr *firstBooleanIterator) Next() (*influxql.BooleanPoint, error) {
	// Seek to the next point if we have read a previous point.
	if !itr.point.Nil {
		// If we do not have an interval, return immediately.
		if itr.opt.Interval.IsZero() {
			return nil, nil
		}

		start, _ := itr.opt.Window(itr.point.Time)
		if itr.opt.Ascending {
			// Ascending iterator needs to move to the future interval.
			start += int64(itr.opt.Interval.Duration)
		} else {
			// The start time of the current interval is the end time of the past interval
			// we need to move to. This is intentionally left empty for this comment.
		}

		// Seek to at least the next interval's start time. This may not get us the
		// time interval that is in start, but it will at least get us the next new
		// time interval.
		if err := itr.input.SeekTo(start); err != nil {
			return nil, err
		}
	}

	p, err := itr.input.Next()
	if p == nil || err != nil {
		itr.point.Nil = true
		return p, err
	}
	itr.point = *p
	return p.Clone(), nil
}

// lastBooleanIterator returns the first value from each window for an iterator.
type lastBooleanIterator struct {
	input influxql.SeekBooleanIterator
	opt   influxql.IteratorOptions
	point influxql.BooleanPoint
}

func newLastBooleanIterator(input influxql.SeekBooleanIterator, opt influxql.IteratorOptions) *lastBooleanIterator {
	return &lastBooleanIterator{
		input: input,
		opt:   opt,
		point: influxql.BooleanPoint{Nil: true},
	}
}

func (itr *lastBooleanIterator) Close() error                  { return itr.input.Close() }
func (itr *lastBooleanIterator) Stats() influxql.IteratorStats { return itr.input.Stats() }

func (itr *lastBooleanIterator) Next() (*influxql.BooleanPoint, error) {
	// Seek to the next point if we have read a previous point.
	if !itr.point.Nil {
		// If we do not have an interval, return immediately.
		if itr.opt.Interval.IsZero() {
			return nil, nil
		}
	}

	_, end := itr.opt.Window(itr.point.Time)
	if itr.opt.Ascending {
		// Ascending iterator needs to move to the future interval.
		end += int64(itr.opt.Interval.Duration)
	} else {
		// The start time of the current interval is the end time of the past interval
		// we need to move to. This is intentionally left empty for this comment.
	}

	for {
		// Seek to at least the next interval's start time. This may not get us the
		// time interval that is in start, but it will at least get us the next new
		// time interval.
		if ok, err := itr.input.SeekUntil(end); err != nil {
			return nil, err
		} else if ok {
			break
		}

		duration := int64(itr.opt.Interval.Duration)
		if !itr.opt.Ascending {
			duration = -duration
		}
		end += duration
	}

	p, err := itr.input.Next()
	if p == nil || err != nil {
		itr.point.Nil = true
		return p, err
	}
	itr.point = *p
	return &itr.point, nil
}

var _ = fmt.Print
