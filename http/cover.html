
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>http: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/influxdata/influxdb/v2/http/api_handler.go (76.3%)</option>
				
				<option value="file1">github.com/influxdata/influxdb/v2/http/auth_service.go (71.9%)</option>
				
				<option value="file2">github.com/influxdata/influxdb/v2/http/authentication_middleware.go (90.2%)</option>
				
				<option value="file3">github.com/influxdata/influxdb/v2/http/backup_service.go (52.5%)</option>
				
				<option value="file4">github.com/influxdata/influxdb/v2/http/check_service.go (52.5%)</option>
				
				<option value="file5">github.com/influxdata/influxdb/v2/http/client.go (81.8%)</option>
				
				<option value="file6">github.com/influxdata/influxdb/v2/http/config.go (96.7%)</option>
				
				<option value="file7">github.com/influxdata/influxdb/v2/http/debug.go (0.0%)</option>
				
				<option value="file8">github.com/influxdata/influxdb/v2/http/delete_handler.go (60.0%)</option>
				
				<option value="file9">github.com/influxdata/influxdb/v2/http/document_service.go (84.9%)</option>
				
				<option value="file10">github.com/influxdata/influxdb/v2/http/duration.go (96.2%)</option>
				
				<option value="file11">github.com/influxdata/influxdb/v2/http/errors.go (79.4%)</option>
				
				<option value="file12">github.com/influxdata/influxdb/v2/http/handler.go (96.2%)</option>
				
				<option value="file13">github.com/influxdata/influxdb/v2/http/health.go (100.0%)</option>
				
				<option value="file14">github.com/influxdata/influxdb/v2/http/label_service.go (55.5%)</option>
				
				<option value="file15">github.com/influxdata/influxdb/v2/http/legacy.go (0.0%)</option>
				
				<option value="file16">github.com/influxdata/influxdb/v2/http/legacy/backend.go (7.7%)</option>
				
				<option value="file17">github.com/influxdata/influxdb/v2/http/legacy/common.go (85.7%)</option>
				
				<option value="file18">github.com/influxdata/influxdb/v2/http/legacy/influx1x_authentication_handler.go (92.3%)</option>
				
				<option value="file19">github.com/influxdata/influxdb/v2/http/legacy/influxql_handler.go (33.3%)</option>
				
				<option value="file20">github.com/influxdata/influxdb/v2/http/legacy/influxqld_handler.go (60.3%)</option>
				
				<option value="file21">github.com/influxdata/influxdb/v2/http/legacy/ping_handler.go (100.0%)</option>
				
				<option value="file22">github.com/influxdata/influxdb/v2/http/legacy/router.go (25.9%)</option>
				
				<option value="file23">github.com/influxdata/influxdb/v2/http/legacy/write_handler.go (79.2%)</option>
				
				<option value="file24">github.com/influxdata/influxdb/v2/http/legacy/write_usage_recorder.go (100.0%)</option>
				
				<option value="file25">github.com/influxdata/influxdb/v2/http/middleware.go (96.2%)</option>
				
				<option value="file26">github.com/influxdata/influxdb/v2/http/notification_endpoint.go (49.7%)</option>
				
				<option value="file27">github.com/influxdata/influxdb/v2/http/notification_rule.go (10.8%)</option>
				
				<option value="file28">github.com/influxdata/influxdb/v2/http/platform_handler.go (0.0%)</option>
				
				<option value="file29">github.com/influxdata/influxdb/v2/http/proxy_handler.go (85.7%)</option>
				
				<option value="file30">github.com/influxdata/influxdb/v2/http/query.go (62.3%)</option>
				
				<option value="file31">github.com/influxdata/influxdb/v2/http/query_handler.go (49.2%)</option>
				
				<option value="file32">github.com/influxdata/influxdb/v2/http/ready.go (90.0%)</option>
				
				<option value="file33">github.com/influxdata/influxdb/v2/http/redoc.go (0.0%)</option>
				
				<option value="file34">github.com/influxdata/influxdb/v2/http/requests.go (100.0%)</option>
				
				<option value="file35">github.com/influxdata/influxdb/v2/http/resources.go (100.0%)</option>
				
				<option value="file36">github.com/influxdata/influxdb/v2/http/restore_service.go (5.9%)</option>
				
				<option value="file37">github.com/influxdata/influxdb/v2/http/router.go (85.4%)</option>
				
				<option value="file38">github.com/influxdata/influxdb/v2/http/scraper_service.go (77.3%)</option>
				
				<option value="file39">github.com/influxdata/influxdb/v2/http/source_proxy_service.go (0.0%)</option>
				
				<option value="file40">github.com/influxdata/influxdb/v2/http/source_service.go (6.7%)</option>
				
				<option value="file41">github.com/influxdata/influxdb/v2/http/task_service.go (50.5%)</option>
				
				<option value="file42">github.com/influxdata/influxdb/v2/http/telegraf.go (37.0%)</option>
				
				<option value="file43">github.com/influxdata/influxdb/v2/http/tokens.go (100.0%)</option>
				
				<option value="file44">github.com/influxdata/influxdb/v2/http/ua.go (80.0%)</option>
				
				<option value="file45">github.com/influxdata/influxdb/v2/http/user_resource_mapping_service.go (38.6%)</option>
				
				<option value="file46">github.com/influxdata/influxdb/v2/http/variable_service.go (82.5%)</option>
				
				<option value="file47">github.com/influxdata/influxdb/v2/http/write_handler.go (92.5%)</option>
				
				<option value="file48">github.com/influxdata/influxdb/v2/http/write_usage_recorder.go (66.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package http

import (
        "context"
        "net/http"

        "github.com/go-chi/chi"
        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/authorizer"
        "github.com/influxdata/influxdb/v2/dbrp"
        "github.com/influxdata/influxdb/v2/http/metric"
        "github.com/influxdata/influxdb/v2/influxql"
        "github.com/influxdata/influxdb/v2/kit/feature"
        "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/kit/prom"
        kithttp "github.com/influxdata/influxdb/v2/kit/transport/http"
        "github.com/influxdata/influxdb/v2/query"
        "github.com/influxdata/influxdb/v2/query/fluxlang"
        "github.com/influxdata/influxdb/v2/static"
        "github.com/influxdata/influxdb/v2/storage"
        "github.com/influxdata/influxdb/v2/task/taskmodel"
        "github.com/prometheus/client_golang/prometheus"
        "go.uber.org/zap"
)

// APIHandler is a collection of all the service handlers.
type APIHandler struct {
        chi.Router
}

// APIBackend is all services and associated parameters required to construct
// an APIHandler.
type APIBackend struct {
        AssetsPath     string // if empty then assets are served from bindata.
        UIDisabled     bool   // if true requests for the UI will return 404
        Logger         *zap.Logger
        FluxLogEnabled bool
        errors.HTTPErrorHandler
        SessionRenewDisabled bool
        // MaxBatchSizeBytes is the maximum number of bytes which can be written
        // in a single points batch
        MaxBatchSizeBytes int64

        // WriteParserMaxBytes specifies the maximum number of bytes that may be allocated when processing a single
        // write request. A value of zero specifies there is no limit.
        WriteParserMaxBytes int

        // WriteParserMaxLines specifies the maximum number of lines that may be parsed when processing a single
        // write request. A value of zero specifies there is no limit.
        WriteParserMaxLines int

        // WriteParserMaxValues specifies the maximum number of values that may be parsed when processing a single
        // write request. A value of zero specifies there is no limit.
        WriteParserMaxValues int

        NewQueryService func(*influxdb.Source) (query.ProxyQueryService, error)

        WriteEventRecorder metric.EventRecorder
        QueryEventRecorder metric.EventRecorder

        AlgoWProxy FeatureProxyHandler

        PointsWriter                    storage.PointsWriter
        DeleteService                   influxdb.DeleteService
        BackupService                   influxdb.BackupService
        SqlBackupRestoreService         influxdb.SqlBackupRestoreService
        BucketManifestWriter            influxdb.BucketManifestWriter
        RestoreService                  influxdb.RestoreService
        AuthorizationService            influxdb.AuthorizationService
        AuthorizationV1Service          influxdb.AuthorizationService
        PasswordV1Service               influxdb.PasswordsService
        AuthorizerV1                    influxdb.AuthorizerV1
        OnboardingService               influxdb.OnboardingService
        DBRPService                     influxdb.DBRPMappingService
        BucketService                   influxdb.BucketService
        SessionService                  influxdb.SessionService
        UserService                     influxdb.UserService
        OrganizationService             influxdb.OrganizationService
        UserResourceMappingService      influxdb.UserResourceMappingService
        LabelService                    influxdb.LabelService
        DashboardService                influxdb.DashboardService
        DashboardOperationLogService    influxdb.DashboardOperationLogService
        BucketOperationLogService       influxdb.BucketOperationLogService
        UserOperationLogService         influxdb.UserOperationLogService
        OrganizationOperationLogService influxdb.OrganizationOperationLogService
        SourceService                   influxdb.SourceService
        VariableService                 influxdb.VariableService
        PasswordsService                influxdb.PasswordsService
        InfluxQLService                 query.ProxyQueryService
        InfluxqldService                influxql.ProxyQueryService
        FluxService                     query.ProxyQueryService
        FluxLanguageService             fluxlang.FluxLanguageService
        TaskService                     taskmodel.TaskService
        CheckService                    influxdb.CheckService
        TelegrafService                 influxdb.TelegrafConfigStore
        ScraperTargetStoreService       influxdb.ScraperTargetStoreService
        SecretService                   influxdb.SecretService
        LookupService                   influxdb.LookupService
        OrgLookupService                authorizer.OrgIDResolver
        DocumentService                 influxdb.DocumentService
        NotificationRuleStore           influxdb.NotificationRuleStore
        NotificationEndpointService     influxdb.NotificationEndpointService
        Flagger                         feature.Flagger
        FlagsHandler                    http.Handler
}

// PrometheusCollectors exposes the prometheus collectors associated with an APIBackend.
func (b *APIBackend) PrometheusCollectors() []prometheus.Collector <span class="cov0" title="0">{
        var cs []prometheus.Collector

        if pc, ok := b.WriteEventRecorder.(prom.PrometheusCollector); ok </span><span class="cov0" title="0">{
                cs = append(cs, pc.PrometheusCollectors()...)
        }</span>

        <span class="cov0" title="0">if pc, ok := b.QueryEventRecorder.(prom.PrometheusCollector); ok </span><span class="cov0" title="0">{
                cs = append(cs, pc.PrometheusCollectors()...)
        }</span>

        <span class="cov0" title="0">return cs</span>
}

// APIHandlerOptFn is a functional input param to set parameters on
// the APIHandler.
type APIHandlerOptFn func(chi.Router)

// WithResourceHandler registers a resource handler on the APIHandler.
func WithResourceHandler(resHandler kithttp.ResourceHandler) APIHandlerOptFn <span class="cov0" title="0">{
        return func(h chi.Router) </span><span class="cov0" title="0">{
                h.Mount(resHandler.Prefix(), resHandler)
        }</span>
}

// NewAPIHandler constructs all api handlers beneath it and returns an APIHandler
func NewAPIHandler(b *APIBackend, opts ...APIHandlerOptFn) *APIHandler <span class="cov8" title="1">{
        h := &amp;APIHandler{
                Router: NewBaseChiRouter(kithttp.NewAPI(kithttp.WithLog(b.Logger))),
        }

        b.UserResourceMappingService = authorizer.NewURMService(b.OrgLookupService, b.UserResourceMappingService)

        h.Handle("/api/v2", serveLinksHandler(b.HTTPErrorHandler))

        checkBackend := NewCheckBackend(b.Logger.With(zap.String("handler", "check")), b)
        checkBackend.CheckService = authorizer.NewCheckService(b.CheckService,
                b.UserResourceMappingService, b.OrganizationService)
        h.Mount(prefixChecks, NewCheckHandler(b.Logger, checkBackend))

        deleteBackend := NewDeleteBackend(b.Logger.With(zap.String("handler", "delete")), b)
        h.Mount(prefixDelete, NewDeleteHandler(b.Logger, deleteBackend))

        documentBackend := NewDocumentBackend(b.Logger.With(zap.String("handler", "document")), b)
        documentBackend.DocumentService = authorizer.NewDocumentService(b.DocumentService)
        h.Mount(prefixDocuments, NewDocumentHandler(documentBackend))

        fluxBackend := NewFluxBackend(b.Logger.With(zap.String("handler", "query")), b)
        h.Mount(prefixQuery, NewFluxHandler(b.Logger, fluxBackend))

        notificationEndpointBackend := NewNotificationEndpointBackend(b.Logger.With(zap.String("handler", "notificationEndpoint")), b)
        notificationEndpointBackend.NotificationEndpointService = authorizer.NewNotificationEndpointService(b.NotificationEndpointService,
                b.UserResourceMappingService, b.OrganizationService)
        h.Mount(prefixNotificationEndpoints, NewNotificationEndpointHandler(notificationEndpointBackend.Logger(), notificationEndpointBackend))

        notificationRuleBackend := NewNotificationRuleBackend(b.Logger.With(zap.String("handler", "notification_rule")), b)
        notificationRuleBackend.NotificationRuleStore = authorizer.NewNotificationRuleStore(b.NotificationRuleStore,
                b.UserResourceMappingService, b.OrganizationService)
        h.Mount(prefixNotificationRules, NewNotificationRuleHandler(b.Logger, notificationRuleBackend))

        scraperBackend := NewScraperBackend(b.Logger.With(zap.String("handler", "scraper")), b)
        scraperBackend.ScraperStorageService = authorizer.NewScraperTargetStoreService(b.ScraperTargetStoreService,
                b.UserResourceMappingService,
                b.OrganizationService)
        h.Mount(prefixTargets, NewScraperHandler(b.Logger, scraperBackend))

        sourceBackend := NewSourceBackend(b.Logger.With(zap.String("handler", "source")), b)
        sourceBackend.SourceService = authorizer.NewSourceService(b.SourceService)
        sourceBackend.BucketService = authorizer.NewBucketService(b.BucketService)
        h.Mount(prefixSources, NewSourceHandler(b.Logger, sourceBackend))

        h.Mount("/api/v2/swagger.json", static.NewSwaggerHandler())

        taskLogger := b.Logger.With(zap.String("handler", "bucket"))
        taskBackend := NewTaskBackend(taskLogger, b)
        taskBackend.TaskService = authorizer.NewTaskService(taskLogger, b.TaskService)
        taskHandler := NewTaskHandler(b.Logger, taskBackend)
        h.Mount(prefixTasks, taskHandler)

        telegrafBackend := NewTelegrafBackend(b.Logger.With(zap.String("handler", "telegraf")), b)
        telegrafBackend.TelegrafService = authorizer.NewTelegrafConfigService(b.TelegrafService, b.UserResourceMappingService)
        h.Mount(prefixTelegrafPlugins, NewTelegrafHandler(b.Logger, telegrafBackend))
        h.Mount(prefixTelegraf, NewTelegrafHandler(b.Logger, telegrafBackend))

        h.Mount("/api/v2/flags", b.FlagsHandler)

        h.Mount(prefixResources, NewResourceListHandler())

        variableBackend := NewVariableBackend(b.Logger.With(zap.String("handler", "variable")), b)
        variableBackend.VariableService = authorizer.NewVariableService(b.VariableService)
        h.Mount(prefixVariables, NewVariableHandler(b.Logger, variableBackend))

        backupBackend := NewBackupBackend(b)
        backupBackend.BackupService = authorizer.NewBackupService(backupBackend.BackupService)
        backupBackend.SqlBackupRestoreService = authorizer.NewSqlBackupRestoreService(backupBackend.SqlBackupRestoreService)
        h.Mount(prefixBackup, NewBackupHandler(backupBackend))

        restoreBackend := NewRestoreBackend(b)
        restoreBackend.RestoreService = authorizer.NewRestoreService(restoreBackend.RestoreService)
        restoreBackend.SqlBackupRestoreService = authorizer.NewSqlBackupRestoreService(restoreBackend.SqlBackupRestoreService)
        h.Mount(prefixRestore, NewRestoreHandler(restoreBackend))

        h.Mount(dbrp.PrefixDBRP, dbrp.NewHTTPHandler(b.Logger, b.DBRPService, b.OrganizationService))

        writeBackend := NewWriteBackend(b.Logger.With(zap.String("handler", "write")), b)
        h.Mount(prefixWrite, NewWriteHandler(b.Logger, writeBackend,
                WithMaxBatchSizeBytes(b.MaxBatchSizeBytes),
                //WithParserOptions(
                //        models.WithParserMaxBytes(b.WriteParserMaxBytes),
                //        models.WithParserMaxLines(b.WriteParserMaxLines),
                //        models.WithParserMaxValues(b.WriteParserMaxValues),
                //),
        ))

        for _, o := range opts </span><span class="cov0" title="0">{
                o(h)
        }</span>
        <span class="cov8" title="1">return h</span>
}

var apiLinks = map[string]interface{}{
        // when adding new links, please take care to keep this list alphabetical
        // as this makes it easier to verify values against the swagger document.
        "authorizations": "/api/v2/authorizations",
        "backup":         "/api/v2/backup",
        "buckets":        "/api/v2/buckets",
        "dashboards":     "/api/v2/dashboards",
        "external": map[string]string{
                "statusFeed": "https://www.influxdata.com/feed/json",
        },
        "flags":                 "/api/v2/flags",
        "labels":                "/api/v2/labels",
        "variables":             "/api/v2/variables",
        "me":                    "/api/v2/me",
        "notificationRules":     "/api/v2/notificationRules",
        "notificationEndpoints": "/api/v2/notificationEndpoints",
        "orgs":                  "/api/v2/orgs",
        "query": map[string]string{
                "self":        "/api/v2/query",
                "ast":         "/api/v2/query/ast",
                "analyze":     "/api/v2/query/analyze",
                "suggestions": "/api/v2/query/suggestions",
        },
        "restore":  "/api/v2/restore",
        "setup":    "/api/v2/setup",
        "signin":   "/api/v2/signin",
        "signout":  "/api/v2/signout",
        "sources":  "/api/v2/sources",
        "scrapers": "/api/v2/scrapers",
        "swagger":  "/api/v2/swagger.json",
        "system": map[string]string{
                "metrics": "/metrics",
                "debug":   "/debug/pprof",
                "health":  "/health",
        },
        "tasks":     "/api/v2/tasks",
        "checks":    "/api/v2/checks",
        "telegrafs": "/api/v2/telegrafs",
        "plugins":   "/api/v2/telegraf/plugins",
        "users":     "/api/v2/users",
        "write":     "/api/v2/write",
        "delete":    "/api/v2/delete",
}

func serveLinksHandler(errorHandler errors.HTTPErrorHandler) http.Handler <span class="cov8" title="1">{
        fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ctx := r.Context()
                if err := encodeResponse(ctx, w, http.StatusOK, apiLinks); err != nil </span><span class="cov0" title="0">{
                        errorHandler.HandleHTTPError(ctx, err, w)
                }</span>
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}

func decodeIDFromCtx(ctx context.Context, name string) (platform.ID, error) <span class="cov0" title="0">{
        params := httprouter.ParamsFromContext(ctx)
        idStr := params.ByName(name)

        if idStr == "" </span><span class="cov0" title="0">{
                return 0, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing " + name,
                }
        }</span>

        <span class="cov0" title="0">var i platform.ID
        if err := i.DecodeFromString(idStr); err != nil </span><span class="cov0" title="0">{
                return 0, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>

        <span class="cov0" title="0">return i, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package http

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        platcontext "github.com/influxdata/influxdb/v2/context"
        "github.com/influxdata/influxdb/v2/kit/platform"
        errors2 "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/pkg/httpc"
        "go.uber.org/zap"
)

const prefixAuthorization = "/api/v2/authorizations"

// AuthorizationBackend is all services and associated parameters required to construct
// the AuthorizationHandler.
type AuthorizationBackend struct {
        errors2.HTTPErrorHandler
        log *zap.Logger

        AuthorizationService influxdb.AuthorizationService
        OrganizationService  influxdb.OrganizationService
        UserService          influxdb.UserService
        LookupService        influxdb.LookupService
}

// NewAuthorizationBackend returns a new instance of AuthorizationBackend.
func NewAuthorizationBackend(log *zap.Logger, b *APIBackend) *AuthorizationBackend <span class="cov0" title="0">{
        return &amp;AuthorizationBackend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,

                AuthorizationService: b.AuthorizationService,
                OrganizationService:  b.OrganizationService,
                UserService:          b.UserService,
                LookupService:        b.LookupService,
        }
}</span>

// AuthorizationHandler represents an HTTP API handler for authorizations.
type AuthorizationHandler struct {
        *httprouter.Router
        errors2.HTTPErrorHandler
        log *zap.Logger

        OrganizationService  influxdb.OrganizationService
        UserService          influxdb.UserService
        AuthorizationService influxdb.AuthorizationService
        LookupService        influxdb.LookupService
}

// NewAuthorizationHandler returns a new instance of AuthorizationHandler.
func NewAuthorizationHandler(log *zap.Logger, b *AuthorizationBackend) *AuthorizationHandler <span class="cov8" title="1">{
        h := &amp;AuthorizationHandler{
                Router:           NewRouter(b.HTTPErrorHandler),
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,

                AuthorizationService: b.AuthorizationService,
                OrganizationService:  b.OrganizationService,
                UserService:          b.UserService,
                LookupService:        b.LookupService,
        }

        h.HandlerFunc("POST", "/api/v2/authorizations", h.handlePostAuthorization)
        h.HandlerFunc("GET", "/api/v2/authorizations", h.handleGetAuthorizations)
        h.HandlerFunc("GET", "/api/v2/authorizations/:id", h.handleGetAuthorization)
        h.HandlerFunc("PATCH", "/api/v2/authorizations/:id", h.handleUpdateAuthorization)
        h.HandlerFunc("DELETE", "/api/v2/authorizations/:id", h.handleDeleteAuthorization)
        return h
}</span>

type authResponse struct {
        ID          platform.ID          `json:"id"`
        Token       string               `json:"token"`
        Status      influxdb.Status      `json:"status"`
        Description string               `json:"description"`
        OrgID       platform.ID          `json:"orgID"`
        Org         string               `json:"org"`
        UserID      platform.ID          `json:"userID"`
        User        string               `json:"user"`
        Permissions []permissionResponse `json:"permissions"`
        Links       map[string]string    `json:"links"`
        CreatedAt   time.Time            `json:"createdAt"`
        UpdatedAt   time.Time            `json:"updatedAt"`
}

func newAuthResponse(a *influxdb.Authorization, org *influxdb.Organization, user *influxdb.User, ps []permissionResponse) *authResponse <span class="cov8" title="1">{
        res := &amp;authResponse{
                ID:          a.ID,
                Token:       a.Token,
                Status:      a.Status,
                Description: a.Description,
                OrgID:       a.OrgID,
                UserID:      a.UserID,
                User:        user.Name,
                Org:         org.Name,
                Permissions: ps,
                Links: map[string]string{
                        "self": fmt.Sprintf("/api/v2/authorizations/%s", a.ID),
                        "user": fmt.Sprintf("/api/v2/users/%s", a.UserID),
                },
                CreatedAt: a.CreatedAt,
                UpdatedAt: a.UpdatedAt,
        }
        return res
}</span>

func (a *authResponse) toPlatform() *influxdb.Authorization <span class="cov8" title="1">{
        res := &amp;influxdb.Authorization{
                ID:          a.ID,
                Token:       a.Token,
                Status:      a.Status,
                Description: a.Description,
                OrgID:       a.OrgID,
                UserID:      a.UserID,
                CRUDLog: influxdb.CRUDLog{
                        CreatedAt: a.CreatedAt,
                        UpdatedAt: a.UpdatedAt,
                },
        }
        for _, p := range a.Permissions </span><span class="cov8" title="1">{
                res.Permissions = append(res.Permissions, influxdb.Permission{Action: p.Action, Resource: p.Resource.Resource})
        }</span>
        <span class="cov8" title="1">return res</span>
}

type permissionResponse struct {
        Action   influxdb.Action  `json:"action"`
        Resource resourceResponse `json:"resource"`
}

type resourceResponse struct {
        influxdb.Resource
        Name         string `json:"name,omitempty"`
        Organization string `json:"org,omitempty"`
}

func newPermissionsResponse(ctx context.Context, ps []influxdb.Permission, svc influxdb.LookupService) ([]permissionResponse, error) <span class="cov8" title="1">{
        res := make([]permissionResponse, len(ps))
        for i, p := range ps </span><span class="cov8" title="1">{
                res[i] = permissionResponse{
                        Action: p.Action,
                        Resource: resourceResponse{
                                Resource: p.Resource,
                        },
                }

                if p.Resource.ID != nil </span><span class="cov8" title="1">{
                        name, err := svc.FindResourceName(ctx, p.Resource.Type, *p.Resource.ID)
                        if errors2.ErrorCode(err) == errors2.ENotFound </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">res[i].Resource.Name = name</span>
                }

                <span class="cov8" title="1">if p.Resource.OrgID != nil </span><span class="cov8" title="1">{
                        name, err := svc.FindResourceName(ctx, influxdb.OrgsResourceType, *p.Resource.OrgID)
                        if errors2.ErrorCode(err) == errors2.ENotFound </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">res[i].Resource.Organization = name</span>
                }
        }
        <span class="cov8" title="1">return res, nil</span>
}

type authsResponse struct {
        Links map[string]string `json:"links"`
        Auths []*authResponse   `json:"authorizations"`
}

func newAuthsResponse(as []*authResponse) *authsResponse <span class="cov8" title="1">{
        return &amp;authsResponse{
                // TODO(desa): update links to include paging and filter information
                Links: map[string]string{
                        "self": "/api/v2/authorizations",
                },
                Auths: as,
        }
}</span>

// handlePostAuthorization is the HTTP handler for the POST /api/v2/authorizations route.
func (h *AuthorizationHandler) handlePostAuthorization(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        req, err := decodePostAuthorizationRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">user, err := getAuthorizedUser(r, h.UserService)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, influxdb.ErrUnableToCreateToken, w)
                return
        }</span>

        <span class="cov8" title="1">userID := user.ID
        if req.UserID != nil &amp;&amp; req.UserID.Valid() </span><span class="cov8" title="1">{
                userID = *req.UserID
        }</span>

        <span class="cov8" title="1">auth := req.toPlatform(userID)

        org, err := h.OrganizationService.FindOrganizationByID(ctx, auth.OrgID)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, influxdb.ErrUnableToCreateToken, w)
                return
        }</span>

        <span class="cov8" title="1">if err := h.AuthorizationService.CreateAuthorization(ctx, auth); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">perms, err := newPermissionsResponse(ctx, auth.Permissions, h.LookupService)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">h.log.Debug("Auth created ", zap.String("auth", fmt.Sprint(auth)))

        if err := encodeResponse(ctx, w, http.StatusCreated, newAuthResponse(auth, org, user, perms)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type postAuthorizationRequest struct {
        Status      influxdb.Status       `json:"status"`
        OrgID       platform.ID           `json:"orgID"`
        UserID      *platform.ID          `json:"userID,omitempty"`
        Description string                `json:"description"`
        Permissions []influxdb.Permission `json:"permissions"`
}

func (p *postAuthorizationRequest) toPlatform(userID platform.ID) *influxdb.Authorization <span class="cov8" title="1">{
        return &amp;influxdb.Authorization{
                OrgID:       p.OrgID,
                Status:      p.Status,
                Description: p.Description,
                Permissions: p.Permissions,
                UserID:      userID,
        }
}</span>

func newPostAuthorizationRequest(a *influxdb.Authorization) (*postAuthorizationRequest, error) <span class="cov8" title="1">{
        res := &amp;postAuthorizationRequest{
                OrgID:       a.OrgID,
                Description: a.Description,
                Permissions: a.Permissions,
                Status:      a.Status,
        }

        if a.UserID.Valid() </span><span class="cov8" title="1">{
                res.UserID = &amp;a.UserID
        }</span>

        <span class="cov8" title="1">res.SetDefaults()

        return res, res.Validate()</span>
}

func (p *postAuthorizationRequest) SetDefaults() <span class="cov8" title="1">{
        if p.Status == "" </span><span class="cov8" title="1">{
                p.Status = influxdb.Active
        }</span>
}

func (p *postAuthorizationRequest) Validate() error <span class="cov8" title="1">{
        if len(p.Permissions) == 0 </span><span class="cov0" title="0">{
                return &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "authorization must include permissions",
                }
        }</span>

        <span class="cov8" title="1">for _, perm := range p.Permissions </span><span class="cov8" title="1">{
                if err := perm.Valid(); err != nil </span><span class="cov0" title="0">{
                        return &amp;errors2.Error{
                                Err: err,
                        }
                }</span>
        }

        <span class="cov8" title="1">if !p.OrgID.Valid() </span><span class="cov0" title="0">{
                return &amp;errors2.Error{
                        Err:  platform.ErrInvalidID,
                        Code: errors2.EInvalid,
                        Msg:  "org id required",
                }
        }</span>

        <span class="cov8" title="1">if p.Status == "" </span><span class="cov0" title="0">{
                p.Status = influxdb.Active
        }</span>

        <span class="cov8" title="1">err := p.Status.Valid()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func decodePostAuthorizationRequest(ctx context.Context, r *http.Request) (*postAuthorizationRequest, error) <span class="cov8" title="1">{
        a := &amp;postAuthorizationRequest{}
        if err := json.NewDecoder(r.Body).Decode(a); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "invalid json structure",
                        Err:  err,
                }
        }</span>

        <span class="cov8" title="1">a.SetDefaults()

        return a, a.Validate()</span>
}

// handleGetAuthorizations is the HTTP handler for the GET /api/v2/authorizations route.
func (h *AuthorizationHandler) handleGetAuthorizations(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeGetAuthorizationsRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Info("Failed to decode request", zap.String("handler", "getAuthorizations"), zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">opts := influxdb.FindOptions{}
        as, _, err := h.AuthorizationService.FindAuthorizations(ctx, req.filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">auths := make([]*authResponse, 0, len(as))
        for _, a := range as </span><span class="cov8" title="1">{
                o, err := h.OrganizationService.FindOrganizationByID(ctx, a.OrgID)
                if err != nil </span><span class="cov8" title="1">{
                        h.log.Info("Failed to get organization", zap.String("handler", "getAuthorizations"), zap.String("orgID", a.OrgID.String()), zap.Error(err))
                        continue</span>
                }

                <span class="cov8" title="1">u, err := h.UserService.FindUserByID(ctx, a.UserID)
                if err != nil </span><span class="cov8" title="1">{
                        h.log.Info("Failed to get user", zap.String("handler", "getAuthorizations"), zap.String("userID", a.UserID.String()), zap.Error(err))
                        continue</span>
                }

                <span class="cov8" title="1">ps, err := newPermissionsResponse(ctx, a.Permissions, h.LookupService)
                if err != nil </span><span class="cov0" title="0">{
                        h.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov8" title="1">auths = append(auths, newAuthResponse(a, o, u, ps))</span>
        }

        <span class="cov8" title="1">h.log.Debug("Auths retrieved ", zap.String("auths", fmt.Sprint(auths)))

        if err := encodeResponse(ctx, w, http.StatusOK, newAuthsResponse(auths)); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
}

type getAuthorizationsRequest struct {
        filter influxdb.AuthorizationFilter
}

func decodeGetAuthorizationsRequest(ctx context.Context, r *http.Request) (*getAuthorizationsRequest, error) <span class="cov8" title="1">{
        qp := r.URL.Query()

        req := &amp;getAuthorizationsRequest{}

        userID := qp.Get("userID")
        if userID != "" </span><span class="cov8" title="1">{
                id, err := platform.IDFromString(userID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">req.filter.UserID = id</span>
        }

        <span class="cov8" title="1">user := qp.Get("user")
        if user != "" </span><span class="cov0" title="0">{
                req.filter.User = &amp;user
        }</span>

        <span class="cov8" title="1">orgID := qp.Get("orgID")
        if orgID != "" </span><span class="cov8" title="1">{
                id, err := platform.IDFromString(orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">req.filter.OrgID = id</span>
        }

        <span class="cov8" title="1">org := qp.Get("org")
        if org != "" </span><span class="cov0" title="0">{
                req.filter.Org = &amp;org
        }</span>

        <span class="cov8" title="1">authID := qp.Get("id")
        if authID != "" </span><span class="cov0" title="0">{
                id, err := platform.IDFromString(authID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req.filter.ID = id</span>
        }

        <span class="cov8" title="1">return req, nil</span>
}

// handleGetAuthorization is the HTTP handler for the GET /api/v2/authorizations/:id route.
func (h *AuthorizationHandler) handleGetAuthorization(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeGetAuthorizationRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Info("Failed to decode request", zap.String("handler", "getAuthorization"), zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">a, err := h.AuthorizationService.FindAuthorizationByID(ctx, req.ID)
        if err != nil </span><span class="cov8" title="1">{
                // Don't log here, it should already be handled by the service
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">o, err := h.OrganizationService.FindOrganizationByID(ctx, a.OrgID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">u, err := h.UserService.FindUserByID(ctx, a.UserID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">ps, err := newPermissionsResponse(ctx, a.Permissions, h.LookupService)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">h.log.Debug("Auth retrieved ", zap.String("auth", fmt.Sprint(a)))

        if err := encodeResponse(ctx, w, http.StatusOK, newAuthResponse(a, o, u, ps)); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
}

type getAuthorizationRequest struct {
        ID platform.ID
}

func decodeGetAuthorizationRequest(ctx context.Context, r *http.Request) (*getAuthorizationRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;getAuthorizationRequest{
                ID: i,
        }, nil</span>
}

// handleUpdateAuthorization is the HTTP handler for the PATCH /api/v2/authorizations/:id route that updates the authorization's status and desc.
func (h *AuthorizationHandler) handleUpdateAuthorization(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeUpdateAuthorizationRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Info("Failed to decode request", zap.String("handler", "updateAuthorization"), zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">a, err := h.AuthorizationService.FindAuthorizationByID(ctx, req.ID)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">a, err = h.AuthorizationService.UpdateAuthorization(ctx, a.ID, req.AuthorizationUpdate)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">o, err := h.OrganizationService.FindOrganizationByID(ctx, a.OrgID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">u, err := h.UserService.FindUserByID(ctx, a.UserID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">ps, err := newPermissionsResponse(ctx, a.Permissions, h.LookupService)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Auth updated", zap.String("auth", fmt.Sprint(a)))

        if err := encodeResponse(ctx, w, http.StatusOK, newAuthResponse(a, o, u, ps)); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
}

type updateAuthorizationRequest struct {
        ID platform.ID
        *influxdb.AuthorizationUpdate
}

func decodeUpdateAuthorizationRequest(ctx context.Context, r *http.Request) (*updateAuthorizationRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">upd := &amp;influxdb.AuthorizationUpdate{}
        if err := json.NewDecoder(r.Body).Decode(upd); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;updateAuthorizationRequest{
                ID:                  i,
                AuthorizationUpdate: upd,
        }, nil</span>
}

// handleDeleteAuthorization is the HTTP handler for the DELETE /api/v2/authorizations/:id route.
func (h *AuthorizationHandler) handleDeleteAuthorization(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeDeleteAuthorizationRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Info("Failed to decode request", zap.String("handler", "deleteAuthorization"), zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := h.AuthorizationService.DeleteAuthorization(ctx, req.ID); err != nil </span><span class="cov8" title="1">{
                // Don't log here, it should already be handled by the service
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">h.log.Debug("Auth deleted", zap.String("authID", fmt.Sprint(req.ID)))

        w.WriteHeader(http.StatusNoContent)</span>
}

type deleteAuthorizationRequest struct {
        ID platform.ID
}

func decodeDeleteAuthorizationRequest(ctx context.Context, r *http.Request) (*deleteAuthorizationRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;deleteAuthorizationRequest{
                ID: i,
        }, nil</span>
}

func getAuthorizedUser(r *http.Request, svc influxdb.UserService) (*influxdb.User, error) <span class="cov8" title="1">{
        ctx := r.Context()

        a, err := platcontext.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return svc.FindUserByID(ctx, a.GetUserID())</span>
}

// AuthorizationService connects to Influx via HTTP using tokens to manage authorizations
type AuthorizationService struct {
        Client *httpc.Client
}

var _ influxdb.AuthorizationService = (*AuthorizationService)(nil)

// FindAuthorizationByID finds the authorization against a remote influx server.
func (s *AuthorizationService) FindAuthorizationByID(ctx context.Context, id platform.ID) (*influxdb.Authorization, error) <span class="cov8" title="1">{
        var b influxdb.Authorization
        err := s.Client.
                Get(prefixAuthorization, id.String()).
                DecodeJSON(&amp;b).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;b, nil</span>
}

// FindAuthorizationByToken returns a single authorization by Token.
func (s *AuthorizationService) FindAuthorizationByToken(ctx context.Context, token string) (*influxdb.Authorization, error) <span class="cov0" title="0">{
        return nil, errors.New("not supported in HTTP authorization service")
}</span>

// FindAuthorizations returns a list of authorizations that match filter and the total count of matching authorizations.
// Additional options provide pagination &amp; sorting.
func (s *AuthorizationService) FindAuthorizations(ctx context.Context, filter influxdb.AuthorizationFilter, opt ...influxdb.FindOptions) ([]*influxdb.Authorization, int, error) <span class="cov8" title="1">{
        params := influxdb.FindOptionParams(opt...)
        if filter.ID != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"id", filter.ID.String()})
        }</span>
        <span class="cov8" title="1">if filter.UserID != nil </span><span class="cov8" title="1">{
                params = append(params, [2]string{"userID", filter.UserID.String()})
        }</span>
        <span class="cov8" title="1">if filter.User != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"user", *filter.User})
        }</span>
        <span class="cov8" title="1">if filter.OrgID != nil </span><span class="cov8" title="1">{
                params = append(params, [2]string{"orgID", filter.OrgID.String()})
        }</span>
        <span class="cov8" title="1">if filter.Org != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"org", *filter.Org})
        }</span>

        <span class="cov8" title="1">var as authsResponse
        err := s.Client.
                Get(prefixAuthorization).
                QueryParams(params...).
                DecodeJSON(&amp;as).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">auths := make([]*influxdb.Authorization, 0, len(as.Auths))
        for _, a := range as.Auths </span><span class="cov8" title="1">{
                auths = append(auths, a.toPlatform())
        }</span>

        <span class="cov8" title="1">return auths, len(auths), nil</span>
}

// CreateAuthorization creates a new authorization and sets b.ID with the new identifier.
func (s *AuthorizationService) CreateAuthorization(ctx context.Context, a *influxdb.Authorization) error <span class="cov8" title="1">{
        newAuth, err := newPostAuthorizationRequest(a)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return s.Client.
                PostJSON(newAuth, prefixAuthorization).
                DecodeJSON(a).
                Do(ctx)</span>
}

// UpdateAuthorization updates the status and description if available.
func (s *AuthorizationService) UpdateAuthorization(ctx context.Context, id platform.ID, upd *influxdb.AuthorizationUpdate) (*influxdb.Authorization, error) <span class="cov8" title="1">{
        var res authResponse
        err := s.Client.
                PatchJSON(upd, prefixAuthorization, id.String()).
                DecodeJSON(&amp;res).
                Do(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return res.toPlatform(), nil</span>
}

// DeleteAuthorization removes a authorization by id.
func (s *AuthorizationService) DeleteAuthorization(ctx context.Context, id platform.ID) error <span class="cov8" title="1">{
        return s.Client.
                Delete(prefixAuthorization, id.String()).
                Do(ctx)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package http

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "time"

        "github.com/influxdata/httprouter"
        platform "github.com/influxdata/influxdb/v2"
        platcontext "github.com/influxdata/influxdb/v2/context"
        "github.com/influxdata/influxdb/v2/jsonweb"
        errors2 "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/session"
        "github.com/opentracing/opentracing-go"
        "go.uber.org/zap"
)

// AuthenticationHandler is a middleware for authenticating incoming requests.
type AuthenticationHandler struct {
        errors2.HTTPErrorHandler
        log *zap.Logger

        AuthorizationService platform.AuthorizationService
        SessionService       platform.SessionService
        UserService          platform.UserService
        TokenParser          *jsonweb.TokenParser
        SessionRenewDisabled bool

        // This is only really used for it's lookup method the specific http
        // handler used to register routes does not matter.
        noAuthRouter *httprouter.Router

        Handler http.Handler
}

// NewAuthenticationHandler creates an authentication handler.
func NewAuthenticationHandler(log *zap.Logger, h errors2.HTTPErrorHandler) *AuthenticationHandler <span class="cov8" title="1">{
        return &amp;AuthenticationHandler{
                log:              log,
                HTTPErrorHandler: h,
                Handler:          http.NotFoundHandler(),
                TokenParser:      jsonweb.NewTokenParser(jsonweb.EmptyKeyStore),
                noAuthRouter:     httprouter.New(),
        }
}</span>

// RegisterNoAuthRoute excludes routes from needing authentication.
func (h *AuthenticationHandler) RegisterNoAuthRoute(method, path string) <span class="cov8" title="1">{
        // the handler specified here does not matter.
        h.noAuthRouter.HandlerFunc(method, path, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span>{<span class="cov0" title="0">}</span>))
}

const (
        tokenAuthScheme   = "token"
        sessionAuthScheme = "session"
)

// ProbeAuthScheme probes the http request for the requests for token or cookie session.
func ProbeAuthScheme(r *http.Request) (string, error) <span class="cov8" title="1">{
        _, tokenErr := GetToken(r)
        _, sessErr := session.DecodeCookieSession(r.Context(), r)

        if tokenErr != nil &amp;&amp; sessErr != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("token required")
        }</span>

        <span class="cov8" title="1">if tokenErr == nil </span><span class="cov8" title="1">{
                return tokenAuthScheme, nil
        }</span>

        <span class="cov8" title="1">return sessionAuthScheme, nil</span>
}

func (h *AuthenticationHandler) unauthorized(ctx context.Context, w http.ResponseWriter, err error) <span class="cov8" title="1">{
        h.log.Info("Unauthorized", zap.Error(err))
        UnauthorizedError(ctx, h, w)
}</span>

// ServeHTTP extracts the session or token from the http request and places the resulting authorizer on the request context.
func (h *AuthenticationHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if handler, _, _ := h.noAuthRouter.Lookup(r.Method, r.URL.Path); handler != nil </span><span class="cov8" title="1">{
                h.Handler.ServeHTTP(w, r)
                return
        }</span>

        <span class="cov8" title="1">ctx := r.Context()
        scheme, err := ProbeAuthScheme(r)
        if err != nil </span><span class="cov8" title="1">{
                h.unauthorized(ctx, w, err)
                return
        }</span>

        <span class="cov8" title="1">var auth platform.Authorizer
        switch scheme </span>{
        case tokenAuthScheme:<span class="cov8" title="1">
                auth, err = h.extractAuthorization(ctx, r)</span>
        case sessionAuthScheme:<span class="cov8" title="1">
                auth, err = h.extractSession(ctx, r)</span>
        default:<span class="cov0" title="0">
                // TODO: this error will be nil if it gets here, this should be remedied with some
                //  sentinel error I'm thinking
                err = errors.New("invalid auth scheme")</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                h.unauthorized(ctx, w, err)
                return
        }</span>

        // jwt based auth is permission based rather than identity based
        // and therefor has no associated user. if the user ID is invalid
        // disregard the user active check
        <span class="cov8" title="1">if auth.GetUserID().Valid() </span><span class="cov8" title="1">{
                if err = h.isUserActive(ctx, auth); err != nil </span><span class="cov8" title="1">{
                        InactiveUserError(ctx, h, w)
                        return
                }</span>
        }

        <span class="cov8" title="1">ctx = platcontext.SetAuthorizer(ctx, auth)

        if span := opentracing.SpanFromContext(ctx); span != nil </span><span class="cov0" title="0">{
                span.SetTag("user_id", auth.GetUserID().String())
        }</span>

        <span class="cov8" title="1">h.Handler.ServeHTTP(w, r.WithContext(ctx))</span>
}

func (h *AuthenticationHandler) isUserActive(ctx context.Context, auth platform.Authorizer) error <span class="cov8" title="1">{
        u, err := h.UserService.FindUserByID(ctx, auth.GetUserID())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if u.Status != "inactive" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return &amp;errors2.Error{Code: errors2.EForbidden, Msg: "User is inactive"}</span>
}

func (h *AuthenticationHandler) extractAuthorization(ctx context.Context, r *http.Request) (platform.Authorizer, error) <span class="cov8" title="1">{
        t, err := GetToken(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">token, err := h.TokenParser.Parse(t)
        if err == nil </span><span class="cov8" title="1">{
                return token, nil
        }</span>

        // if the error returned signifies ths token is
        // not a well formed JWT then use it as a lookup
        // key for its associated authorization
        // otherwise return the error
        <span class="cov8" title="1">if !jsonweb.IsMalformedError(err) </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return h.AuthorizationService.FindAuthorizationByToken(ctx, t)</span>
}

func (h *AuthenticationHandler) extractSession(ctx context.Context, r *http.Request) (*platform.Session, error) <span class="cov8" title="1">{
        k, err := session.DecodeCookieSession(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">s, err := h.SessionService.FindSession(ctx, k)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !h.SessionRenewDisabled </span><span class="cov8" title="1">{
                // if the session is not expired, renew the session
                err = h.SessionService.RenewSession(ctx, s, time.Now().Add(platform.RenewSessionTime))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return s, err</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package http

import (
        "fmt"
        "io"
        "mime/multipart"
        "net/http"
        "strconv"
        "time"

        "github.com/NYTimes/gziphandler"
        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/authorizer"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/kit/tracing"
        "go.uber.org/zap"
)

// BackupBackend is all services and associated parameters required to construct the BackupHandler.
type BackupBackend struct {
        Logger *zap.Logger
        errors.HTTPErrorHandler

        BackupService           influxdb.BackupService
        SqlBackupRestoreService influxdb.SqlBackupRestoreService
        BucketManifestWriter    influxdb.BucketManifestWriter
}

// NewBackupBackend returns a new instance of BackupBackend.
func NewBackupBackend(b *APIBackend) *BackupBackend <span class="cov8" title="1">{
        return &amp;BackupBackend{
                Logger: b.Logger.With(zap.String("handler", "backup")),

                HTTPErrorHandler:        b.HTTPErrorHandler,
                BackupService:           b.BackupService,
                SqlBackupRestoreService: b.SqlBackupRestoreService,
                BucketManifestWriter:    b.BucketManifestWriter,
        }
}</span>

// BackupHandler is http handler for backup service.
type BackupHandler struct {
        *httprouter.Router
        errors.HTTPErrorHandler
        Logger *zap.Logger

        BackupService           influxdb.BackupService
        SqlBackupRestoreService influxdb.SqlBackupRestoreService
        BucketManifestWriter    influxdb.BucketManifestWriter
}

const (
        prefixBackup       = "/api/v2/backup"
        backupKVStorePath  = prefixBackup + "/kv"
        backupShardPath    = prefixBackup + "/shards/:shardID"
        backupMetadataPath = prefixBackup + "/metadata"
)

// NewBackupHandler creates a new handler at /api/v2/backup to receive backup requests.
func NewBackupHandler(b *BackupBackend) *BackupHandler <span class="cov8" title="1">{
        h := &amp;BackupHandler{
                HTTPErrorHandler:        b.HTTPErrorHandler,
                Router:                  NewRouter(b.HTTPErrorHandler),
                Logger:                  b.Logger,
                BackupService:           b.BackupService,
                SqlBackupRestoreService: b.SqlBackupRestoreService,
                BucketManifestWriter:    b.BucketManifestWriter,
        }

        h.HandlerFunc(http.MethodGet, backupKVStorePath, h.handleBackupKVStore) // Deprecated

        h.Handler(http.MethodGet, backupShardPath, gziphandler.GzipHandler(http.HandlerFunc(h.handleBackupShard)))
        h.Handler(http.MethodGet, backupMetadataPath, gziphandler.GzipHandler(h.requireOperPermissions(http.HandlerFunc(h.handleBackupMetadata))))

        return h
}</span>

// requireOperPermissions returns an "unauthorized" response for requests that do not have OperPermissions.
// This is needed for the handleBackupMetadata handler, which sets a header prior to
// accessing any methods on the BackupService which would also return an "authorized" response.
func (h *BackupHandler) requireOperPermissions(next http.Handler) http.HandlerFunc <span class="cov8" title="1">{
        fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ctx := r.Context()

                if err := authorizer.IsAllowedAll(ctx, influxdb.OperPermissions()); err != nil </span><span class="cov8" title="1">{
                        h.HandleHTTPError(ctx, err, w)
                        return
                }</span>
                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}

func (h *BackupHandler) handleBackupKVStore(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        span, r := tracing.ExtractFromHTTPRequest(r, "BackupHandler.handleBackupKVStore")
        defer span.Finish()

        ctx := r.Context()

        if err := h.BackupService.BackupKVStore(ctx, w); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
}

func (h *BackupHandler) handleBackupShard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        span, r := tracing.ExtractFromHTTPRequest(r, "BackupHandler.handleBackupShard")
        defer span.Finish()

        ctx := r.Context()

        params := httprouter.ParamsFromContext(ctx)
        shardID, err := strconv.ParseUint(params.ByName("shardID"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">var since time.Time
        if s := r.URL.Query().Get("since"); s != "" </span><span class="cov0" title="0">{
                if since, err = time.ParseInLocation(time.RFC3339, s, time.UTC); err != nil </span><span class="cov0" title="0">{
                        h.HandleHTTPError(ctx, err, w)
                        return
                }</span>
        }

        <span class="cov0" title="0">if err := h.BackupService.BackupShard(ctx, w, shardID, since); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
}

func (h *BackupHandler) handleBackupMetadata(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        span, r := tracing.ExtractFromHTTPRequest(r, "BackupHandler.handleBackupMetadata")
        defer span.Finish()

        ctx := r.Context()

        // Lock the sqlite and bolt databases prior to writing the response to prevent
        // data inconsistencies.
        h.BackupService.RLockKVStore()
        defer h.BackupService.RUnlockKVStore()

        h.SqlBackupRestoreService.RLockSqlStore()
        defer h.SqlBackupRestoreService.RUnlockSqlStore()

        dataWriter := multipart.NewWriter(w)
        w.Header().Set("Content-Type", "multipart/mixed; boundary="+dataWriter.Boundary())

        parts := []struct {
                contentType        string
                contentDisposition string
                writeFn            func(io.Writer) error
        }{
                {
                        "application/octet-stream",
                        fmt.Sprintf("attachment; name=%q", "kv"),
                        func(fw io.Writer) error </span><span class="cov8" title="1">{
                                return h.BackupService.BackupKVStore(ctx, fw)
                        }</span>,
                },
                {
                        "application/octet-stream",
                        fmt.Sprintf("attachment; name=%q", "sql"),
                        func(fw io.Writer) error <span class="cov8" title="1">{
                                return h.SqlBackupRestoreService.BackupSqlStore(ctx, fw)
                        }</span>,
                },
                {
                        "application/json; charset=utf-8",
                        fmt.Sprintf("attachment; name=%q", "buckets"),
                        func(fw io.Writer) error <span class="cov8" title="1">{
                                return h.BucketManifestWriter.WriteManifest(ctx, fw)
                        }</span>,
                },
        }

        <span class="cov8" title="1">for _, p := range parts </span><span class="cov8" title="1">{
                pw, err := dataWriter.CreatePart(map[string][]string{
                        "Content-Type":        {p.contentType},
                        "Content-Disposition": {p.contentDisposition},
                })
                if err != nil </span><span class="cov0" title="0">{
                        h.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov8" title="1">if err := p.writeFn(pw); err != nil </span><span class="cov0" title="0">{
                        h.HandleHTTPError(ctx, err, w)
                        return
                }</span>
        }

        <span class="cov8" title="1">if err := dataWriter.Close(); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package http

import (
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "path"
        "time"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        pctx "github.com/influxdata/influxdb/v2/context"
        "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/kit/tracing"
        "github.com/influxdata/influxdb/v2/notification/check"
        "github.com/influxdata/influxdb/v2/pkg/httpc"
        "github.com/influxdata/influxdb/v2/query/fluxlang"
        "github.com/influxdata/influxdb/v2/task/taskmodel"
        "go.uber.org/zap"
)

// CheckBackend is all services and associated parameters required to construct
// the CheckBackendHandler.
type CheckBackend struct {
        errors.HTTPErrorHandler
        log *zap.Logger

        AlgoWProxy                 FeatureProxyHandler
        TaskService                taskmodel.TaskService
        CheckService               influxdb.CheckService
        UserResourceMappingService influxdb.UserResourceMappingService
        LabelService               influxdb.LabelService
        UserService                influxdb.UserService
        OrganizationService        influxdb.OrganizationService
        FluxLanguageService        fluxlang.FluxLanguageService
}

// NewCheckBackend returns a new instance of CheckBackend.
func NewCheckBackend(log *zap.Logger, b *APIBackend) *CheckBackend <span class="cov8" title="1">{
        return &amp;CheckBackend{
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        log,
                AlgoWProxy:                 b.AlgoWProxy,
                TaskService:                b.TaskService,
                CheckService:               b.CheckService,
                UserResourceMappingService: b.UserResourceMappingService,
                LabelService:               b.LabelService,
                UserService:                b.UserService,
                OrganizationService:        b.OrganizationService,
                FluxLanguageService:        b.FluxLanguageService,
        }
}</span>

// CheckHandler is the handler for the check service
type CheckHandler struct {
        *httprouter.Router
        errors.HTTPErrorHandler
        log *zap.Logger

        TaskService                taskmodel.TaskService
        CheckService               influxdb.CheckService
        UserResourceMappingService influxdb.UserResourceMappingService
        LabelService               influxdb.LabelService
        UserService                influxdb.UserService
        OrganizationService        influxdb.OrganizationService
        FluxLanguageService        fluxlang.FluxLanguageService
}

const (
        prefixChecks          = "/api/v2/checks"
        checksIDPath          = "/api/v2/checks/:id"
        checksIDQueryPath     = "/api/v2/checks/:id/query"
        checksIDMembersPath   = "/api/v2/checks/:id/members"
        checksIDMembersIDPath = "/api/v2/checks/:id/members/:userID"
        checksIDOwnersPath    = "/api/v2/checks/:id/owners"
        checksIDOwnersIDPath  = "/api/v2/checks/:id/owners/:userID"
        checksIDLabelsPath    = "/api/v2/checks/:id/labels"
        checksIDLabelsIDPath  = "/api/v2/checks/:id/labels/:lid"
)

// NewCheckHandler returns a new instance of CheckHandler.
func NewCheckHandler(log *zap.Logger, b *CheckBackend) *CheckHandler <span class="cov8" title="1">{
        h := &amp;CheckHandler{
                Router:           NewRouter(b.HTTPErrorHandler),
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,

                CheckService:               b.CheckService,
                UserResourceMappingService: b.UserResourceMappingService,
                LabelService:               b.LabelService,
                UserService:                b.UserService,
                TaskService:                b.TaskService,
                OrganizationService:        b.OrganizationService,
                FluxLanguageService:        b.FluxLanguageService,
        }

        h.Handler("POST", prefixChecks, withFeatureProxy(b.AlgoWProxy, http.HandlerFunc(h.handlePostCheck)))
        h.HandlerFunc("GET", prefixChecks, h.handleGetChecks)
        h.HandlerFunc("GET", checksIDPath, h.handleGetCheck)
        h.HandlerFunc("GET", checksIDQueryPath, h.handleGetCheckQuery)
        h.HandlerFunc("DELETE", checksIDPath, h.handleDeleteCheck)
        h.Handler("PUT", checksIDPath, withFeatureProxy(b.AlgoWProxy, http.HandlerFunc(h.handlePutCheck)))
        h.Handler("PATCH", checksIDPath, withFeatureProxy(b.AlgoWProxy, http.HandlerFunc(h.handlePatchCheck)))

        memberBackend := MemberBackend{
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        b.log.With(zap.String("handler", "member")),
                ResourceType:               influxdb.ChecksResourceType,
                UserType:                   influxdb.Member,
                UserResourceMappingService: b.UserResourceMappingService,
                UserService:                b.UserService,
        }
        h.HandlerFunc("POST", checksIDMembersPath, newPostMemberHandler(memberBackend))
        h.HandlerFunc("GET", checksIDMembersPath, newGetMembersHandler(memberBackend))
        h.HandlerFunc("DELETE", checksIDMembersIDPath, newDeleteMemberHandler(memberBackend))

        ownerBackend := MemberBackend{
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        b.log.With(zap.String("handler", "member")),
                ResourceType:               influxdb.ChecksResourceType,
                UserType:                   influxdb.Owner,
                UserResourceMappingService: b.UserResourceMappingService,
                UserService:                b.UserService,
        }
        h.HandlerFunc("POST", checksIDOwnersPath, newPostMemberHandler(ownerBackend))
        h.HandlerFunc("GET", checksIDOwnersPath, newGetMembersHandler(ownerBackend))
        h.HandlerFunc("DELETE", checksIDOwnersIDPath, newDeleteMemberHandler(ownerBackend))

        labelBackend := &amp;LabelBackend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              b.log.With(zap.String("handler", "label")),
                LabelService:     b.LabelService,
                ResourceType:     influxdb.ChecksResourceType,
        }
        h.HandlerFunc("GET", checksIDLabelsPath, newGetLabelsHandler(labelBackend))
        h.HandlerFunc("POST", checksIDLabelsPath, newPostLabelHandler(labelBackend))
        h.HandlerFunc("DELETE", checksIDLabelsIDPath, newDeleteLabelHandler(labelBackend))

        return h
}</span>

type checkLinks struct {
        Self    string `json:"self"`
        Labels  string `json:"labels"`
        Members string `json:"members"`
        Owners  string `json:"owners"`
        Query   string `json:"query"`
}

type checkResponse struct {
        influxdb.Check
        Status          string           `json:"status"`
        Labels          []influxdb.Label `json:"labels"`
        Links           checkLinks       `json:"links"`
        LatestCompleted time.Time        `json:"latestCompleted,omitempty"`
        LatestScheduled time.Time        `json:"latestScheduled,omitempty"`
        LastRunStatus   string           `json:"LastRunStatus,omitempty"`
        LastRunError    string           `json:"LastRunError,omitempty"`
        TaskID          platform.ID      `json:"taskID,omitempty"`
}

type postCheckRequest struct {
        influxdb.CheckCreate
        Labels []string `json:"labels"`
}

type decodeLabels struct {
        Labels []string `json:"labels"`
}

func (resp checkResponse) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        b1, err := json.Marshal(resp.Check)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">b2, err := json.Marshal(struct {
                Labels          []influxdb.Label `json:"labels"`
                Links           checkLinks       `json:"links"`
                Status          string           `json:"status"`
                LatestCompleted time.Time        `json:"latestCompleted,omitempty"`
                LatestScheduled time.Time        `json:"latestScheduled,omitempty"`
                LastRunStatus   string           `json:"lastRunStatus,omitempty"`
                LastRunError    string           `json:"lastRunError,omitempty"`
                TaskID          platform.ID      `json:"taskID,omitempty"`
        }{
                Links:           resp.Links,
                Labels:          resp.Labels,
                Status:          resp.Status,
                LatestCompleted: resp.LatestCompleted,
                LatestScheduled: resp.LatestScheduled,
                LastRunStatus:   resp.LastRunStatus,
                LastRunError:    resp.LastRunError,
                TaskID:          resp.Check.GetTaskID(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return []byte(string(b1[:len(b1)-1]) + ", " + string(b2[1:])), nil</span>
}

type checksResponse struct {
        Checks []*checkResponse      `json:"checks"`
        Links  *influxdb.PagingLinks `json:"links"`
}

func (h *CheckHandler) newCheckResponse(ctx context.Context, chk influxdb.Check, labels []*influxdb.Label) (*checkResponse, error) <span class="cov8" title="1">{
        // TODO(desa): this should be handled in the check and not exposed in http land, but is currently blocking the FE. https://github.com/influxdata/influxdb/issues/15259
        task, err := h.TaskService.FindTaskByID(ctx, chk.GetTaskID())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">res := &amp;checkResponse{
                Check: chk,
                Links: checkLinks{
                        Self:    fmt.Sprintf("/api/v2/checks/%s", chk.GetID()),
                        Labels:  fmt.Sprintf("/api/v2/checks/%s/labels", chk.GetID()),
                        Members: fmt.Sprintf("/api/v2/checks/%s/members", chk.GetID()),
                        Owners:  fmt.Sprintf("/api/v2/checks/%s/owners", chk.GetID()),
                        Query:   fmt.Sprintf("/api/v2/checks/%s/query", chk.GetID()),
                },
                Labels:          []influxdb.Label{},
                LatestCompleted: task.LatestCompleted,
                LatestScheduled: task.LatestScheduled,
                LastRunStatus:   task.LastRunStatus,
                LastRunError:    task.LastRunError,
                TaskID:          chk.GetTaskID(),
        }

        for _, l := range labels </span><span class="cov8" title="1">{
                res.Labels = append(res.Labels, *l)
        }</span>

        <span class="cov8" title="1">res.Status = task.Status

        return res, nil</span>
}

func (h *CheckHandler) newChecksResponse(ctx context.Context, chks []influxdb.Check, labelService influxdb.LabelService, f influxdb.PagingFilter, opts influxdb.FindOptions) *checksResponse <span class="cov8" title="1">{
        resp := &amp;checksResponse{
                Checks: []*checkResponse{},
                Links:  influxdb.NewPagingLinks(prefixChecks, opts, f, len(chks)),
        }
        for _, chk := range chks </span><span class="cov8" title="1">{
                labels, _ := labelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: chk.GetID(), ResourceType: influxdb.ChecksResourceType})
                cr, err := h.newCheckResponse(ctx, chk, labels)
                if err != nil </span><span class="cov0" title="0">{
                        h.log.Info("Failed to retrieve task associated with check", zap.String("checkID", chk.GetID().String()))
                        continue</span>
                }

                <span class="cov8" title="1">resp.Checks = append(resp.Checks, cr)</span>
        }
        <span class="cov8" title="1">return resp</span>
}

func decodeGetCheckRequest(ctx context.Context, r *http.Request) (i platform.ID, err error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return i, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return i, err
        }</span>
        <span class="cov8" title="1">return i, nil</span>
}

func (h *CheckHandler) handleGetChecks(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        filter, opts, err := decodeCheckFilter(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">chks, _, err := h.CheckService.FindChecks(ctx, *filter, *opts)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Checks retrieved", zap.String("checks", fmt.Sprint(chks)))

        if err := encodeResponse(ctx, w, http.StatusOK, h.newChecksResponse(ctx, chks, h.LabelService, filter, *opts)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func (h *CheckHandler) handleGetCheckQuery(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        id, err := decodeGetCheckRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">chk, err := h.CheckService.FindCheckByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">flux, err := chk.GenerateFlux(h.FluxLanguageService)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Check query retrieved", zap.String("check query", flux))
        if err := encodeResponse(ctx, w, http.StatusOK, newFluxResponse(flux)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type fluxResp struct {
        Flux string `json:"flux"`
}

func newFluxResponse(flux string) fluxResp <span class="cov8" title="1">{
        return fluxResp{
                Flux: flux,
        }
}</span>

func (h *CheckHandler) handleGetCheck(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        id, err := decodeGetCheckRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">chk, err := h.CheckService.FindCheckByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Check retrieved", zap.String("check", fmt.Sprint(chk)))

        labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: chk.GetID(), ResourceType: influxdb.ChecksResourceType})
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">cr, err := h.newCheckResponse(ctx, chk, labels)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusOK, cr); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func decodeCheckFilter(ctx context.Context, r *http.Request) (*influxdb.CheckFilter, *influxdb.FindOptions, error) <span class="cov8" title="1">{
        auth, err := pctx.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">f := &amp;influxdb.CheckFilter{
                UserResourceMappingFilter: influxdb.UserResourceMappingFilter{
                        UserID:       auth.GetUserID(),
                        ResourceType: influxdb.ChecksResourceType,
                },
        }

        opts, err := influxdb.DecodeFindOptions(r)
        if err != nil </span><span class="cov0" title="0">{
                return f, nil, err
        }</span>

        <span class="cov8" title="1">q := r.URL.Query()
        if orgIDStr := q.Get("orgID"); orgIDStr != "" </span><span class="cov0" title="0">{
                orgID, err := platform.IDFromString(orgIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return f, opts, &amp;errors.Error{
                                Code: errors.EInvalid,
                                Msg:  "orgID is invalid",
                                Err:  err,
                        }
                }</span>
                <span class="cov0" title="0">f.OrgID = orgID</span>
        } else<span class="cov8" title="1"> if orgNameStr := q.Get("org"); orgNameStr != "" </span><span class="cov0" title="0">{
                f.Org = &amp;orgNameStr
        }</span>
        <span class="cov8" title="1">return f, opts, err</span>
}

type decodeStatus struct {
        Status influxdb.Status `json:"status"`
}

func decodePostCheckRequest(r *http.Request) (postCheckRequest, error) <span class="cov8" title="1">{
        b, err := ioutil.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return postCheckRequest{}, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>
        <span class="cov8" title="1">defer r.Body.Close()

        chk, err := check.UnmarshalJSON(b)
        if err != nil </span><span class="cov0" title="0">{
                return postCheckRequest{}, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>

        <span class="cov8" title="1">var ds decodeStatus
        if err := json.Unmarshal(b, &amp;ds); err != nil </span><span class="cov0" title="0">{
                return postCheckRequest{}, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>

        <span class="cov8" title="1">var dl decodeLabels
        if err := json.Unmarshal(b, &amp;dl); err != nil </span><span class="cov0" title="0">{
                return postCheckRequest{}, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>

        <span class="cov8" title="1">return postCheckRequest{
                CheckCreate: influxdb.CheckCreate{
                        Check:  chk,
                        Status: ds.Status,
                },
                Labels: dl.Labels,
        }, nil</span>
}

func decodePutCheckRequest(ctx context.Context, lang fluxlang.FluxLanguageService, r *http.Request) (influxdb.CheckCreate, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return influxdb.CheckCreate{}, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">i := new(platform.ID)
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return influxdb.CheckCreate{}, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "invalid check id format",
                }
        }</span>

        <span class="cov8" title="1">b, err := ioutil.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return influxdb.CheckCreate{}, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "unable to read HTTP body",
                        Err:  err,
                }
        }</span>
        <span class="cov8" title="1">defer r.Body.Close()

        chk, err := check.UnmarshalJSON(b)
        if err != nil </span><span class="cov0" title="0">{
                return influxdb.CheckCreate{}, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "malformed check body",
                        Err:  err,
                }
        }</span>
        <span class="cov8" title="1">chk.SetID(*i)

        if err := chk.Valid(lang); err != nil </span><span class="cov0" title="0">{
                return influxdb.CheckCreate{}, err
        }</span>

        <span class="cov8" title="1">var ds decodeStatus
        err = json.Unmarshal(b, &amp;ds)
        if err != nil </span><span class="cov0" title="0">{
                return influxdb.CheckCreate{}, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>

        <span class="cov8" title="1">return influxdb.CheckCreate{
                Check:  chk,
                Status: ds.Status,
        }, nil</span>
}

type patchCheckRequest struct {
        platform.ID
        Update influxdb.CheckUpdate
}

func decodePatchCheckRequest(ctx context.Context, r *http.Request) (*patchCheckRequest, error) <span class="cov8" title="1">{
        id := httprouter.ParamsFromContext(ctx).ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var upd influxdb.CheckUpdate
        if err := json.NewDecoder(r.Body).Decode(&amp;upd); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  err.Error(),
                }
        }</span>
        <span class="cov8" title="1">if err := upd.Valid(); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  err.Error(),
                }
        }</span>

        <span class="cov8" title="1">return &amp;patchCheckRequest{
                ID:     i,
                Update: upd,
        }, nil</span>
}

// handlePostCheck is the HTTP handler for the POST /api/v2/checks route.
func (h *CheckHandler) handlePostCheck(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        chk, err := decodePostCheckRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">auth, err := pctx.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := h.CheckService.CreateCheck(ctx, chk.CheckCreate, auth.GetUserID()); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">labels := h.mapNewCheckLabels(ctx, chk.CheckCreate, chk.Labels)

        cr, err := h.newCheckResponse(ctx, chk, labels)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusCreated, cr); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

// mapNewCheckLabels takes label ids from create check and maps them to the newly created check
func (h *CheckHandler) mapNewCheckLabels(ctx context.Context, chk influxdb.CheckCreate, labels []string) []*influxdb.Label <span class="cov8" title="1">{
        var ls []*influxdb.Label
        for _, sid := range labels </span><span class="cov0" title="0">{
                var lid platform.ID
                err := lid.DecodeFromString(sid)

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">label, err := h.LabelService.FindLabelByID(ctx, lid)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">mapping := influxdb.LabelMapping{
                        LabelID:      label.ID,
                        ResourceID:   chk.GetID(),
                        ResourceType: influxdb.ChecksResourceType,
                }

                err = h.LabelService.CreateLabelMapping(ctx, &amp;mapping)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">ls = append(ls, label)</span>
        }
        <span class="cov8" title="1">return ls</span>
}

// handlePutCheck is the HTTP handler for the PUT /api/v2/checks route.
func (h *CheckHandler) handlePutCheck(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        chk, err := decodePutCheckRequest(ctx, h.FluxLanguageService, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">c, err := h.CheckService.UpdateCheck(ctx, chk.GetID(), chk)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: c.GetID(), ResourceType: influxdb.ChecksResourceType})
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Check replaced", zap.String("check", fmt.Sprint(c)))

        cr, err := h.newCheckResponse(ctx, c, labels)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusOK, cr); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

// handlePatchCheck is the HTTP handler for the PATCH /api/v2/checks/:id route.
func (h *CheckHandler) handlePatchCheck(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodePatchCheckRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">chk, err := h.CheckService.PatchCheck(ctx, req.ID, req.Update)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: chk.GetID(), ResourceType: influxdb.ChecksResourceType})
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Check patch", zap.String("check", fmt.Sprint(chk)))

        cr, err := h.newCheckResponse(ctx, chk, labels)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusOK, cr); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func (h *CheckHandler) handleDeleteCheck(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        i, err := decodeGetCheckRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err = h.CheckService.DeleteCheck(ctx, i); err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Check deleted", zap.String("checkID", fmt.Sprint(i)))

        w.WriteHeader(http.StatusNoContent)</span>
}

func checkIDPath(id platform.ID) string <span class="cov0" title="0">{
        return path.Join(prefixChecks, id.String())
}</span>

// CheckService is a client to interact with the handlers in this package over HTTP.
// It does not implement influxdb.CheckService because it returns a concrete representation of the API response
// and influxdb.Check as returned by that interface is not appropriate for this use case.
type CheckService struct {
        Client *httpc.Client
}

// FindCheckByID returns the Check matching the ID.
func (s *CheckService) FindCheckByID(ctx context.Context, id platform.ID) (*Check, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        var cr Check
        err := s.Client.
                Get(checkIDPath(id)).
                DecodeJSON(&amp;cr).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cr, nil</span>
}

// FindCheck returns the first check matching the filter.
func (s *CheckService) FindCheck(ctx context.Context, filter influxdb.CheckFilter) (*Check, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        cs, n, err := s.FindChecks(ctx, filter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if n == 0 &amp;&amp; filter.Name != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.ENotFound,
                        Op:   influxdb.OpFindBucket,
                        Msg:  fmt.Sprintf("check %q not found", *filter.Name),
                }
        }</span> else<span class="cov0" title="0"> if n == 0 </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.ENotFound,
                        Op:   influxdb.OpFindBucket,
                        Msg:  "check not found",
                }
        }</span>

        <span class="cov0" title="0">return cs[0], nil</span>
}

// FindChecks returns a list of checks that match filter and the total count of matching checks.
// Additional options provide pagination &amp; sorting.
func (s *CheckService) FindChecks(ctx context.Context, filter influxdb.CheckFilter, opt ...influxdb.FindOptions) ([]*Check, int, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        params := influxdb.FindOptionParams(opt...)
        if filter.OrgID != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"orgID", filter.OrgID.String()})
        }</span>
        <span class="cov0" title="0">if filter.Org != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"org", *filter.Org})
        }</span>
        <span class="cov0" title="0">if filter.ID != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"id", filter.ID.String()})
        }</span>
        <span class="cov0" title="0">if filter.Name != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"name", *filter.Name})
        }</span>

        <span class="cov0" title="0">var cr Checks
        err := s.Client.
                Get(prefixChecks).
                QueryParams(params...).
                DecodeJSON(&amp;cr).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return cr.Checks, len(cr.Checks), nil</span>
}

// CreateCheck creates a new check.
func (s *CheckService) CreateCheck(ctx context.Context, c *Check) (*Check, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        var r Check
        err := s.Client.
                PostJSON(c, prefixChecks).
                DecodeJSON(&amp;r).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;r, nil</span>
}

// UpdateCheck updates a check.
func (s *CheckService) UpdateCheck(ctx context.Context, id platform.ID, u *Check) (*Check, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        var r Check
        err := s.Client.
                PutJSON(u, checkIDPath(id)).
                DecodeJSON(&amp;r).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;r, nil</span>
}

// PatchCheck changes the status, description or name of a check.
func (s *CheckService) PatchCheck(ctx context.Context, id platform.ID, u influxdb.CheckUpdate) (*Check, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        var r Check
        err := s.Client.
                PatchJSON(u, checkIDPath(id)).
                DecodeJSON(&amp;r).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;r, nil</span>
}

// DeleteCheck removes a check.
func (s *CheckService) DeleteCheck(ctx context.Context, id platform.ID) error <span class="cov0" title="0">{
        return s.Client.
                Delete(checkIDPath(id)).
                Do(ctx)
}</span>

// TODO(gavincabbage): These structures should be in a common place, like other models,
//                 but the common influxdb.Check is an interface that is not appropriate for an API client.
type Checks struct {
        Checks []*Check              `json:"checks"`
        Links  *influxdb.PagingLinks `json:"links"`
}

type Check struct {
        ID                    platform.ID       `json:"id,omitempty"`
        Name                  string            `json:"name"`
        OrgID                 platform.ID       `json:"orgID,omitempty"`
        OwnerID               platform.ID       `json:"ownerID,omitempty"`
        CreatedAt             time.Time         `json:"createdAt,omitempty"`
        UpdatedAt             time.Time         `json:"updatedAt,omitempty"`
        Query                 *CheckQuery       `json:"query"`
        Status                influxdb.Status   `json:"status"`
        Description           string            `json:"description"`
        LatestCompleted       time.Time         `json:"latestCompleted"`
        LastRunStatus         string            `json:"lastRunStatus"`
        LastRunError          string            `json:"lastRunError"`
        Labels                []*influxdb.Label `json:"labels"`
        Links                 *CheckLinks       `json:"links"`
        Type                  string            `json:"type"`
        TimeSince             string            `json:"timeSince"`
        StaleTime             string            `json:"staleTime"`
        ReportZero            bool              `json:"reportZero"`
        Level                 string            `json:"level"`
        Every                 string            `json:"every"`
        Offset                string            `json:"offset"`
        Tags                  []*influxdb.Tag   `json:"tags"`
        StatusMessageTemplate string            `json:"statusMessageTemplate"`
        Thresholds            []*CheckThreshold `json:"thresholds"`
}

type CheckQuery struct {
        Text          string              `json:"text"`
        EditMode      string              `json:"editMode"`
        Name          string              `json:"name"`
        BuilderConfig *CheckBuilderConfig `json:"builderConfig"`
}

type CheckBuilderConfig struct {
        Buckets []string `json:"buckets"`
        Tags    []struct {
                Key                   string   `json:"key"`
                Values                []string `json:"values"`
                AggregateFunctionType string   `json:"aggregateFunctionType"`
        } `json:"tags"`
        Functions []struct {
                Name string `json:"name"`
        } `json:"functions"`
        AggregateWindow struct {
                Period string `json:"period"`
        } `json:"aggregateWindow"`
}

type CheckLinks struct {
        Self    string `json:"self"`
        Labels  string `json:"labels"`
        Members string `json:"members"`
        Owners  string `json:"owners"`
        Query   string `json:"query"`
}

type CheckThreshold struct {
        check.ThresholdConfigBase
        Type   string  `json:"type"`
        Value  float64 `json:"value,omitempty"`
        Min    float64 `json:"min,omitempty"`
        Max    float64 `json:"max,omitempty"`
        Within bool    `json:"within"`
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package http

import (
        "crypto/tls"
        "net"
        "net/http"
        "net/url"
        "time"

        "github.com/influxdata/influxdb/v2/dbrp"
        "github.com/influxdata/influxdb/v2/kit/tracing"
        "github.com/influxdata/influxdb/v2/pkg/httpc"
)

// NewHTTPClient creates a new httpc.Client type. This call sets all
// the options that are important to the http pkg on the httpc client.
// The default status fn and so forth will all be set for the caller.
// In addition, some options can be specified. Those will be added to the defaults.
func NewHTTPClient(addr, token string, insecureSkipVerify bool, opts ...httpc.ClientOptFn) (*httpc.Client, error) <span class="cov8" title="1">{
        u, err := url.Parse(addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">defaultOpts := []httpc.ClientOptFn{
                httpc.WithAddr(addr),
                httpc.WithContentType("application/json"),
                httpc.WithHTTPClient(NewClient(u.Scheme, insecureSkipVerify)),
                httpc.WithInsecureSkipVerify(insecureSkipVerify),
                httpc.WithStatusFn(CheckError),
        }
        if token != "" </span><span class="cov8" title="1">{
                defaultOpts = append(defaultOpts, httpc.WithAuthToken(token))
        }</span>
        <span class="cov8" title="1">opts = append(defaultOpts, opts...)
        return httpc.New(opts...)</span>
}

// Service connects to an InfluxDB via HTTP.
type Service struct {
        Addr               string
        Token              string
        InsecureSkipVerify bool

        *TaskService
        *NotificationRuleService
        *VariableService
        *WriteService
        *CheckService
        *NotificationEndpointService
        *TelegrafService
        *LabelService
        DBRPMappingService *dbrp.Client
}

// NewService returns a service that is an HTTP client to a remote.
// Address and token are needed for those services that do not use httpc.Client,
// but use those for configuring.
// Usually one would do:
//
// ```
// c := NewHTTPClient(addr, token, insecureSkipVerify)
// s := NewService(c, addr token)
// ```
//
// So one should provide the same `addr` and `token` to both calls to ensure consistency
// in the behavior of the returned service.
func NewService(httpClient *httpc.Client, addr, token string) (*Service, error) <span class="cov0" title="0">{
        return &amp;Service{
                Addr:                    addr,
                Token:                   token,
                TaskService:             &amp;TaskService{Client: httpClient},
                NotificationRuleService: &amp;NotificationRuleService{Client: httpClient},
                VariableService:         &amp;VariableService{Client: httpClient},
                WriteService: &amp;WriteService{
                        Addr:  addr,
                        Token: token,
                },
                CheckService:                &amp;CheckService{Client: httpClient},
                NotificationEndpointService: &amp;NotificationEndpointService{Client: httpClient},
                TelegrafService:             NewTelegrafService(httpClient),
                LabelService:                &amp;LabelService{Client: httpClient},
                DBRPMappingService:          dbrp.NewClient(httpClient),
        }, nil
}</span>

// NewURL concats addr and path.
func NewURL(addr, path string) (*url.URL, error) <span class="cov8" title="1">{
        u, err := url.Parse(addr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">u.Path = path
        return u, nil</span>
}

// NewClient returns an http.Client that pools connections and injects a span.
func NewClient(scheme string, insecure bool) *http.Client <span class="cov8" title="1">{
        return httpClient(scheme, insecure)
}</span>

// SpanTransport injects the http.RoundTripper.RoundTrip() request
// with a span.
type SpanTransport struct {
        base http.RoundTripper
}

// RoundTrip implements the http.RoundTripper, intercepting the base
// round trippers call and injecting a span.
func (s *SpanTransport) RoundTrip(r *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        span, _ := tracing.StartSpanFromContext(r.Context())
        defer span.Finish()
        tracing.InjectToHTTPRequest(span, r)
        return s.base.RoundTrip(r)
}</span>

// DefaultTransport wraps http.DefaultTransport in SpanTransport to inject
// tracing headers into all outgoing requests.
var DefaultTransport http.RoundTripper = &amp;SpanTransport{base: http.DefaultTransport}

// DefaultTransportInsecure is identical to DefaultTransport, with
// the exception that tls.Config is configured with InsecureSkipVerify
// set to true.
var DefaultTransportInsecure http.RoundTripper = &amp;SpanTransport{
        base: &amp;http.Transport{
                Proxy: http.ProxyFromEnvironment,
                DialContext: (&amp;net.Dialer{
                        Timeout:   30 * time.Second,
                        KeepAlive: 30 * time.Second,
                        DualStack: true,
                }).DialContext,
                ForceAttemptHTTP2:     true,
                MaxIdleConns:          100,
                IdleConnTimeout:       90 * time.Second,
                TLSHandshakeTimeout:   10 * time.Second,
                ExpectContinueTimeout: 1 * time.Second,
                TLSClientConfig: &amp;tls.Config{
                        InsecureSkipVerify: true,
                },
        },
}

func httpClient(scheme string, insecure bool) *http.Client <span class="cov8" title="1">{
        if scheme == "https" &amp;&amp; insecure </span><span class="cov0" title="0">{
                return &amp;http.Client{Transport: DefaultTransportInsecure}
        }</span>
        <span class="cov8" title="1">return &amp;http.Client{Transport: DefaultTransport}</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package http

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/go-chi/chi"
        "github.com/go-chi/chi/middleware"
        "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/authorizer"
        "github.com/influxdata/influxdb/v2/kit/cli"
        "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        kithttp "github.com/influxdata/influxdb/v2/kit/transport/http"
        "github.com/spf13/pflag"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

const prefixConfig = "/api/v2/config"

func errInvalidType(dest interface{}, flag string) error <span class="cov8" title="1">{
        return &amp;errors.Error{
                Code: errors.EInternal,
                Err:  fmt.Errorf("unknown destination type %T for %q", dest, flag),
        }
}</span>

type parsedOpt map[string]optValue

type optValue []byte

func (o optValue) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{ return o, nil }</span>

type ConfigHandler struct {
        chi.Router

        log *zap.Logger
        api *kithttp.API

        config parsedOpt
}

// NewConfigHandler creates a handler that will return a JSON object with key/value pairs for the configuration values
// used during the launcher startup. The opts slice provides a list of options names along with a pointer to their
// value.
func NewConfigHandler(log *zap.Logger, opts []cli.Opt) (*ConfigHandler, error) <span class="cov8" title="1">{
        h := &amp;ConfigHandler{
                log: log,
                api: kithttp.NewAPI(kithttp.WithLog(log)),
        }

        if err := h.parseOptions(opts); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">r := chi.NewRouter()
        r.Use(
                middleware.Recoverer,
                middleware.RequestID,
                middleware.RealIP,
                h.mwAuthorize,
        )

        r.Get("/", h.handleGetConfig)
        h.Router = r
        return h, nil</span>
}

func (h *ConfigHandler) Prefix() string <span class="cov8" title="1">{
        return prefixConfig
}</span>

func (h *ConfigHandler) parseOptions(opts []cli.Opt) error <span class="cov8" title="1">{
        h.config = make(parsedOpt)

        for _, o := range opts </span><span class="cov8" title="1">{
                var b []byte
                switch o.DestP.(type) </span>{
                // Known types for configuration values. Currently, these can all be encoded directly with json.Marshal.
                case *string, *int, *int32, *int64, *bool, *time.Duration, *[]string, *map[string]string, pflag.Value, *platform.ID, *zapcore.Level:<span class="cov8" title="1">
                        var err error
                        b, err = json.Marshal(o.DestP)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                default:<span class="cov8" title="1">
                        // Return an error if we don't know how to marshal this type.
                        return errInvalidType(o.DestP, o.Flag)</span>
                }

                <span class="cov8" title="1">h.config[o.Flag] = b</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (h *ConfigHandler) handleGetConfig(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        h.api.Respond(w, r, http.StatusOK, h.config)
}</span>

func (h *ConfigHandler) mwAuthorize(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ctx := r.Context()

                if err := authorizer.IsAllowedAll(ctx, influxdb.OperPermissions()); err != nil </span><span class="cov8" title="1">{
                        h.api.Err(w, r, &amp;errors.Error{
                                Code: errors.EUnauthorized,
                                Msg:  fmt.Sprintf("access to %s requires operator permissions", h.Prefix()),
                        })
                        return
                }</span>
                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package http

import (
        "context"
        "net/http"
)

// Flusher flushes data from a store to reset; used for testing.
type Flusher interface {
        Flush(ctx context.Context)
}

// DebugFlush clears all services for testing.
func DebugFlush(ctx context.Context, next http.Handler, f Flusher) http.HandlerFunc <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                if r.URL.Path == "/debug/flush" </span><span class="cov0" title="0">{
                        f.Flush(ctx)
                        w.Header().Set("Content-Type", "text/html; charset=utf-8")
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package http

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        http "net/http"
        "time"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        pcontext "github.com/influxdata/influxdb/v2/context"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/kit/tracing"
        "github.com/influxdata/influxdb/v2/models"
        "github.com/influxdata/influxdb/v2/predicate"
        "go.uber.org/zap"
)

// DeleteBackend is all services and associated parameters required to construct
// the DeleteHandler.
type DeleteBackend struct {
        log *zap.Logger
        errors.HTTPErrorHandler

        DeleteService       influxdb.DeleteService
        BucketService       influxdb.BucketService
        OrganizationService influxdb.OrganizationService
}

// NewDeleteBackend returns a new instance of DeleteBackend
func NewDeleteBackend(log *zap.Logger, b *APIBackend) *DeleteBackend <span class="cov8" title="1">{
        return &amp;DeleteBackend{
                log: log,

                HTTPErrorHandler:    b.HTTPErrorHandler,
                DeleteService:       b.DeleteService,
                BucketService:       b.BucketService,
                OrganizationService: b.OrganizationService,
        }
}</span>

// DeleteHandler receives a delete request with a predicate and sends it to storage.
type DeleteHandler struct {
        errors.HTTPErrorHandler
        *httprouter.Router

        log *zap.Logger

        DeleteService       influxdb.DeleteService
        BucketService       influxdb.BucketService
        OrganizationService influxdb.OrganizationService
}

const (
        prefixDelete = "/api/v2/delete"
)

var (
        msgStartTooSoon = fmt.Sprintf("invalid start time, start time must not be before %s", time.Unix(0, models.MinNanoTime).UTC().Format(time.RFC3339Nano))
        msgStopTooLate  = fmt.Sprintf("invalid stop time, stop time must not be after %s", time.Unix(0, models.MaxNanoTime).UTC().Format(time.RFC3339Nano))
)

// NewDeleteHandler creates a new handler at /api/v2/delete to receive delete requests.
func NewDeleteHandler(log *zap.Logger, b *DeleteBackend) *DeleteHandler <span class="cov8" title="1">{
        h := &amp;DeleteHandler{
                HTTPErrorHandler: b.HTTPErrorHandler,
                Router:           NewRouter(b.HTTPErrorHandler),
                log:              log,

                BucketService:       b.BucketService,
                DeleteService:       b.DeleteService,
                OrganizationService: b.OrganizationService,
        }

        h.HandlerFunc("POST", prefixDelete, h.handleDelete)
        return h
}</span>

func (h *DeleteHandler) handleDelete(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        span, r := tracing.ExtractFromHTTPRequest(r, "DeleteHandler")
        defer span.Finish()

        ctx := r.Context()
        defer r.Body.Close()

        a, err := pcontext.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">dr, err := decodeDeleteRequest(
                ctx, r,
                h.OrganizationService,
                h.BucketService,
        )
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">p, err := influxdb.NewPermissionAtID(dr.Bucket.ID, influxdb.WriteAction, influxdb.BucketsResourceType, dr.Org.ID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, &amp;errors.Error{
                        Code: errors.EInternal,
                        Op:   "http/handleDelete",
                        Msg:  fmt.Sprintf("unable to create permission for bucket: %v", err),
                        Err:  err,
                }, w)
                return
        }</span>

        <span class="cov8" title="1">if pset, err := a.PermissionSet(); err != nil || !pset.Allowed(*p) </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, &amp;errors.Error{
                        Code: errors.EForbidden,
                        Op:   "http/handleDelete",
                        Msg:  "insufficient permissions to delete",
                }, w)
                return
        }</span>

        <span class="cov8" title="1">if err := h.DeleteService.DeleteBucketRangePredicate(r.Context(), dr.Org.ID, dr.Bucket.ID, dr.Start, dr.Stop, dr.Predicate); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, &amp;errors.Error{
                        Code: errors.EInternal,
                        Op:   "http/handleDelete",
                        Msg:  fmt.Sprintf("unable to delete: %v", err),
                        Err:  err,
                }, w)
                return
        }</span>

        <span class="cov8" title="1">h.log.Debug("Deleted",
                zap.String("orgID", fmt.Sprint(dr.Org.ID.String())),
                zap.String("bucketID", fmt.Sprint(dr.Bucket.ID.String())),
        )

        w.WriteHeader(http.StatusNoContent)</span>
}

func decodeDeleteRequest(ctx context.Context, r *http.Request, orgSvc influxdb.OrganizationService, bucketSvc influxdb.BucketService) (*deleteRequest, error) <span class="cov8" title="1">{
        dr := new(deleteRequest)
        err := json.NewDecoder(r.Body).Decode(dr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "invalid request; error parsing request json",
                        Err:  err,
                }
        }</span>
        <span class="cov8" title="1">if dr.Org, err = queryOrganization(ctx, r, orgSvc); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if dr.Bucket, err = queryBucket(ctx, dr.Org.ID, r, bucketSvc); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return dr, nil</span>
}

type deleteRequest struct {
        Org       *influxdb.Organization
        Bucket    *influxdb.Bucket
        Start     int64
        Stop      int64
        Predicate influxdb.Predicate
}

type deleteRequestDecode struct {
        Start     string `json:"start"`
        Stop      string `json:"stop"`
        Predicate string `json:"predicate"`
}

// DeleteRequest is the request send over http to delete points.
type DeleteRequest struct {
        OrgID     string `json:"-"`
        Org       string `json:"-"` // org name
        BucketID  string `json:"-"`
        Bucket    string `json:"-"`
        Start     string `json:"start"`
        Stop      string `json:"stop"`
        Predicate string `json:"predicate"`
}

func (dr *deleteRequest) UnmarshalJSON(b []byte) error <span class="cov8" title="1">{
        var drd deleteRequestDecode
        if err := json.Unmarshal(b, &amp;drd); err != nil </span><span class="cov0" title="0">{
                return &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "Invalid delete predicate node request",
                        Err:  err,
                }
        }</span>
        <span class="cov8" title="1">*dr = deleteRequest{}
        start, err := time.Parse(time.RFC3339Nano, drd.Start)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;errors.Error{
                        Code: errors.EInvalid,
                        Op:   "http/Delete",
                        Msg:  "invalid RFC3339Nano for field start, please format your time with RFC3339Nano format, example: 2009-01-02T23:00:00Z",
                }
        }</span>
        <span class="cov8" title="1">if err = models.CheckTime(start); err != nil </span><span class="cov8" title="1">{
                return &amp;errors.Error{
                        Code: errors.EInvalid,
                        Op:   "http/Delete",
                        Msg:  msgStartTooSoon,
                }
        }</span>
        <span class="cov8" title="1">dr.Start = start.UnixNano()

        stop, err := time.Parse(time.RFC3339Nano, drd.Stop)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;errors.Error{
                        Code: errors.EInvalid,
                        Op:   "http/Delete",
                        Msg:  "invalid RFC3339Nano for field stop, please format your time with RFC3339Nano format, example: 2009-01-01T23:00:00Z",
                }
        }</span>
        <span class="cov8" title="1">if err = models.CheckTime(stop); err != nil </span><span class="cov8" title="1">{
                return &amp;errors.Error{
                        Code: errors.EInvalid,
                        Op:   "http/Delete",
                        Msg:  msgStopTooLate,
                }
        }</span>
        <span class="cov8" title="1">dr.Stop = stop.UnixNano()
        node, err := predicate.Parse(drd.Predicate)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">dr.Predicate, err = predicate.New(node)
        return err</span>
}

// DeleteService sends data over HTTP to delete points.
type DeleteService struct {
        Addr               string
        Token              string
        InsecureSkipVerify bool
}

// DeleteBucketRangePredicate send delete request over http to delete points.
func (s *DeleteService) DeleteBucketRangePredicate(ctx context.Context, dr DeleteRequest) error <span class="cov0" title="0">{
        u, err := NewURL(s.Addr, prefixDelete)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">buf := new(bytes.Buffer)
        if err := json.NewEncoder(buf).Encode(dr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">req, err := http.NewRequest("POST", u.String(), buf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json; charset=utf-8")
        SetToken(s.Token, req)

        params := req.URL.Query()
        if dr.OrgID != "" </span><span class="cov0" title="0">{
                params.Set("orgID", dr.OrgID)
        }</span> else<span class="cov0" title="0"> if dr.Org != "" </span><span class="cov0" title="0">{
                params.Set("org", dr.Org)
        }</span>

        <span class="cov0" title="0">if dr.BucketID != "" </span><span class="cov0" title="0">{
                params.Set("bucketID", dr.BucketID)
        }</span> else<span class="cov0" title="0"> if dr.Bucket != "" </span><span class="cov0" title="0">{
                params.Set("bucket", dr.Bucket)
        }</span>
        <span class="cov0" title="0">req.URL.RawQuery = params.Encode()

        hc := NewClient(u.Scheme, s.InsecureSkipVerify)

        resp, err := hc.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        return CheckError(resp)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package http

import (
        "context"
        "fmt"
        "net/http"
        "path"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/kit/tracing"
        "github.com/influxdata/influxdb/v2/pkg/httpc"
        "go.uber.org/zap"
)

const prefixDocuments = "/api/v2/documents"

// DocumentService is an interface HTTP-exposed portion of the document service.
type DocumentService interface {
        GetDocuments(ctx context.Context, namespace string, orgID platform.ID) ([]*influxdb.Document, error)
}

// DocumentBackend is all services and associated parameters required to construct
// the DocumentHandler.
type DocumentBackend struct {
        log *zap.Logger
        errors.HTTPErrorHandler

        DocumentService influxdb.DocumentService
}

// NewDocumentBackend returns a new instance of DocumentBackend.
func NewDocumentBackend(log *zap.Logger, b *APIBackend) *DocumentBackend <span class="cov8" title="1">{
        return &amp;DocumentBackend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,
                DocumentService:  b.DocumentService,
        }
}</span>

// DocumentHandler represents an HTTP API handler for documents.
type DocumentHandler struct {
        *httprouter.Router

        log *zap.Logger
        errors.HTTPErrorHandler

        DocumentService influxdb.DocumentService
        LabelService    influxdb.LabelService
}

const (
        documentsPath = "/api/v2/documents/:ns"
)

// NewDocumentHandler returns a new instance of DocumentHandler.
// TODO(desa): this should probably take a namespace
func NewDocumentHandler(b *DocumentBackend) *DocumentHandler <span class="cov8" title="1">{
        h := &amp;DocumentHandler{
                Router:           NewRouter(b.HTTPErrorHandler),
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              b.log,

                DocumentService: b.DocumentService,
        }

        h.HandlerFunc("GET", documentsPath, h.handleGetDocuments)

        return h
}</span>

type documentResponse struct {
        Links map[string]string `json:"links"`
        *influxdb.Document
}

func newDocumentResponse(ns string, d *influxdb.Document) *documentResponse <span class="cov8" title="1">{
        if d.Labels == nil </span><span class="cov8" title="1">{
                d.Labels = []*influxdb.Label{}
        }</span>
        <span class="cov8" title="1">return &amp;documentResponse{
                Links: map[string]string{
                        "self": fmt.Sprintf("/api/v2/documents/%s/%s", ns, d.ID),
                },
                Document: d,
        }</span>
}

type documentsResponse struct {
        Documents []*documentResponse `json:"documents"`
}

func newDocumentsResponse(ns string, docs []*influxdb.Document) *documentsResponse <span class="cov8" title="1">{
        ds := make([]*documentResponse, 0, len(docs))
        for _, doc := range docs </span><span class="cov8" title="1">{
                ds = append(ds, newDocumentResponse(ns, doc))
        }</span>

        <span class="cov8" title="1">return &amp;documentsResponse{
                Documents: ds,
        }</span>
}

// handleGetDocuments is the HTTP handler for the GET /api/v2/documents/:ns route.
func (h *DocumentHandler) handleGetDocuments(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeGetDocumentsRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">s, err := h.DocumentService.FindDocumentStore(ctx, req.Namespace)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">ds, err := s.FindDocuments(ctx, req.OrgID)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">h.log.Debug("Documents retrieved", zap.String("documents", fmt.Sprint(ds)))

        if err := encodeResponse(ctx, w, http.StatusOK, newDocumentsResponse(req.Namespace, ds)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type getDocumentsRequest struct {
        Namespace string
        Org       string
        OrgID     platform.ID
}

func decodeGetDocumentsRequest(ctx context.Context, r *http.Request) (*getDocumentsRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        ns := params.ByName("ns")
        if ns == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing namespace",
                }
        }</span>

        <span class="cov8" title="1">qp := r.URL.Query()
        req := &amp;getDocumentsRequest{
                Namespace: ns,
                Org:       qp.Get("org"),
        }

        if oidStr := qp.Get("orgID"); oidStr != "" </span><span class="cov8" title="1">{
                oid, err := platform.IDFromString(oidStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, &amp;errors.Error{
                                Code: errors.EInvalid,
                                Msg:  "Invalid orgID",
                        }
                }</span>
                <span class="cov8" title="1">req.OrgID = *oid</span>
        }
        <span class="cov8" title="1">return req, nil</span>
}

type documentService struct {
        Client *httpc.Client
}

// NewDocumentService creates a client to connect to Influx via HTTP to manage documents.
func NewDocumentService(client *httpc.Client) DocumentService <span class="cov8" title="1">{
        return &amp;documentService{
                Client: client,
        }
}</span>

func buildDocumentsPath(namespace string) string <span class="cov8" title="1">{
        return path.Join(prefixDocuments, namespace)
}</span>

// GetDocuments returns the documents for a `namespace` and an `orgID`.
// Returned documents do not  contain their content.
func (s *documentService) GetDocuments(ctx context.Context, namespace string, orgID platform.ID) ([]*influxdb.Document, error) <span class="cov8" title="1">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        var resp documentsResponse
        r := s.Client.
                Get(buildDocumentsPath(namespace)).
                DecodeJSON(&amp;resp)
        r = r.QueryParams([2]string{"orgID", orgID.String()})
        if err := r.Do(ctx); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">docs := make([]*influxdb.Document, len(resp.Documents))
        for i := 0; i &lt; len(docs); i++ </span><span class="cov8" title="1">{
                docs[i] = resp.Documents[i].Document
        }</span>
        <span class="cov8" title="1">return docs, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package http

import (
        "fmt"
        "strconv"
        "time"

        "github.com/influxdata/influxdb/v2/kit/platform/errors"
)

// ErrInvalidDuration is returned when parsing a malformatted duration.
var ErrInvalidDuration = &amp;errors.Error{
        Code: errors.EInvalid,
        Msg:  "invalid duration",
}

// ParseDuration parses a time duration from a string.
// This is needed instead of time.ParseDuration because this will support
// the full syntax that InfluxQL supports for specifying durations
// including weeks and days.
func ParseDuration(s string) (time.Duration, error) <span class="cov8" title="1">{
        // Return an error if the string is blank or one character
        if len(s) &lt; 2 </span><span class="cov8" title="1">{
                return 0, ErrInvalidDuration
        }</span>

        // Split string into individual runes.
        <span class="cov8" title="1">a := split(s)

        // Start with a zero duration.
        var d time.Duration
        i := 0

        // Check for a negative.
        isNegative := false
        if a[i] == '-' </span><span class="cov8" title="1">{
                isNegative = true
                i++
        }</span>

        <span class="cov8" title="1">var measure int64
        var unit string

        // Parsing loop.
        for i &lt; len(a) </span><span class="cov8" title="1">{
                // Find the number portion.
                start := i
                for ; i &lt; len(a) &amp;&amp; isDigit(a[i]); i++ </span>{<span class="cov8" title="1">
                        // Scan for the digits.
                }</span>

                // Check if we reached the end of the string prematurely.
                <span class="cov8" title="1">if i &gt;= len(a) || i == start </span><span class="cov8" title="1">{
                        return 0, ErrInvalidDuration
                }</span>

                // Parse the numeric part.
                <span class="cov8" title="1">n, err := strconv.ParseInt(string(a[start:i]), 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return 0, ErrInvalidDuration
                }</span>
                <span class="cov8" title="1">measure = n

                // Extract the unit of measure.
                unit = string(a[i])
                switch a[i] </span>{
                case 'n':<span class="cov8" title="1">
                        d += time.Duration(n) * time.Nanosecond
                        if i+1 &lt; len(a) &amp;&amp; a[i+1] == 's' </span><span class="cov8" title="1">{
                                unit = string(a[i : i+2])
                                i += 2
                                continue</span>
                        }
                case 'u', 'µ':<span class="cov8" title="1">
                        d += time.Duration(n) * time.Microsecond
                        if i+1 &lt; len(a) &amp;&amp; a[i+1] == 's' </span><span class="cov8" title="1">{
                                unit = string(a[i : i+2])
                                i += 2
                                continue</span>
                        }
                case 'm':<span class="cov8" title="1">
                        // Check for `mo` and `ms`; month and millisecond, respectively.
                        if i+1 &lt; len(a) </span><span class="cov8" title="1">{
                                switch a[i+1] </span>{
                                case 's':<span class="cov8" title="1"> // ms == milliseconds
                                        unit = string(a[i : i+2])
                                        d += time.Duration(n) * time.Millisecond
                                        i += 2
                                        continue</span>
                                case 'o':<span class="cov8" title="1"> // mo == month
                                        // TODO(goller): use real duration values:
                                        // https://github.com/influxdata/platform/issues/657
                                        unit = string(a[i : i+2])
                                        d += time.Duration(n) * 30 * 24 * time.Hour
                                        i += 2
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">d += time.Duration(n) * time.Minute</span>
                case 's':<span class="cov8" title="1">
                        d += time.Duration(n) * time.Second</span>
                case 'h':<span class="cov8" title="1">
                        d += time.Duration(n) * time.Hour</span>
                case 'd':<span class="cov8" title="1">
                        d += time.Duration(n) * 24 * time.Hour</span>
                case 'w':<span class="cov8" title="1">
                        // TODO(goller): use real duration values:
                        // https://github.com/influxdata/platform/issues/657
                        d += time.Duration(n) * 7 * 24 * time.Hour</span>
                case 'y':<span class="cov8" title="1">
                        // TODO(goller): use real duration values:
                        // https://github.com/influxdata/platform/issues/657
                        d += time.Duration(n) * 365 * 24 * time.Hour</span>
                default:<span class="cov8" title="1">
                        return 0, ErrInvalidDuration</span>
                }
                <span class="cov8" title="1">i++</span>
        }

        // Check to see if we overflowed a duration
        <span class="cov8" title="1">if d &lt; 0 &amp;&amp; !isNegative </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("overflowed duration %d%s: choose a smaller duration or INF", measure, unit)
        }</span>

        <span class="cov8" title="1">if isNegative </span><span class="cov8" title="1">{
                d = -d
        }</span>
        <span class="cov8" title="1">return d, nil</span>
}

// FormatDuration formats a duration to a string.
func FormatDuration(d time.Duration) string <span class="cov8" title="1">{
        if d == 0 </span><span class="cov0" title="0">{
                return "0s"
        }</span> else<span class="cov8" title="1"> if d%(365*24*time.Hour) == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dy", d/(365*24*time.Hour))
        }</span> else<span class="cov8" title="1"> if d%(30*24*time.Hour) == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dmo", d/(30*24*time.Hour))
        }</span> else<span class="cov8" title="1"> if d%(7*24*time.Hour) == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dw", d/(7*24*time.Hour))
        }</span> else<span class="cov8" title="1"> if d%(24*time.Hour) == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dd", d/(24*time.Hour))
        }</span> else<span class="cov8" title="1"> if d%time.Hour == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dh", d/time.Hour)
        }</span> else<span class="cov8" title="1"> if d%time.Minute == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dm", d/time.Minute)
        }</span> else<span class="cov8" title="1"> if d%time.Second == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%ds", d/time.Second)
        }</span> else<span class="cov8" title="1"> if d%time.Millisecond == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dms", d/time.Millisecond)
        }</span> else<span class="cov8" title="1"> if d%time.Microsecond == 0 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%dus", d/time.Microsecond)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%dns", d/time.Nanosecond)</span>
}

// split splits a string into a slice of runes.
func split(s string) (a []rune) <span class="cov8" title="1">{
        for _, ch := range s </span><span class="cov8" title="1">{
                a = append(a, ch)
        }</span>
        <span class="cov8" title="1">return</span>
}

// isDigit returns true if the rune is a digit.
func isDigit(ch rune) bool <span class="cov8" title="1">{ return (ch &gt;= '0' &amp;&amp; ch &lt;= '9') }</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package http

import (
        "bytes"
        "context"
        "encoding/json"
        stderrors "errors"
        "fmt"
        "io"
        "mime"
        "net/http"
        "strings"

        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        khttp "github.com/influxdata/influxdb/v2/kit/transport/http"
)

// AuthzError is returned for authorization errors. When this error type is returned,
// the user can be presented with a generic "authorization failed" error, but
// the system can log the underlying AuthzError() so that operators have insight
// into what actually failed with authorization.
type AuthzError interface {
        error
        AuthzError() error
}

// CheckErrorStatus for status and any error in the response.
func CheckErrorStatus(code int, res *http.Response) error <span class="cov8" title="1">{
        err := CheckError(res)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if res.StatusCode != code </span><span class="cov0" title="0">{
                return fmt.Errorf("unexpected status code: %s", res.Status)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CheckError reads the http.Response and returns an error if one exists.
// It will automatically recognize the errors returned by Influx services
// and decode the error into an internal error type. If the error cannot
// be determined in that way, it will create a generic error message.
//
// If there is no error, then this returns nil.
func CheckError(resp *http.Response) (err error) <span class="cov8" title="1">{
        switch resp.StatusCode / 100 </span>{
        case 4, 5:<span class="cov8" title="1"></span>
                // We will attempt to parse this error outside of this block.
        case 2:<span class="cov8" title="1">
                return nil</span>
        default:<span class="cov0" title="0">
                // TODO(jsternberg): Figure out what to do here?
                return &amp;errors.Error{
                        Code: errors.EInternal,
                        Msg:  fmt.Sprintf("unexpected status code: %d %s", resp.StatusCode, resp.Status),
                }</span>
        }

        <span class="cov8" title="1">perr := &amp;errors.Error{
                Code: khttp.StatusCodeToErrorCode(resp.StatusCode),
        }

        if resp.StatusCode == http.StatusUnsupportedMediaType </span><span class="cov0" title="0">{
                perr.Msg = fmt.Sprintf("invalid media type: %q", resp.Header.Get("Content-Type"))
                return perr
        }</span>

        <span class="cov8" title="1">contentType := resp.Header.Get("Content-Type")
        if contentType == "" </span><span class="cov8" title="1">{
                // Assume JSON if there is no content-type.
                contentType = "application/json"
        }</span>
        <span class="cov8" title="1">mediatype, _, _ := mime.ParseMediaType(contentType)

        var buf bytes.Buffer
        if _, err := io.Copy(&amp;buf, resp.Body); err != nil </span><span class="cov0" title="0">{
                perr.Msg = "failed to read error response"
                perr.Err = err
                return perr
        }</span>

        <span class="cov8" title="1">switch mediatype </span>{
        case "application/json":<span class="cov8" title="1">
                if err := json.Unmarshal(buf.Bytes(), perr); err != nil </span><span class="cov8" title="1">{
                        perr.Msg = fmt.Sprintf("attempted to unmarshal error as JSON but failed: %q", err)
                        perr.Err = firstLineAsError(buf)
                }</span>
        default:<span class="cov8" title="1">
                perr.Err = firstLineAsError(buf)</span>
        }

        <span class="cov8" title="1">if perr.Code == "" </span><span class="cov8" title="1">{
                // given it was unset during attempt to unmarshal as JSON
                perr.Code = khttp.StatusCodeToErrorCode(resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return perr</span>
}

func firstLineAsError(buf bytes.Buffer) error <span class="cov8" title="1">{
        line, _ := buf.ReadString('\n')
        return stderrors.New(strings.TrimSuffix(line, "\n"))
}</span>

// UnauthorizedError encodes a error message and status code for unauthorized access.
func UnauthorizedError(ctx context.Context, h errors.HTTPErrorHandler, w http.ResponseWriter) <span class="cov8" title="1">{
        h.HandleHTTPError(ctx, &amp;errors.Error{
                Code: errors.EUnauthorized,
                Msg:  "unauthorized access",
        }, w)
}</span>

// InactiveUserError encode a error message and status code for inactive users.
func InactiveUserError(ctx context.Context, h errors.HTTPErrorHandler, w http.ResponseWriter) <span class="cov8" title="1">{
        h.HandleHTTPError(ctx, &amp;errors.Error{
                Code: errors.EForbidden,
                Msg:  "User is inactive",
        }, w)
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package http

import (
        "context"
        "encoding/json"
        "net/http"

        "github.com/go-chi/chi"
        "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/kit/prom"
        kithttp "github.com/influxdata/influxdb/v2/kit/transport/http"
        "github.com/influxdata/influxdb/v2/pprof"
        "github.com/prometheus/client_golang/prometheus"
        "go.uber.org/zap"
)

const (
        // MetricsPath exposes the prometheus metrics over /metrics.
        MetricsPath = "/metrics"
        // ReadyPath exposes the readiness of the service over /ready.
        ReadyPath = "/ready"
        // HealthPath exposes the health of the service over /health.
        HealthPath = "/health"
        // DebugPath exposes /debug/pprof for go debugging.
        DebugPath = "/debug"
)

// Handler provides basic handling of metrics, health and debug endpoints.
// All other requests are passed down to the sub handler.
type Handler struct {
        name string
        r    chi.Router

        requests   *prometheus.CounterVec
        requestDur *prometheus.HistogramVec

        // log logs all HTTP requests as they are served
        log *zap.Logger
}

type (
        handlerOpts struct {
                log           *zap.Logger
                apiHandler    http.Handler
                healthHandler http.Handler
                readyHandler  http.Handler
                pprofEnabled  bool

                // NOTE: Track the registry even if metricsExposed = false
                // so we can report HTTP metrics via telemetry.
                metricsRegistry *prom.Registry
                metricsExposed  bool
        }

        HandlerOptFn func(opts *handlerOpts)
)

func (o *handlerOpts) metricsHTTPHandler() http.Handler <span class="cov8" title="1">{
        if o.metricsRegistry != nil &amp;&amp; o.metricsExposed </span><span class="cov8" title="1">{
                return o.metricsRegistry.HTTPHandler()
        }</span>
        <span class="cov8" title="1">handlerFunc := func(rw http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                kithttp.WriteErrorResponse(r.Context(), rw, errors.EForbidden, "metrics disabled")
        }</span>
        <span class="cov8" title="1">return http.HandlerFunc(handlerFunc)</span>
}

func WithLog(l *zap.Logger) HandlerOptFn <span class="cov8" title="1">{
        return func(opts *handlerOpts) </span><span class="cov8" title="1">{
                opts.log = l
        }</span>
}

func WithAPIHandler(h http.Handler) HandlerOptFn <span class="cov8" title="1">{
        return func(opts *handlerOpts) </span><span class="cov8" title="1">{
                opts.apiHandler = h
        }</span>
}

func WithPprofEnabled(enabled bool) HandlerOptFn <span class="cov0" title="0">{
        return func(opts *handlerOpts) </span><span class="cov0" title="0">{
                opts.pprofEnabled = enabled
        }</span>
}

func WithMetrics(reg *prom.Registry, exposed bool) HandlerOptFn <span class="cov8" title="1">{
        return func(opts *handlerOpts) </span><span class="cov8" title="1">{
                opts.metricsRegistry = reg
                opts.metricsExposed = exposed
        }</span>
}

type AddHeader struct {
        WriteHeader func(header http.Header)
}

// Middleware is a middleware that mutates the header of all responses
func (h *AddHeader) Middleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                h.WriteHeader(w.Header())
                next.ServeHTTP(w, r)
        }</span>
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}

// NewRootHandler creates a new handler with the given name and registers any root-level
// (non-API) routes enabled by the caller.
func NewRootHandler(name string, opts ...HandlerOptFn) *Handler <span class="cov8" title="1">{
        opt := handlerOpts{
                log:             zap.NewNop(),
                healthHandler:   http.HandlerFunc(HealthHandler),
                readyHandler:    ReadyHandler(),
                pprofEnabled:    false,
                metricsRegistry: nil,
                metricsExposed:  false,
        }
        for _, o := range opts </span><span class="cov8" title="1">{
                o(&amp;opt)
        }</span>

        <span class="cov8" title="1">h := &amp;Handler{
                name: name,
                log:  opt.log,
        }
        h.initMetrics()

        r := chi.NewRouter()
        buildHeader := &amp;AddHeader{
                WriteHeader: func(header http.Header) </span><span class="cov8" title="1">{
                        header.Add("X-Influxdb-Build", "OSS")
                        header.Add("X-Influxdb-Version", influxdb.GetBuildInfo().Version)
                }</span>,
        }
        <span class="cov8" title="1">r.Use(buildHeader.Middleware)
        // only gather metrics for system handlers
        r.Group(func(r chi.Router) </span><span class="cov8" title="1">{
                r.Use(
                        kithttp.Metrics(name, h.requests, h.requestDur),
                )
                r.Mount(MetricsPath, opt.metricsHTTPHandler())
                r.Mount(ReadyPath, opt.readyHandler)
                r.Mount(HealthPath, opt.healthHandler)
                r.Mount(DebugPath, pprof.NewHTTPHandler(opt.pprofEnabled))
        }</span>)

        // gather metrics and traces for everything else
        <span class="cov8" title="1">r.Group(func(r chi.Router) </span><span class="cov8" title="1">{
                r.Use(
                        kithttp.Trace(name),
                        kithttp.Metrics(name, h.requests, h.requestDur),
                )
                r.Mount("/", opt.apiHandler)
        }</span>)

        <span class="cov8" title="1">h.r = r

        if opt.metricsRegistry != nil </span><span class="cov8" title="1">{
                opt.metricsRegistry.MustRegister(h.PrometheusCollectors()...)
        }</span>
        <span class="cov8" title="1">return h</span>
}

// ServeHTTP delegates a request to the appropriate subhandler.
func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        h.r.ServeHTTP(w, r)
}</span>

// PrometheusCollectors satisfies prom.PrometheusCollector.
func (h *Handler) PrometheusCollectors() []prometheus.Collector <span class="cov8" title="1">{
        return []prometheus.Collector{
                h.requests,
                h.requestDur,
        }
}</span>

func (h *Handler) initMetrics() <span class="cov8" title="1">{
        const namespace = "http"
        const handlerSubsystem = "api"

        labelNames := []string{"handler", "method", "path", "status", "user_agent", "response_code"}
        h.requests = prometheus.NewCounterVec(prometheus.CounterOpts{
                Namespace: namespace,
                Subsystem: handlerSubsystem,
                Name:      "requests_total",
                Help:      "Number of http requests received",
        }, labelNames)

        h.requestDur = prometheus.NewHistogramVec(prometheus.HistogramOpts{
                Namespace: namespace,
                Subsystem: handlerSubsystem,
                Name:      "request_duration_seconds",
                Help:      "Time taken to respond to HTTP request",
        }, labelNames)
}</span>

func encodeResponse(ctx context.Context, w http.ResponseWriter, code int, res interface{}) error <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(code)

        return json.NewEncoder(w).Encode(res)
}</span>

func logEncodingError(log *zap.Logger, r *http.Request, err error) <span class="cov8" title="1">{
        // If we encounter an error while encoding the response to an http request
        // the best thing we can do is log that error, as we may have already written
        // the headers for the http request in question.
        log.Error("Error encoding response",
                zap.String("path", r.URL.Path),
                zap.String("method", r.Method),
                zap.Error(err))
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package http

import (
        "fmt"
        "net/http"

        platform "github.com/influxdata/influxdb/v2"
)

// HealthHandler returns the status of the process.
func HealthHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        msg := fmt.Sprintf(`{"name":"influxdb", "message":"ready for queries and writes", "status":"pass", "checks":[], "version": %q, "commit": %q}`, platform.GetBuildInfo().Version, platform.GetBuildInfo().Commit)
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.WriteHeader(http.StatusOK)
        fmt.Fprintln(w, msg)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package http

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "path"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/pkg/httpc"
        "go.uber.org/zap"
)

// LabelHandler represents an HTTP API handler for labels
type LabelHandler struct {
        *httprouter.Router
        errors.HTTPErrorHandler
        log *zap.Logger

        LabelService influxdb.LabelService
}

const (
        prefixLabels = "/api/v2/labels"
        labelsIDPath = "/api/v2/labels/:id"
)

// NewLabelHandler returns a new instance of LabelHandler
func NewLabelHandler(log *zap.Logger, s influxdb.LabelService, he errors.HTTPErrorHandler) *LabelHandler <span class="cov8" title="1">{
        h := &amp;LabelHandler{
                Router:           NewRouter(he),
                HTTPErrorHandler: he,
                log:              log,
                LabelService:     s,
        }

        h.HandlerFunc("POST", prefixLabels, h.handlePostLabel)
        h.HandlerFunc("GET", prefixLabels, h.handleGetLabels)

        h.HandlerFunc("GET", labelsIDPath, h.handleGetLabel)
        h.HandlerFunc("PATCH", labelsIDPath, h.handlePatchLabel)
        h.HandlerFunc("DELETE", labelsIDPath, h.handleDeleteLabel)

        return h
}</span>

func (h *LabelHandler) Prefix() string <span class="cov0" title="0">{
        return prefixLabels
}</span>

// handlePostLabel is the HTTP handler for the POST /api/v2/labels route.
func (h *LabelHandler) handlePostLabel(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodePostLabelRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := h.LabelService.CreateLabel(ctx, req.Label); err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Label created", zap.String("label", fmt.Sprint(req.Label)))
        if err := encodeResponse(ctx, w, http.StatusCreated, newLabelResponse(req.Label)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type postLabelRequest struct {
        Label *influxdb.Label
}

func (b postLabelRequest) Validate() error <span class="cov8" title="1">{
        if b.Label.Name == "" </span><span class="cov0" title="0">{
                return &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "label requires a name",
                }
        }</span>
        <span class="cov8" title="1">if !b.Label.OrgID.Valid() </span><span class="cov0" title="0">{
                return &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "label requires a valid orgID",
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// TODO(jm): ensure that the specified org actually exists
func decodePostLabelRequest(ctx context.Context, r *http.Request) (*postLabelRequest, error) <span class="cov8" title="1">{
        l := &amp;influxdb.Label{}
        if err := json.NewDecoder(r.Body).Decode(l); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "unable to decode label request",
                        Err:  err,
                }
        }</span>

        <span class="cov8" title="1">req := &amp;postLabelRequest{
                Label: l,
        }

        return req, req.Validate()</span>
}

// handleGetLabels is the HTTP handler for the GET /api/v2/labels route.
func (h *LabelHandler) handleGetLabels(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeGetLabelsRequest(r.URL.Query())
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">labels, err := h.LabelService.FindLabels(ctx, req.filter)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Labels retrieved", zap.String("labels", fmt.Sprint(labels)))
        err = encodeResponse(ctx, w, http.StatusOK, newLabelsResponse(labels))
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
}

type getLabelsRequest struct {
        filter influxdb.LabelFilter
}

func decodeGetLabelsRequest(qp url.Values) (*getLabelsRequest, error) <span class="cov8" title="1">{
        req := &amp;getLabelsRequest{
                filter: influxdb.LabelFilter{
                        Name: qp.Get("name"),
                },
        }

        if orgID := qp.Get("orgID"); orgID != "" </span><span class="cov8" title="1">{
                id, err := platform.IDFromString(orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">req.filter.OrgID = id</span>
        }

        <span class="cov8" title="1">return req, nil</span>
}

// handleGetLabel is the HTTP handler for the GET /api/v2/labels/id route.
func (h *LabelHandler) handleGetLabel(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeGetLabelRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">l, err := h.LabelService.FindLabelByID(ctx, req.LabelID)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Label retrieved", zap.String("label", fmt.Sprint(l)))
        if err := encodeResponse(ctx, w, http.StatusOK, newLabelResponse(l)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type getLabelRequest struct {
        LabelID platform.ID
}

func decodeGetLabelRequest(ctx context.Context, r *http.Request) (*getLabelRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "label id is not valid",
                }
        }</span>

        <span class="cov8" title="1">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req := &amp;getLabelRequest{
                LabelID: i,
        }

        return req, nil</span>
}

// handleDeleteLabel is the HTTP handler for the DELETE /api/v2/labels/:id route.
func (h *LabelHandler) handleDeleteLabel(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeDeleteLabelRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := h.LabelService.DeleteLabel(ctx, req.LabelID); err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Label deleted", zap.String("labelID", fmt.Sprint(req.LabelID)))
        w.WriteHeader(http.StatusNoContent)</span>
}

type deleteLabelRequest struct {
        LabelID platform.ID
}

func decodeDeleteLabelRequest(ctx context.Context, r *http.Request) (*deleteLabelRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req := &amp;deleteLabelRequest{
                LabelID: i,
        }

        return req, nil</span>
}

// handlePatchLabel is the HTTP handler for the PATCH /api/v2/labels route.
func (h *LabelHandler) handlePatchLabel(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodePatchLabelRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">l, err := h.LabelService.UpdateLabel(ctx, req.LabelID, req.Update)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Label updated", zap.String("label", fmt.Sprint(l)))
        if err := encodeResponse(ctx, w, http.StatusOK, newLabelResponse(l)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type patchLabelRequest struct {
        Update  influxdb.LabelUpdate
        LabelID platform.ID
}

func decodePatchLabelRequest(ctx context.Context, r *http.Request) (*patchLabelRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">upd := &amp;influxdb.LabelUpdate{}
        if err := json.NewDecoder(r.Body).Decode(upd); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;patchLabelRequest{
                Update:  *upd,
                LabelID: i,
        }, nil</span>
}

type labelResponse struct {
        Links map[string]string `json:"links"`
        Label influxdb.Label    `json:"label"`
}

func newLabelResponse(l *influxdb.Label) *labelResponse <span class="cov8" title="1">{
        return &amp;labelResponse{
                Links: map[string]string{
                        "self": fmt.Sprintf("/api/v2/labels/%s", l.ID),
                },
                Label: *l,
        }
}</span>

type labelsResponse struct {
        Links  map[string]string `json:"links"`
        Labels []*influxdb.Label `json:"labels"`
}

func newLabelsResponse(ls []*influxdb.Label) *labelsResponse <span class="cov8" title="1">{
        return &amp;labelsResponse{
                Links: map[string]string{
                        "self": "/api/v2/labels",
                },
                Labels: ls,
        }
}</span>

// LabelBackend is all services and associated parameters required to construct
// label handlers.
type LabelBackend struct {
        log *zap.Logger
        errors.HTTPErrorHandler
        LabelService influxdb.LabelService
        ResourceType influxdb.ResourceType
}

// newGetLabelsHandler returns a handler func for a GET to /labels endpoints
func newGetLabelsHandler(b *LabelBackend) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                req, err := decodeGetLabelMappingsRequest(ctx, b.ResourceType)
                if err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov0" title="0">labels, err := b.LabelService.FindResourceLabels(ctx, req.filter)
                if err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov0" title="0">if err := encodeResponse(ctx, w, http.StatusOK, newLabelsResponse(labels)); err != nil </span><span class="cov0" title="0">{
                        logEncodingError(b.log, r, err)
                        return
                }</span>
        }
}

type getLabelMappingsRequest struct {
        filter influxdb.LabelMappingFilter
}

func decodeGetLabelMappingsRequest(ctx context.Context, rt influxdb.ResourceType) (*getLabelMappingsRequest, error) <span class="cov0" title="0">{
        req := &amp;getLabelMappingsRequest{}

        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov0" title="0">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.filter.ResourceID = i
        req.filter.ResourceType = rt

        return req, nil</span>
}

// newPostLabelHandler returns a handler func for a POST to /labels endpoints
func newPostLabelHandler(b *LabelBackend) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ctx := r.Context()

                req, err := decodePostLabelMappingRequest(ctx, r, b.ResourceType)
                if err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov8" title="1">if err := req.Mapping.Validate(); err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov8" title="1">if err := b.LabelService.CreateLabelMapping(ctx, &amp;req.Mapping); err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov8" title="1">label, err := b.LabelService.FindLabelByID(ctx, req.Mapping.LabelID)
                if err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusCreated, newLabelResponse(label)); err != nil </span><span class="cov0" title="0">{
                        logEncodingError(b.log, r, err)
                        return
                }</span>
        }
}

type postLabelMappingRequest struct {
        Mapping influxdb.LabelMapping
}

func decodePostLabelMappingRequest(ctx context.Context, r *http.Request, rt influxdb.ResourceType) (*postLabelMappingRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">var rid platform.ID
        if err := rid.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">mapping := &amp;influxdb.LabelMapping{}
        if err := json.NewDecoder(r.Body).Decode(mapping); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "Invalid post label map request",
                }
        }</span>

        <span class="cov8" title="1">mapping.ResourceID = rid
        mapping.ResourceType = rt

        if err := mapping.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req := &amp;postLabelMappingRequest{
                Mapping: *mapping,
        }

        return req, nil</span>
}

// newDeleteLabelHandler returns a handler func for a DELETE to /labels endpoints
func newDeleteLabelHandler(b *LabelBackend) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()

                req, err := decodeDeleteLabelMappingRequest(ctx, r)
                if err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov0" title="0">mapping := &amp;influxdb.LabelMapping{
                        LabelID:      req.LabelID,
                        ResourceID:   req.ResourceID,
                        ResourceType: b.ResourceType,
                }

                if err := b.LabelService.DeleteLabelMapping(ctx, mapping); err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov0" title="0">w.WriteHeader(http.StatusNoContent)</span>
        }
}

type deleteLabelMappingRequest struct {
        ResourceID platform.ID
        LabelID    platform.ID
}

func decodeDeleteLabelMappingRequest(ctx context.Context, r *http.Request) (*deleteLabelMappingRequest, error) <span class="cov0" title="0">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing resource id",
                }
        }</span>

        <span class="cov0" title="0">var rid platform.ID
        if err := rid.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">id = params.ByName("lid")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "label id is missing",
                }
        }</span>

        <span class="cov0" title="0">var lid platform.ID
        if err := lid.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;deleteLabelMappingRequest{
                LabelID:    lid,
                ResourceID: rid,
        }, nil</span>
}

func labelIDPath(id platform.ID) string <span class="cov8" title="1">{
        return path.Join(prefixLabels, id.String())
}</span>

// LabelService connects to Influx via HTTP using tokens to manage labels
type LabelService struct {
        Client   *httpc.Client
        OpPrefix string
}

// FindLabelByID returns a single label by ID.
func (s *LabelService) FindLabelByID(ctx context.Context, id platform.ID) (*influxdb.Label, error) <span class="cov8" title="1">{
        var lr labelResponse
        err := s.Client.
                Get(labelIDPath(id)).
                DecodeJSON(&amp;lr).
                Do(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;lr.Label, nil</span>
}

// FindLabels is a client for the find labels response from the server.
func (s *LabelService) FindLabels(ctx context.Context, filter influxdb.LabelFilter, opt ...influxdb.FindOptions) ([]*influxdb.Label, error) <span class="cov8" title="1">{
        params := influxdb.FindOptionParams(opt...)
        if filter.OrgID != nil </span><span class="cov8" title="1">{
                params = append(params, [2]string{"orgID", filter.OrgID.String()})
        }</span>
        <span class="cov8" title="1">if filter.Name != "" </span><span class="cov8" title="1">{
                params = append(params, [2]string{"name", filter.Name})
        }</span>

        <span class="cov8" title="1">var lr labelsResponse
        err := s.Client.
                Get(prefixLabels).
                QueryParams(params...).
                DecodeJSON(&amp;lr).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return lr.Labels, nil</span>
}

// FindResourceLabels returns a list of labels, derived from a label mapping filter.
func (s *LabelService) FindResourceLabels(ctx context.Context, filter influxdb.LabelMappingFilter) ([]*influxdb.Label, error) <span class="cov0" title="0">{
        if err := filter.Valid(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var r labelsResponse
        err := s.Client.
                Get(resourceIDPath(filter.ResourceType, filter.ResourceID, "labels")).
                DecodeJSON(&amp;r).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.Labels, nil</span>
}

// CreateLabel creates a new label.
func (s *LabelService) CreateLabel(ctx context.Context, l *influxdb.Label) error <span class="cov8" title="1">{
        var lr labelResponse
        err := s.Client.
                PostJSON(l, prefixLabels).
                DecodeJSON(&amp;lr).
                Do(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // this is super dirty &gt;_&lt;
        <span class="cov8" title="1">*l = lr.Label
        return nil</span>
}

// UpdateLabel updates a label and returns the updated label.
func (s *LabelService) UpdateLabel(ctx context.Context, id platform.ID, upd influxdb.LabelUpdate) (*influxdb.Label, error) <span class="cov8" title="1">{
        var lr labelResponse
        err := s.Client.
                PatchJSON(upd, labelIDPath(id)).
                DecodeJSON(&amp;lr).
                Do(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;lr.Label, nil</span>
}

// DeleteLabel removes a label by ID.
func (s *LabelService) DeleteLabel(ctx context.Context, id platform.ID) error <span class="cov8" title="1">{
        return s.Client.
                Delete(labelIDPath(id)).
                Do(ctx)
}</span>

// CreateLabelMapping will create a labbel mapping
func (s *LabelService) CreateLabelMapping(ctx context.Context, m *influxdb.LabelMapping) error <span class="cov0" title="0">{
        if err := m.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">urlPath := resourceIDPath(m.ResourceType, m.ResourceID, "labels")
        return s.Client.
                PostJSON(m, urlPath).
                DecodeJSON(m).
                Do(ctx)</span>
}

func (s *LabelService) DeleteLabelMapping(ctx context.Context, m *influxdb.LabelMapping) error <span class="cov0" title="0">{
        if err := m.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.Client.
                Delete(resourceIDMappingPath(m.ResourceType, m.ResourceID, "labels", m.LabelID)).
                Do(ctx)</span>
}

func resourceIDMappingPath(resourceType influxdb.ResourceType, resourceID platform.ID, p string, labelID platform.ID) string <span class="cov0" title="0">{
        return path.Join("/api/v2/", string(resourceType), resourceID.String(), p, labelID.String())
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package http

import (
        "github.com/influxdata/influxdb/v2/http/legacy"
)

// newLegacyBackend constructs a legacy backend from an api backend.
func newLegacyBackend(b *APIBackend) *legacy.Backend <span class="cov0" title="0">{
        return &amp;legacy.Backend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                Logger:           b.Logger,
                // TODO(sgc): /write support
                //MaxBatchSizeBytes:     b.APIBackend.MaxBatchSizeBytes,
                AuthorizationService:  b.AuthorizationService,
                OrganizationService:   b.OrganizationService,
                BucketService:         b.BucketService,
                PointsWriter:          b.PointsWriter,
                DBRPMappingService:    b.DBRPService,
                ProxyQueryService:     b.InfluxQLService,
                InfluxqldQueryService: b.InfluxqldService,
                WriteEventRecorder:    b.WriteEventRecorder,
        }
}</span>

// newLegacyHandler constructs a legacy handler from a backend.
func newLegacyHandler(b *legacy.Backend, config legacy.HandlerConfig) *legacy.Handler <span class="cov0" title="0">{
        h := &amp;legacy.Handler{
                HTTPErrorHandler: b.HTTPErrorHandler,
        }

        pointsWriterBackend := legacy.NewPointsWriterBackend(b)
        h.PointsWriterHandler = legacy.NewWriterHandler(pointsWriterBackend, legacy.WithMaxBatchSizeBytes(b.MaxBatchSizeBytes))

        influxqlBackend := legacy.NewInfluxQLBackend(b)
        h.InfluxQLHandler = legacy.NewInfluxQLHandler(influxqlBackend, config)

        h.PingHandler = legacy.NewPingHandler()
        return h
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package legacy

import (
        http2 "net/http"

        "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/http/metric"
        "github.com/influxdata/influxdb/v2/influxql"
        "github.com/influxdata/influxdb/v2/kit/cli"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/query"
        "github.com/influxdata/influxdb/v2/storage"
        "github.com/prometheus/client_golang/prometheus"
        "go.uber.org/zap"
)

// Handler is a collection of all the service handlers.
type Handler struct {
        errors.HTTPErrorHandler
        PointsWriterHandler *WriteHandler
        PingHandler         *PingHandler
        InfluxQLHandler     *InfluxqlHandler
}

type Backend struct {
        errors.HTTPErrorHandler
        Logger            *zap.Logger
        MaxBatchSizeBytes int64

        WriteEventRecorder    metric.EventRecorder
        AuthorizationService  influxdb.AuthorizationService
        OrganizationService   influxdb.OrganizationService
        BucketService         influxdb.BucketService
        PointsWriter          storage.PointsWriter
        DBRPMappingService    influxdb.DBRPMappingService
        ProxyQueryService     query.ProxyQueryService
        InfluxqldQueryService influxql.ProxyQueryService
}

// HandlerConfig provides configuration for the legacy handler.
type HandlerConfig struct {
        DefaultRoutingKey string
}

func NewHandlerConfig() *HandlerConfig <span class="cov8" title="1">{
        return &amp;HandlerConfig{}
}</span>

// Opts returns the CLI options for use with kit/cli.
// Currently set values on c are provided as the defaults.
func (c *HandlerConfig) Opts() []cli.Opt <span class="cov0" title="0">{
        return []cli.Opt{
                {
                        DestP:   &amp;c.DefaultRoutingKey,
                        Flag:    "influxql-default-routing-key",
                        Default: "defaultQueue",
                        Desc:    "Default routing key for publishing new query requests",
                },
        }
}</span>

func (h *Handler) ServeHTTP(w http2.ResponseWriter, r *http2.Request) <span class="cov0" title="0">{
        if r.URL.Path == "/write" </span><span class="cov0" title="0">{
                h.PointsWriterHandler.ServeHTTP(w, r)
                return
        }</span>

        <span class="cov0" title="0">if r.URL.Path == "/ping" </span><span class="cov0" title="0">{
                h.PingHandler.ServeHTTP(w, r)
                return
        }</span>

        <span class="cov0" title="0">if r.URL.Path == "/query" </span><span class="cov0" title="0">{
                h.InfluxQLHandler.ServeHTTP(w, r)
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http2.StatusNotFound)</span>
}

func (h *Handler) PrometheusCollectors() []prometheus.Collector <span class="cov0" title="0">{
        return h.InfluxQLHandler.PrometheusCollectors()
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package legacy

import (
        "context"

        "github.com/influxdata/influxdb/v2"
        pcontext "github.com/influxdata/influxdb/v2/context"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
)

// getAuthorization extracts authorization information from a context.Context.
// It guards against non influxdb.Authorization values for authorization and
// InfluxQL feature flag not enabled.
func getAuthorization(ctx context.Context) (*influxdb.Authorization, error) <span class="cov8" title="1">{
        authorizer, err := pcontext.GetAuthorizer(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">a, ok := authorizer.(*influxdb.Authorization)
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EForbidden,
                        Msg:  "insufficient permissions; session not supported",
                }
        }</span>
        <span class="cov8" title="1">return a, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package legacy

import (
        "context"
        "errors"
        "fmt"
        "net/http"
        "strings"

        "github.com/influxdata/influxdb/v2"
        platcontext "github.com/influxdata/influxdb/v2/context"
        errors2 "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/opentracing/opentracing-go"
)

type Authorizer interface {
        Authorize(ctx context.Context, c influxdb.CredentialsV1) (*influxdb.Authorization, error)
}

type Influx1xAuthenticationHandler struct {
        errors2.HTTPErrorHandler
        next http.Handler
        auth Authorizer
}

// NewInflux1xAuthenticationHandler creates an authentication handler to process
// InfluxDB 1.x authentication requests.
func NewInflux1xAuthenticationHandler(next http.Handler, auth Authorizer, h errors2.HTTPErrorHandler) *Influx1xAuthenticationHandler <span class="cov8" title="1">{
        return &amp;Influx1xAuthenticationHandler{
                HTTPErrorHandler: h,
                next:             next,
                auth:             auth,
        }
}</span>

// ServeHTTP extracts the session or token from the http request and places the resulting authorizer on the request context.
func (h *Influx1xAuthenticationHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // The ping endpoint does not need authorization
        if r.URL.Path == "/ping" </span><span class="cov0" title="0">{
                h.next.ServeHTTP(w, r)
                return
        }</span>
        <span class="cov8" title="1">ctx := r.Context()

        creds, err := h.parseCredentials(r)
        if err != nil </span><span class="cov8" title="1">{
                unauthorizedError(ctx, h, w)
                return
        }</span>

        <span class="cov8" title="1">auth, err := h.auth.Authorize(ctx, creds)
        if err != nil </span><span class="cov8" title="1">{
                var erri *errors2.Error
                if errors.As(err, &amp;erri) </span><span class="cov8" title="1">{
                        switch erri.Code </span>{
                        case errors2.EForbidden, errors2.EUnauthorized:<span class="cov8" title="1">
                                h.HandleHTTPError(ctx, erri, w)
                                return</span>
                        }
                }
                <span class="cov8" title="1">unauthorizedError(ctx, h, w)
                return</span>
        }

        <span class="cov8" title="1">ctx = platcontext.SetAuthorizer(ctx, auth)

        if span := opentracing.SpanFromContext(ctx); span != nil </span><span class="cov0" title="0">{
                span.SetTag("user_id", auth.GetUserID().String())
        }</span>

        <span class="cov8" title="1">h.next.ServeHTTP(w, r.WithContext(ctx))</span>
}

func parseToken(token string) (user, pass string, ok bool) <span class="cov8" title="1">{
        s := strings.IndexByte(token, ':')
        if s &lt; 0 </span><span class="cov8" title="1">{
                // Token &lt;token&gt;
                return "", token, true
        }</span>

        // Token &lt;username&gt;:&lt;token&gt;
        <span class="cov8" title="1">return token[:s], token[s+1:], true</span>
}

// parseCredentials parses a request and returns the authentication credentials.
// The credentials may be present as URL query params, or as a Basic
// Authentication header.
// As params: http://127.0.0.1/query?u=username&amp;p=token
// As basic auth: http://username:token@127.0.0.1
// As Token in Authorization header: Token &lt;username:token&gt;
func (h *Influx1xAuthenticationHandler) parseCredentials(r *http.Request) (influxdb.CredentialsV1, error) <span class="cov8" title="1">{
        q := r.URL.Query()

        // Check for username and password in URL params.
        if u, p := q.Get("u"), q.Get("p"); u != "" &amp;&amp; p != "" </span><span class="cov8" title="1">{
                return influxdb.CredentialsV1{
                        Scheme:   influxdb.SchemeV1URL,
                        Username: u,
                        Token:    p,
                }, nil
        }</span>

        // Check for the HTTP Authorization header.
        <span class="cov8" title="1">if s := r.Header.Get("Authorization"); s != "" </span><span class="cov8" title="1">{
                // Check for Bearer token.
                strs := strings.Split(s, " ")
                if len(strs) == 2 </span><span class="cov8" title="1">{
                        switch strs[0] </span>{
                        case "Token":<span class="cov8" title="1">
                                if u, p, ok := parseToken(strs[1]); ok </span><span class="cov8" title="1">{
                                        return influxdb.CredentialsV1{
                                                Scheme:   influxdb.SchemeV1Token,
                                                Username: u,
                                                Token:    p,
                                        }, nil
                                }</span>

                                // fallback to only a token
                        }
                }

                // Check for basic auth.
                <span class="cov8" title="1">if u, p, ok := r.BasicAuth(); ok </span><span class="cov8" title="1">{
                        return influxdb.CredentialsV1{
                                Scheme:   influxdb.SchemeV1Basic,
                                Username: u,
                                Token:    p,
                        }, nil
                }</span>
        }

        <span class="cov8" title="1">return influxdb.CredentialsV1{}, fmt.Errorf("unable to parse authentication credentials")</span>
}

// unauthorizedError encodes a error message and status code for unauthorized access.
func unauthorizedError(ctx context.Context, h errors2.HTTPErrorHandler, w http.ResponseWriter) <span class="cov8" title="1">{
        h.HandleHTTPError(ctx, &amp;errors2.Error{
                Code: errors2.EUnauthorized,
                Msg:  "unauthorized access",
        }, w)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package legacy

import (
        "net/http"

        platform "github.com/influxdata/influxdb/v2"
        influxqld "github.com/influxdata/influxdb/v2/influxql"
        "github.com/influxdata/influxdb/v2/influxql/control"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/query"
        "go.uber.org/zap"
)

// InfluxqlHandler mimics the /query handler from influxdb, but, enriches
// with org and forwards requests to the transpiler service.
type InfluxqlHandler struct {
        *InfluxQLBackend
        HandlerConfig
        Metrics *control.ControllerMetrics
}

type InfluxQLBackend struct {
        errors.HTTPErrorHandler
        Logger                *zap.Logger
        AuthorizationService  platform.AuthorizationService
        OrganizationService   platform.OrganizationService
        ProxyQueryService     query.ProxyQueryService
        InfluxqldQueryService influxqld.ProxyQueryService
}

// NewInfluxQLBackend constructs an InfluxQLBackend from a LegacyBackend.
func NewInfluxQLBackend(b *Backend) *InfluxQLBackend <span class="cov0" title="0">{
        return &amp;InfluxQLBackend{
                HTTPErrorHandler:      b.HTTPErrorHandler,
                Logger:                b.Logger.With(zap.String("handler", "influxql")),
                AuthorizationService:  b.AuthorizationService,
                OrganizationService:   b.OrganizationService,
                InfluxqldQueryService: b.InfluxqldQueryService,
        }
}</span>

// NewInfluxQLHandler returns a new instance of InfluxqlHandler to handle influxql v1 queries
func NewInfluxQLHandler(b *InfluxQLBackend, config HandlerConfig) *InfluxqlHandler <span class="cov8" title="1">{
        return &amp;InfluxqlHandler{
                InfluxQLBackend: b,
                HandlerConfig:   config,
                Metrics:         control.NewControllerMetrics([]string{}),
        }
}</span>

func (h *InfluxqlHandler) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        h.handleInfluxqldQuery(w, req)
}</span>

// DefaultChunkSize is the default number of points to write in
// one chunk.
const DefaultChunkSize = 10000
</pre>
		
		<pre class="file" id="file20" style="display: none">package legacy

import (
        "encoding/json"
        "io/ioutil"
        "mime"
        "net/http"
        "strconv"
        "strings"

        "github.com/influxdata/flux/iocounter"
        "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/influxql"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/kit/tracing"
        "github.com/prometheus/client_golang/prometheus"
        "go.uber.org/zap"
)

const (
        traceIDHeader = "Trace-Id"
)

func (h *InfluxqlHandler) PrometheusCollectors() []prometheus.Collector <span class="cov0" title="0">{
        return []prometheus.Collector{
                h.Metrics.Requests,
                h.Metrics.RequestsLatency,
        }
}</span>

// HandleQuery mimics the influxdb 1.0 /query
func (h *InfluxqlHandler) handleInfluxqldQuery(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        span, r := tracing.ExtractFromHTTPRequest(r, "handleInfluxqldQuery")
        defer span.Finish()

        if id, _, found := tracing.InfoFromSpan(span); found </span><span class="cov0" title="0">{
                w.Header().Set(traceIDHeader, id)
        }</span>

        <span class="cov8" title="1">ctx := r.Context()
        defer r.Body.Close()

        auth, err := getAuthorization(ctx)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if !auth.IsActive() </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, &amp;errors.Error{
                        Code: errors.EForbidden,
                        Msg:  "insufficient permissions",
                }, w)
                return
        }</span>

        <span class="cov8" title="1">o, err := h.OrganizationService.FindOrganization(ctx, influxdb.OrganizationFilter{
                ID: &amp;auth.OrgID,
        })
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">var query string
        // Attempt to read the form value from the "q" form value.
        if qp := strings.TrimSpace(r.FormValue("q")); qp != "" </span><span class="cov0" title="0">{
                query = qp
        }</span> else<span class="cov8" title="1"> if r.MultipartForm != nil &amp;&amp; r.MultipartForm.File != nil </span><span class="cov0" title="0">{
                // If we have a multipart/form-data, try to retrieve a file from 'q'.
                if fhs := r.MultipartForm.File["q"]; len(fhs) &gt; 0 </span><span class="cov0" title="0">{
                        d, err := ioutil.ReadFile(fhs[0].Filename)
                        if err != nil </span><span class="cov0" title="0">{
                                h.HandleHTTPError(ctx, err, w)
                                return
                        }</span>
                        <span class="cov0" title="0">query = string(d)</span>
                }
        } else<span class="cov8" title="1"> {
                ct := r.Header.Get("Content-Type")
                mt, _, err := mime.ParseMediaType(ct)
                if err != nil </span><span class="cov0" title="0">{
                        h.HandleHTTPError(ctx, &amp;errors.Error{
                                Code: errors.EInvalid,
                                Err:  err,
                        }, w)
                        return
                }</span>

                <span class="cov8" title="1">if mt == "application/vnd.influxql" </span><span class="cov8" title="1">{
                        if d, err := ioutil.ReadAll(r.Body); err != nil </span><span class="cov0" title="0">{
                                h.HandleHTTPError(ctx, err, w)
                                return
                        }</span> else<span class="cov8" title="1"> {
                                query = string(d)
                        }</span>
                }
        }

        // parse the parameters
        <span class="cov8" title="1">rawParams := r.FormValue("params")
        var params map[string]interface{}
        if rawParams != "" </span><span class="cov0" title="0">{
                decoder := json.NewDecoder(strings.NewReader(rawParams))
                decoder.UseNumber()
                if err := decoder.Decode(&amp;params); err != nil </span><span class="cov0" title="0">{
                        h.HandleHTTPError(ctx, &amp;errors.Error{
                                Code: errors.EInvalid,
                                Msg:  "error parsing query parameters",
                                Err:  err,
                        }, w)
                        return
                }</span>

                // Convert json.Number into int64 and float64 values
                <span class="cov0" title="0">for k, v := range params </span><span class="cov0" title="0">{
                        if v, ok := v.(json.Number); ok </span><span class="cov0" title="0">{
                                var err error
                                if strings.Contains(string(v), ".") </span><span class="cov0" title="0">{
                                        params[k], err = v.Float64()
                                }</span> else<span class="cov0" title="0"> {
                                        params[k], err = v.Int64()
                                }</span>

                                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                        h.HandleHTTPError(ctx, &amp;errors.Error{
                                                Code: errors.EInvalid,
                                                Msg:  "error parsing json value",
                                                Err:  err,
                                        }, w)
                                        return
                                }</span>
                        }
                }
        }

        // Parse chunk size. Use default if not provided or cannot be parsed
        <span class="cov8" title="1">chunked := r.FormValue("chunked") == "true"
        chunkSize := DefaultChunkSize
        if chunked </span><span class="cov0" title="0">{
                if n, err := strconv.ParseInt(r.FormValue("chunk_size"), 10, 64); err == nil &amp;&amp; int(n) &gt; 0 </span><span class="cov0" title="0">{
                        chunkSize = int(n)
                }</span>
        }

        <span class="cov8" title="1">formatString := r.Header.Get("Accept")
        encodingFormat := influxql.EncodingFormatFromMimeType(formatString)
        w.Header().Set("Content-Type", encodingFormat.ContentType())

        req := &amp;influxql.QueryRequest{
                DB:             r.FormValue("db"),
                RP:             r.FormValue("rp"),
                Epoch:          r.FormValue("epoch"),
                EncodingFormat: encodingFormat,
                OrganizationID: o.ID,
                Query:          query,
                Params:         params,
                Source:         r.Header.Get("User-Agent"),
                Authorization:  auth,
                Chunked:        chunked,
                ChunkSize:      chunkSize,
        }

        var respSize int64
        cw := iocounter.Writer{Writer: w}
        _, err = h.InfluxqldQueryService.Query(ctx, &amp;cw, req)
        respSize = cw.Count()

        if err != nil </span><span class="cov8" title="1">{
                if respSize == 0 </span><span class="cov8" title="1">{
                        // Only record the error headers IFF nothing has been written to w.
                        h.HandleHTTPError(ctx, err, w)
                        return
                }</span>
                <span class="cov8" title="1">h.Logger.Info("error writing response to client",
                        zap.String("org", o.Name),
                        zap.String("handler", "influxql"),
                        zap.Error(err),
                )</span>
        }
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package legacy

import (
        "net/http"

        "github.com/influxdata/httprouter"
)

type PingHandler struct {
        *httprouter.Router
}

func NewPingHandler() *PingHandler <span class="cov8" title="1">{
        h := &amp;PingHandler{
                Router: httprouter.New(),
        }

        h.HandlerFunc("GET", "/ping", h.pingHandler)
        h.HandlerFunc("HEAD", "/ping", h.pingHandler)
        return h
}</span>

// handlePostLegacyWrite is the HTTP handler for the POST /write route.
func (h *PingHandler) pingHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // X-Influxdb-Version and X-Influxdb-Build header are sets by buildHeader in http/handler.go
        w.WriteHeader(http.StatusNoContent)
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package legacy

import (
        "fmt"
        "net/http"
        "os"
        "runtime/debug"
        "sync"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        influxlogger "github.com/influxdata/influxdb/v2/logger"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// NewRouter returns a new router with a 404 handler, a 405 handler, and a panic handler.
func NewRouter(h errors.HTTPErrorHandler) *httprouter.Router <span class="cov8" title="1">{
        b := baseHandler{HTTPErrorHandler: h}
        router := httprouter.New()
        router.NotFound = http.HandlerFunc(b.notFound)
        router.MethodNotAllowed = http.HandlerFunc(b.methodNotAllowed)
        router.PanicHandler = b.panic
        router.AddMatchedRouteToContext = true
        return router
}</span>

type baseHandler struct {
        errors.HTTPErrorHandler
}

// notFound represents a 404 handler that return a JSON response.
func (h baseHandler) notFound(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        pe := &amp;errors.Error{
                Code: errors.ENotFound,
                Msg:  "path not found",
        }

        h.HandleHTTPError(ctx, pe, w)
}</span>

// methodNotAllowed represents a 405 handler that return a JSON response.
func (h baseHandler) methodNotAllowed(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        allow := w.Header().Get("Allow")
        pe := &amp;errors.Error{
                Code: errors.EMethodNotAllowed,
                Msg:  fmt.Sprintf("allow: %s", allow),
        }

        h.HandleHTTPError(ctx, pe, w)
}</span>

// panic handles panics recovered from http handlers.
// It returns a json response with http status code 500 and the recovered error message.
func (h baseHandler) panic(w http.ResponseWriter, r *http.Request, rcv interface{}) <span class="cov0" title="0">{
        ctx := r.Context()
        pe := &amp;errors.Error{
                Code: errors.EInternal,
                Msg:  "a panic has occurred",
                Err:  fmt.Errorf("%s: %v", r.URL.String(), rcv),
        }

        l := getPanicLogger()
        if entry := l.Check(zapcore.ErrorLevel, pe.Msg); entry != nil </span><span class="cov0" title="0">{
                entry.Stack = string(debug.Stack())
                entry.Write(zap.Error(pe.Err))
        }</span>

        <span class="cov0" title="0">h.HandleHTTPError(ctx, pe, w)</span>
}

var panicLogger = zap.NewNop()
var panicLoggerOnce sync.Once

// getPanicLogger returns a logger for panicHandler.
func getPanicLogger() *zap.Logger <span class="cov0" title="0">{
        panicLoggerOnce.Do(func() </span><span class="cov0" title="0">{
                conf := influxlogger.NewConfig()
                logger, err := conf.New(os.Stderr)
                if err == nil </span><span class="cov0" title="0">{
                        panicLogger = logger.With(zap.String("handler", "panic"))
                }</span>
        })

        <span class="cov0" title="0">return panicLogger</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package legacy

import (
        "context"
        "fmt"
        "io"
        "net/http"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/http/metric"
        "github.com/influxdata/influxdb/v2/http/points"
        "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/kit/tracing"
        kithttp "github.com/influxdata/influxdb/v2/kit/transport/http"
        "github.com/influxdata/influxdb/v2/storage"
        "github.com/influxdata/influxdb/v2/tsdb"
        "go.uber.org/zap"
)

var _ http.Handler = (*WriteHandler)(nil)

const (
        opWriteHandler = "http/v1WriteHandler"
)

// PointsWriterBackend contains all the services needed to run a PointsWriterHandler.
type PointsWriterBackend struct {
        errors.HTTPErrorHandler
        Logger *zap.Logger

        EventRecorder      metric.EventRecorder
        BucketService      influxdb.BucketService
        PointsWriter       storage.PointsWriter
        DBRPMappingService influxdb.DBRPMappingService
}

// NewPointsWriterBackend creates a new backend for legacy work.
func NewPointsWriterBackend(b *Backend) *PointsWriterBackend <span class="cov0" title="0">{
        return &amp;PointsWriterBackend{
                HTTPErrorHandler:   b.HTTPErrorHandler,
                Logger:             b.Logger.With(zap.String("handler", "points_writer")),
                EventRecorder:      b.WriteEventRecorder,
                BucketService:      b.BucketService,
                PointsWriter:       b.PointsWriter,
                DBRPMappingService: b.DBRPMappingService,
        }
}</span>

// PointsWriterHandler represents an HTTP API handler for writing points.
type WriteHandler struct {
        errors.HTTPErrorHandler
        EventRecorder      metric.EventRecorder
        BucketService      influxdb.BucketService
        PointsWriter       storage.PointsWriter
        DBRPMappingService influxdb.DBRPMappingService

        router            *httprouter.Router
        logger            *zap.Logger
        maxBatchSizeBytes int64
}

// NewWriterHandler returns a new instance of PointsWriterHandler.
func NewWriterHandler(b *PointsWriterBackend, opts ...WriteHandlerOption) *WriteHandler <span class="cov8" title="1">{
        h := &amp;WriteHandler{
                HTTPErrorHandler:   b.HTTPErrorHandler,
                EventRecorder:      b.EventRecorder,
                BucketService:      b.BucketService,
                PointsWriter:       b.PointsWriter,
                DBRPMappingService: b.DBRPMappingService,

                router: NewRouter(b.HTTPErrorHandler),
                logger: b.Logger.With(zap.String("handler", "points_writer")),
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(h)
        }</span>

        <span class="cov8" title="1">h.router.HandlerFunc(http.MethodPost, "/write", h.handleWrite)

        return h</span>
}

// WriteHandlerOption is a functional option for a *PointsWriterHandler
type WriteHandlerOption func(*WriteHandler)

// WithMaxBatchSizeBytes configures the maximum size for a
// (decompressed) points batch allowed by the write handler
func WithMaxBatchSizeBytes(n int64) WriteHandlerOption <span class="cov0" title="0">{
        return func(w *WriteHandler) </span><span class="cov0" title="0">{
                w.maxBatchSizeBytes = n
        }</span>
}

// ServeHTTP implements http.Handler
func (h *WriteHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        h.router.ServeHTTP(w, r)
}</span>

// handleWrite handles requests for the v1 write endpoint
func (h *WriteHandler) handleWrite(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        span, r := tracing.ExtractFromHTTPRequest(r, "WriteHandler")
        defer span.Finish()

        ctx := r.Context()
        auth, err := getAuthorization(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">sw := kithttp.NewStatusResponseWriter(w)
        recorder := newWriteUsageRecorder(sw, h.EventRecorder)
        var requestBytes int
        defer func() </span><span class="cov8" title="1">{
                // Close around the requestBytes variable to placate the linter.
                recorder.Record(ctx, requestBytes, auth.OrgID, r.URL.Path)
        }</span>()

        <span class="cov8" title="1">req, err := decodeWriteRequest(ctx, r, h.maxBatchSizeBytes)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, sw)
                return
        }</span>

        <span class="cov8" title="1">bucket, err := h.findBucket(ctx, auth.OrgID, req.Database, req.RetentionPolicy)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, sw)
                return
        }</span>
        <span class="cov8" title="1">span.LogKV("bucket_id", bucket.ID)

        if err := checkBucketWritePermissions(auth, bucket.OrgID, bucket.ID); err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, sw)
                return
        }</span>

        <span class="cov8" title="1">parsed, err := points.NewParser(req.Precision).Parse(ctx, auth.OrgID, bucket.ID, req.Body)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, sw)
                return
        }</span>

        <span class="cov8" title="1">if err := h.PointsWriter.WritePoints(ctx, auth.OrgID, bucket.ID, parsed.Points); err != nil </span><span class="cov8" title="1">{
                if partialErr, ok := err.(tsdb.PartialWriteError); ok </span><span class="cov8" title="1">{
                        h.HandleHTTPError(ctx, &amp;errors.Error{
                                Code: errors.EUnprocessableEntity,
                                Op:   opWriteHandler,
                                Msg:  "failure writing points to database",
                                Err:  partialErr,
                        }, sw)
                        return
                }</span>

                <span class="cov0" title="0">h.HandleHTTPError(ctx, &amp;errors.Error{
                        Code: errors.EInternal,
                        Op:   opWriteHandler,
                        Msg:  "unexpected error writing points to database",
                        Err:  err,
                }, sw)
                return</span>
        }

        <span class="cov8" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

// findBucket finds a bucket for the specified database and
// retention policy combination.
func (h *WriteHandler) findBucket(ctx context.Context, orgID platform.ID, db, rp string) (*influxdb.Bucket, error) <span class="cov8" title="1">{
        mapping, err := h.findMapping(ctx, orgID, db, rp)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return h.BucketService.FindBucketByID(ctx, mapping.BucketID)</span>
}

// checkBucketWritePermissions checks an Authorizer for write permissions to a
// specific Bucket.
func checkBucketWritePermissions(auth influxdb.Authorizer, orgID, bucketID platform.ID) error <span class="cov8" title="1">{
        p, err := influxdb.NewPermissionAtID(bucketID, influxdb.WriteAction, influxdb.BucketsResourceType, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;errors.Error{
                        Code: errors.EInternal,
                        Op:   opWriteHandler,
                        Msg:  fmt.Sprintf("unable to create permission for bucket: %v", err),
                        Err:  err,
                }
        }</span>
        <span class="cov8" title="1">if pset, err := auth.PermissionSet(); err != nil || !pset.Allowed(*p) </span><span class="cov8" title="1">{
                return &amp;errors.Error{
                        Code: errors.EForbidden,
                        Op:   opWriteHandler,
                        Msg:  "insufficient permissions for write",
                        Err:  err,
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// findMapping finds a DBRPMapping for the database and retention policy
// combination.
func (h *WriteHandler) findMapping(ctx context.Context, orgID platform.ID, db, rp string) (*influxdb.DBRPMapping, error) <span class="cov8" title="1">{
        filter := influxdb.DBRPMappingFilter{
                OrgID:    &amp;orgID,
                Database: &amp;db,
        }
        if rp != "" </span><span class="cov8" title="1">{
                filter.RetentionPolicy = &amp;rp
        }</span> else<span class="cov8" title="1"> {
                b := true // Can't get a direct pointer to `true`...
                filter.Default = &amp;b
        }</span>

        <span class="cov8" title="1">mappings, count, err := h.DBRPMappingService.FindMany(ctx, filter)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if count == 0 </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.ENotFound,
                        Msg:  "no dbrp mapping found",
                }
        }</span>
        <span class="cov8" title="1">return mappings[0], nil</span>
}

// writeRequest is a transport-agnostic write request. It holds all inputs for
// processing a v1 write request.
type writeRequest struct {
        OrganizationName string
        Database         string
        RetentionPolicy  string
        Precision        string
        Body             io.ReadCloser
}

// decodeWriteRequest extracts write request information from an inbound
// http.Request and returns a writeRequest.
func decodeWriteRequest(_ context.Context, r *http.Request, maxBatchSizeBytes int64) (*writeRequest, error) <span class="cov8" title="1">{
        qp := r.URL.Query()
        precision := qp.Get("precision")
        if precision == "" </span><span class="cov8" title="1">{
                precision = "ns"
        }</span>
        <span class="cov8" title="1">db := qp.Get("db")
        if db == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "missing db",
                }
        }</span>

        <span class="cov8" title="1">encoding := r.Header.Get("Content-Encoding")
        body, err := points.BatchReadCloser(r.Body, encoding, maxBatchSizeBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;writeRequest{
                OrganizationName: qp.Get("org"),
                Database:         db,
                RetentionPolicy:  qp.Get("rp"),
                Precision:        precision,
                Body:             body,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package legacy

import (
        "context"

        "github.com/influxdata/influxdb/v2/http/metric"
        "github.com/influxdata/influxdb/v2/kit/platform"
        kithttp "github.com/influxdata/influxdb/v2/kit/transport/http"
)

func newWriteUsageRecorder(w *kithttp.StatusResponseWriter, recorder metric.EventRecorder) *writeUsageRecorder <span class="cov8" title="1">{
        return &amp;writeUsageRecorder{
                Writer:        w,
                EventRecorder: recorder,
        }
}</span>

type writeUsageRecorder struct {
        Writer        *kithttp.StatusResponseWriter
        EventRecorder metric.EventRecorder
}

func (w *writeUsageRecorder) Record(ctx context.Context, requestBytes int, orgID platform.ID, endpoint string) <span class="cov8" title="1">{
        w.EventRecorder.Record(ctx, metric.Event{
                OrgID:         orgID,
                Endpoint:      endpoint,
                RequestBytes:  requestBytes,
                ResponseBytes: w.Writer.ResponseBytes(),
                Status:        w.Writer.Code(),
        })
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package http

import (
        "bytes"
        "errors"
        "io"
        "net/http"
        "path"
        "strings"
        "time"

        kithttp "github.com/influxdata/influxdb/v2/kit/transport/http"
        "go.uber.org/zap"
)

// LoggingMW middleware for logging inflight http requests.
func LoggingMW(log *zap.Logger) kithttp.Middleware <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        srw := kithttp.NewStatusResponseWriter(w)

                        var buf bytes.Buffer
                        r.Body = &amp;bodyEchoer{
                                rc:    r.Body,
                                teedR: io.TeeReader(r.Body, &amp;buf),
                        }

                        defer func(start time.Time) </span><span class="cov8" title="1">{
                                errField := zap.Skip()
                                if errStr := w.Header().Get(kithttp.PlatformErrorCodeHeader); errStr != "" </span><span class="cov0" title="0">{
                                        errField = zap.Error(errors.New(errStr))
                                }</span>

                                <span class="cov8" title="1">errReferenceField := zap.Skip()
                                if errReference := w.Header().Get(kithttp.PlatformErrorCodeHeader); errReference != "" </span><span class="cov0" title="0">{
                                        errReferenceField = zap.String("error_code", errReference)
                                }</span>

                                <span class="cov8" title="1">fields := []zap.Field{
                                        zap.String("method", r.Method),
                                        zap.String("host", r.Host),
                                        zap.String("path", r.URL.Path),
                                        zap.String("query", r.URL.Query().Encode()),
                                        zap.String("proto", r.Proto),
                                        zap.Int("status_code", srw.Code()),
                                        zap.Int("response_size", srw.ResponseBytes()),
                                        zap.Int64("content_length", r.ContentLength),
                                        zap.String("referrer", r.Referer()),
                                        zap.String("remote", r.RemoteAddr),
                                        zap.String("user_agent", kithttp.UserAgent(r)),
                                        zap.Duration("took", time.Since(start)),
                                        errField,
                                        errReferenceField,
                                }

                                invalidMethodFn, ok := mapURLPath(r.URL.Path)
                                if !ok || !invalidMethodFn(r.Method) </span><span class="cov8" title="1">{
                                        fields = append(fields, zap.ByteString("body", buf.Bytes()))
                                }</span>

                                <span class="cov8" title="1">log.Debug("Request", fields...)</span>
                        }(time.Now())

                        <span class="cov8" title="1">next.ServeHTTP(srw, r)</span>
                }
                <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
        }
}

type isValidMethodFn func(method string) bool

func mapURLPath(rawPath string) (isValidMethodFn, bool) <span class="cov8" title="1">{
        if fn, ok := blacklistEndpoints[rawPath]; ok </span><span class="cov8" title="1">{
                return fn, true
        }</span>

        <span class="cov8" title="1">shiftPath := func(p string) (head, tail string) </span><span class="cov8" title="1">{
                p = path.Clean("/" + p)
                i := strings.Index(p[1:], "/") + 1
                if i &lt;= 0 </span><span class="cov8" title="1">{
                        return p[1:], "/"
                }</span>
                <span class="cov8" title="1">return p[1:i], p[i:]</span>
        }

        // ugh, should probably make this whole operation use a trie
        <span class="cov8" title="1">partsMatch := func(raw, source string) bool </span><span class="cov8" title="1">{
                return raw == source || (strings.HasPrefix(source, ":") &amp;&amp; raw != "")
        }</span>

        <span class="cov8" title="1">compareRawSourceURLs := func(raw, source string) bool </span><span class="cov8" title="1">{
                sourceHead, sourceTail := shiftPath(source)
                for rawHead, rawTail := shiftPath(rawPath); rawHead != ""; </span><span class="cov8" title="1">{
                        if !partsMatch(rawHead, sourceHead) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">rawHead, rawTail = shiftPath(rawTail)
                        sourceHead, sourceTail = shiftPath(sourceTail)</span>
                }
                <span class="cov8" title="1">return sourceHead == ""</span>
        }

        <span class="cov8" title="1">for sourcePath, fn := range blacklistEndpoints </span><span class="cov8" title="1">{
                match := compareRawSourceURLs(rawPath, sourcePath)
                if match </span><span class="cov8" title="1">{
                        return fn, true
                }</span>
        }

        <span class="cov8" title="1">return nil, false</span>
}

func ignoreMethod(ignoredMethods ...string) isValidMethodFn <span class="cov8" title="1">{
        if len(ignoredMethods) == 0 </span><span class="cov8" title="1">{
                return func(string) bool </span><span class="cov8" title="1">{ return true }</span>
        }

        <span class="cov8" title="1">ignoreMap := make(map[string]bool)
        for _, method := range ignoredMethods </span><span class="cov8" title="1">{
                ignoreMap[method] = true
        }</span>

        <span class="cov8" title="1">return func(method string) bool </span><span class="cov8" title="1">{
                return ignoreMap[method]
        }</span>
}

const (
        prefixSetup                      = "/api/v2/setup"
        organizationsIDSecretsPath       = "/api/v2/orgs/:id/secrets"
        organizationsIDSecretsDeletePath = "/api/v2/orgs/:id/secrets/delete"
)

// TODO(@jsteenb2): make this a stronger type that handlers can register routes that should not be logged.
var blacklistEndpoints = map[string]isValidMethodFn{
        "/api/v2/signin":                 ignoreMethod(),
        "/api/v2/signout":                ignoreMethod(),
        "/api/v2/me":                     ignoreMethod(),
        "/api/v2/me/password":            ignoreMethod(),
        "/api/v2/users/:id/password":     ignoreMethod(),
        "/api/v2/packages/apply":         ignoreMethod(),
        prefixWrite:                      ignoreMethod("POST"),
        "/write":                         ignoreMethod("POST"),
        organizationsIDSecretsPath:       ignoreMethod("PATCH"),
        organizationsIDSecretsDeletePath: ignoreMethod("POST"),
        prefixSetup:                      ignoreMethod("POST"),
        prefixNotificationEndpoints:      ignoreMethod("POST"),
        notificationEndpointsIDPath:      ignoreMethod("PUT"),
        restoreKVPath:                    ignoreMethod(),
        restoreSqlPath:                   ignoreMethod(),
        restoreBucketPath:                ignoreMethod(),
        restoreShardPath:                 ignoreMethod(),
        "/api/v2/remotes":                ignoreMethod("POST"),
        "/api/v2/remotes/:id":            ignoreMethod("PATCH"),
}

type bodyEchoer struct {
        rc    io.ReadCloser
        teedR io.Reader
}

func (b *bodyEchoer) Read(p []byte) (int, error) <span class="cov8" title="1">{
        return b.teedR.Read(p)
}</span>

func (b *bodyEchoer) Close() error <span class="cov8" title="1">{
        return b.rc.Close()
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package http

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        pctx "github.com/influxdata/influxdb/v2/context"
        "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/notification/endpoint"
        "github.com/influxdata/influxdb/v2/pkg/httpc"
        "go.uber.org/zap"
)

// NotificationEndpointBackend is all services and associated parameters required to construct
// the NotificationEndpointBackendHandler.
type NotificationEndpointBackend struct {
        errors.HTTPErrorHandler
        log *zap.Logger

        NotificationEndpointService influxdb.NotificationEndpointService
        UserResourceMappingService  influxdb.UserResourceMappingService
        LabelService                influxdb.LabelService
        UserService                 influxdb.UserService
}

// NewNotificationEndpointBackend returns a new instance of NotificationEndpointBackend.
func NewNotificationEndpointBackend(log *zap.Logger, b *APIBackend) *NotificationEndpointBackend <span class="cov8" title="1">{
        return &amp;NotificationEndpointBackend{
                HTTPErrorHandler:            b.HTTPErrorHandler,
                log:                         log,
                NotificationEndpointService: b.NotificationEndpointService,
                UserResourceMappingService:  b.UserResourceMappingService,
                LabelService:                b.LabelService,
                UserService:                 b.UserService,
        }
}</span>

func (b *NotificationEndpointBackend) Logger() *zap.Logger <span class="cov8" title="1">{
        return b.log
}</span>

// NotificationEndpointHandler is the handler for the notificationEndpoint service
type NotificationEndpointHandler struct {
        *httprouter.Router
        errors.HTTPErrorHandler
        log *zap.Logger

        NotificationEndpointService influxdb.NotificationEndpointService
        UserResourceMappingService  influxdb.UserResourceMappingService
        LabelService                influxdb.LabelService
        UserService                 influxdb.UserService
}

const (
        prefixNotificationEndpoints          = "/api/v2/notificationEndpoints"
        notificationEndpointsIDPath          = "/api/v2/notificationEndpoints/:id"
        notificationEndpointsIDMembersPath   = "/api/v2/notificationEndpoints/:id/members"
        notificationEndpointsIDMembersIDPath = "/api/v2/notificationEndpoints/:id/members/:userID"
        notificationEndpointsIDOwnersPath    = "/api/v2/notificationEndpoints/:id/owners"
        notificationEndpointsIDOwnersIDPath  = "/api/v2/notificationEndpoints/:id/owners/:userID"
        notificationEndpointsIDLabelsPath    = "/api/v2/notificationEndpoints/:id/labels"
        notificationEndpointsIDLabelsIDPath  = "/api/v2/notificationEndpoints/:id/labels/:lid"
)

// NewNotificationEndpointHandler returns a new instance of NotificationEndpointHandler.
func NewNotificationEndpointHandler(log *zap.Logger, b *NotificationEndpointBackend) *NotificationEndpointHandler <span class="cov8" title="1">{
        h := &amp;NotificationEndpointHandler{
                Router:           NewRouter(b.HTTPErrorHandler),
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,

                NotificationEndpointService: b.NotificationEndpointService,
                UserResourceMappingService:  b.UserResourceMappingService,
                LabelService:                b.LabelService,
                UserService:                 b.UserService,
        }
        h.HandlerFunc("POST", prefixNotificationEndpoints, h.handlePostNotificationEndpoint)
        h.HandlerFunc("GET", prefixNotificationEndpoints, h.handleGetNotificationEndpoints)
        h.HandlerFunc("GET", notificationEndpointsIDPath, h.handleGetNotificationEndpoint)
        h.HandlerFunc("DELETE", notificationEndpointsIDPath, h.handleDeleteNotificationEndpoint)
        h.HandlerFunc("PUT", notificationEndpointsIDPath, h.handlePutNotificationEndpoint)
        h.HandlerFunc("PATCH", notificationEndpointsIDPath, h.handlePatchNotificationEndpoint)

        memberBackend := MemberBackend{
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        b.log.With(zap.String("handler", "member")),
                ResourceType:               influxdb.NotificationEndpointResourceType,
                UserType:                   influxdb.Member,
                UserResourceMappingService: b.UserResourceMappingService,
                UserService:                b.UserService,
        }
        h.HandlerFunc("POST", notificationEndpointsIDMembersPath, newPostMemberHandler(memberBackend))
        h.HandlerFunc("GET", notificationEndpointsIDMembersPath, newGetMembersHandler(memberBackend))
        h.HandlerFunc("DELETE", notificationEndpointsIDMembersIDPath, newDeleteMemberHandler(memberBackend))

        ownerBackend := MemberBackend{
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        b.log.With(zap.String("handler", "member")),
                ResourceType:               influxdb.NotificationEndpointResourceType,
                UserType:                   influxdb.Owner,
                UserResourceMappingService: b.UserResourceMappingService,
                UserService:                b.UserService,
        }
        h.HandlerFunc("POST", notificationEndpointsIDOwnersPath, newPostMemberHandler(ownerBackend))
        h.HandlerFunc("GET", notificationEndpointsIDOwnersPath, newGetMembersHandler(ownerBackend))
        h.HandlerFunc("DELETE", notificationEndpointsIDOwnersIDPath, newDeleteMemberHandler(ownerBackend))

        labelBackend := &amp;LabelBackend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              b.log.With(zap.String("handler", "label")),
                LabelService:     b.LabelService,
                ResourceType:     influxdb.NotificationEndpointResourceType,
        }
        h.HandlerFunc("GET", notificationEndpointsIDLabelsPath, newGetLabelsHandler(labelBackend))
        h.HandlerFunc("POST", notificationEndpointsIDLabelsPath, newPostLabelHandler(labelBackend))
        h.HandlerFunc("DELETE", notificationEndpointsIDLabelsIDPath, newDeleteLabelHandler(labelBackend))

        return h
}</span>

type notificationEndpointLinks struct {
        Self    string `json:"self"`
        Labels  string `json:"labels"`
        Members string `json:"members"`
        Owners  string `json:"owners"`
}

type postNotificationEndpointRequest struct {
        influxdb.NotificationEndpoint
        Labels []string `json:"labels"`
}

type notificationEndpointResponse struct {
        influxdb.NotificationEndpoint
        Labels []influxdb.Label          `json:"labels"`
        Links  notificationEndpointLinks `json:"links"`
}

func (resp notificationEndpointResponse) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        b1, err := json.Marshal(resp.NotificationEndpoint)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">b2, err := json.Marshal(struct {
                Labels []influxdb.Label          `json:"labels"`
                Links  notificationEndpointLinks `json:"links"`
        }{
                Links:  resp.Links,
                Labels: resp.Labels,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return []byte(string(b1[:len(b1)-1]) + ", " + string(b2[1:])), nil</span>
}

type notificationEndpointsResponse struct {
        NotificationEndpoints []notificationEndpointResponse `json:"notificationEndpoints"`
        Links                 *influxdb.PagingLinks          `json:"links"`
}

func newNotificationEndpointResponse(edp influxdb.NotificationEndpoint, labels []*influxdb.Label) notificationEndpointResponse <span class="cov8" title="1">{
        res := notificationEndpointResponse{
                NotificationEndpoint: edp,
                Links: notificationEndpointLinks{
                        Self:    fmt.Sprintf("/api/v2/notificationEndpoints/%s", edp.GetID()),
                        Labels:  fmt.Sprintf("/api/v2/notificationEndpoints/%s/labels", edp.GetID()),
                        Members: fmt.Sprintf("/api/v2/notificationEndpoints/%s/members", edp.GetID()),
                        Owners:  fmt.Sprintf("/api/v2/notificationEndpoints/%s/owners", edp.GetID()),
                },
                Labels: []influxdb.Label{},
        }

        for _, l := range labels </span><span class="cov8" title="1">{
                res.Labels = append(res.Labels, *l)
        }</span>

        <span class="cov8" title="1">return res</span>
}

func newNotificationEndpointsResponse(ctx context.Context, edps []influxdb.NotificationEndpoint, labelService influxdb.LabelService, f influxdb.PagingFilter, opts influxdb.FindOptions) *notificationEndpointsResponse <span class="cov8" title="1">{
        resp := &amp;notificationEndpointsResponse{
                NotificationEndpoints: make([]notificationEndpointResponse, len(edps)),
                Links:                 influxdb.NewPagingLinks(prefixNotificationEndpoints, opts, f, len(edps)),
        }
        for i, edp := range edps </span><span class="cov8" title="1">{
                labels, _ := labelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: edp.GetID(), ResourceType: influxdb.NotificationEndpointResourceType})
                resp.NotificationEndpoints[i] = newNotificationEndpointResponse(edp, labels)
        }</span>
        <span class="cov8" title="1">return resp</span>
}

func decodeGetNotificationEndpointRequest(ctx context.Context) (i platform.ID, err error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return i, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return i, err
        }</span>
        <span class="cov8" title="1">return i, nil</span>
}

func (h *NotificationEndpointHandler) handleGetNotificationEndpoints(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        filter, opts, err := decodeNotificationEndpointFilter(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">edps, _, err := h.NotificationEndpointService.FindNotificationEndpoints(ctx, filter, opts)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("NotificationEndpoints retrieved", zap.String("notificationEndpoints", fmt.Sprint(edps)))

        if err := encodeResponse(ctx, w, http.StatusOK, newNotificationEndpointsResponse(ctx, edps, h.LabelService, filter, opts)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func (h *NotificationEndpointHandler) handleGetNotificationEndpoint(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        id, err := decodeGetNotificationEndpointRequest(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">edp, err := h.NotificationEndpointService.FindNotificationEndpointByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("NotificationEndpoint retrieved", zap.String("notificationEndpoint", fmt.Sprint(edp)))

        labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: edp.GetID(), ResourceType: influxdb.NotificationEndpointResourceType})
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusOK, newNotificationEndpointResponse(edp, labels)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func decodeNotificationEndpointFilter(ctx context.Context, r *http.Request) (influxdb.NotificationEndpointFilter, influxdb.FindOptions, error) <span class="cov8" title="1">{
        f := influxdb.NotificationEndpointFilter{
                UserResourceMappingFilter: influxdb.UserResourceMappingFilter{
                        ResourceType: influxdb.NotificationEndpointResourceType,
                },
        }

        opts, err := influxdb.DecodeFindOptions(r)
        if err != nil </span><span class="cov0" title="0">{
                return influxdb.NotificationEndpointFilter{}, influxdb.FindOptions{}, err
        }</span>

        <span class="cov8" title="1">q := r.URL.Query()
        if orgIDStr := q.Get("orgID"); orgIDStr != "" </span><span class="cov0" title="0">{
                orgID, err := platform.IDFromString(orgIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return influxdb.NotificationEndpointFilter{}, influxdb.FindOptions{}, &amp;errors.Error{
                                Code: errors.EInvalid,
                                Msg:  "orgID is invalid",
                                Err:  err,
                        }
                }</span>
                <span class="cov0" title="0">f.OrgID = orgID</span>
        } else<span class="cov8" title="1"> if orgNameStr := q.Get("org"); orgNameStr != "" </span><span class="cov0" title="0">{
                *f.Org = orgNameStr
        }</span>

        <span class="cov8" title="1">if userID := q.Get("user"); userID != "" </span><span class="cov0" title="0">{
                id, err := platform.IDFromString(userID)
                if err != nil </span><span class="cov0" title="0">{
                        return influxdb.NotificationEndpointFilter{}, influxdb.FindOptions{}, err
                }</span>
                <span class="cov0" title="0">f.UserID = *id</span>
        }

        <span class="cov8" title="1">return f, *opts, err</span>
}

func decodePostNotificationEndpointRequest(r *http.Request) (postNotificationEndpointRequest, error) <span class="cov8" title="1">{
        b, err := ioutil.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return postNotificationEndpointRequest{}, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>
        <span class="cov8" title="1">defer r.Body.Close()
        edp, err := endpoint.UnmarshalJSON(b)
        if err != nil </span><span class="cov0" title="0">{
                return postNotificationEndpointRequest{}, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>

        <span class="cov8" title="1">var dl decodeLabels
        if err := json.Unmarshal(b, &amp;dl); err != nil </span><span class="cov0" title="0">{
                return postNotificationEndpointRequest{}, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>

        <span class="cov8" title="1">return postNotificationEndpointRequest{
                NotificationEndpoint: edp,
                Labels:               dl.Labels,
        }, nil</span>
}

func decodePutNotificationEndpointRequest(ctx context.Context, r *http.Request) (influxdb.NotificationEndpoint, error) <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        if _, err := buf.ReadFrom(r.Body); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>
        <span class="cov8" title="1">defer r.Body.Close()

        edp, err := endpoint.UnmarshalJSON(buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>

        <span class="cov8" title="1">params := httprouter.ParamsFromContext(ctx)
        i, err := platform.IDFromString(params.ByName("id"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">edp.SetID(*i)
        return edp, nil</span>
}

type patchNotificationEndpointRequest struct {
        platform.ID
        Update influxdb.NotificationEndpointUpdate
}

func decodePatchNotificationEndpointRequest(ctx context.Context, r *http.Request) (patchNotificationEndpointRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id, err := platform.IDFromString(params.ByName("id"))
        if err != nil </span><span class="cov0" title="0">{
                return patchNotificationEndpointRequest{}, err
        }</span>
        <span class="cov8" title="1">req := patchNotificationEndpointRequest{
                ID: *id,
        }

        var upd influxdb.NotificationEndpointUpdate
        if err := json.NewDecoder(r.Body).Decode(&amp;upd); err != nil </span><span class="cov0" title="0">{
                return patchNotificationEndpointRequest{}, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  err.Error(),
                }
        }</span>
        <span class="cov8" title="1">if err := upd.Valid(); err != nil </span><span class="cov0" title="0">{
                return patchNotificationEndpointRequest{}, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  err.Error(),
                }
        }</span>

        <span class="cov8" title="1">req.Update = upd
        return req, nil</span>
}

// handlePostNotificationEndpoint is the HTTP handler for the POST /api/v2/notificationEndpoints route.
func (h *NotificationEndpointHandler) handlePostNotificationEndpoint(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        edp, err := decodePostNotificationEndpointRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">auth, err := pctx.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">err = h.NotificationEndpointService.CreateNotificationEndpoint(ctx, edp.NotificationEndpoint, auth.GetUserID())
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">labels := h.mapNewNotificationEndpointLabels(ctx, edp.NotificationEndpoint, edp.Labels)

        h.log.Debug("NotificationEndpoint created", zap.String("notificationEndpoint", fmt.Sprint(edp)))

        if err := encodeResponse(ctx, w, http.StatusCreated, newNotificationEndpointResponse(edp, labels)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func (h *NotificationEndpointHandler) mapNewNotificationEndpointLabels(ctx context.Context, nre influxdb.NotificationEndpoint, labels []string) []*influxdb.Label <span class="cov8" title="1">{
        var ls []*influxdb.Label
        for _, sid := range labels </span><span class="cov0" title="0">{
                var lid platform.ID
                err := lid.DecodeFromString(sid)

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">label, err := h.LabelService.FindLabelByID(ctx, lid)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">mapping := influxdb.LabelMapping{
                        LabelID:      label.ID,
                        ResourceID:   nre.GetID(),
                        ResourceType: influxdb.NotificationEndpointResourceType,
                }

                err = h.LabelService.CreateLabelMapping(ctx, &amp;mapping)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">ls = append(ls, label)</span>
        }
        <span class="cov8" title="1">return ls</span>
}

// handlePutNotificationEndpoint is the HTTP handler for the PUT /api/v2/notificationEndpoints route.
func (h *NotificationEndpointHandler) handlePutNotificationEndpoint(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        edp, err := decodePutNotificationEndpointRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">auth, err := pctx.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">edp, err = h.NotificationEndpointService.UpdateNotificationEndpoint(ctx, edp.GetID(), edp, auth.GetUserID())
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: edp.GetID(), ResourceType: influxdb.NotificationEndpointResourceType})
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("NotificationEndpoint replaced", zap.String("notificationEndpoint", fmt.Sprint(edp)))

        if err := encodeResponse(ctx, w, http.StatusOK, newNotificationEndpointResponse(edp, labels)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

// handlePatchNotificationEndpoint is the HTTP handler for the PATCH /api/v2/notificationEndpoints/:id route.
func (h *NotificationEndpointHandler) handlePatchNotificationEndpoint(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodePatchNotificationEndpointRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">edp, err := h.NotificationEndpointService.PatchNotificationEndpoint(ctx, req.ID, req.Update)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: edp.GetID(), ResourceType: influxdb.NotificationEndpointResourceType})
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("NotificationEndpoint patch", zap.String("notificationEndpoint", fmt.Sprint(edp)))

        if err := encodeResponse(ctx, w, http.StatusOK, newNotificationEndpointResponse(edp, labels)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func (h *NotificationEndpointHandler) handleDeleteNotificationEndpoint(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        i, err := decodeGetNotificationEndpointRequest(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">flds, _, err := h.NotificationEndpointService.DeleteNotificationEndpoint(ctx, i)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">keys := make([]string, len(flds))
        for k, fld := range flds </span><span class="cov8" title="1">{
                if fld.Key == "" </span><span class="cov0" title="0">{
                        h.HandleHTTPError(ctx, &amp;errors.Error{
                                Op:  "http/handleDeleteNotificationEndpoint",
                                Msg: "Bad Secret Key in endpoint " + i.String(),
                        }, w)
                        return
                }</span>
                <span class="cov8" title="1">keys[k] = fld.Key</span>
        }
        <span class="cov8" title="1">h.log.Debug("NotificationEndpoint deleted", zap.String("notificationEndpointID", fmt.Sprint(i)))

        w.WriteHeader(http.StatusNoContent)</span>
}

// NotificationEndpointService is an http client for the influxdb.NotificationEndpointService server implementation.
type NotificationEndpointService struct {
        Client *httpc.Client
}

// NewNotificationEndpointService constructs a new http NotificationEndpointService.
func NewNotificationEndpointService(client *httpc.Client) *NotificationEndpointService <span class="cov0" title="0">{
        return &amp;NotificationEndpointService{
                Client: client,
        }
}</span>

var _ influxdb.NotificationEndpointService = (*NotificationEndpointService)(nil)

// FindNotificationEndpointByID returns a single notification endpoint by ID.
func (s *NotificationEndpointService) FindNotificationEndpointByID(ctx context.Context, id platform.ID) (influxdb.NotificationEndpoint, error) <span class="cov0" title="0">{
        if !id.Valid() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid ID: please provide a valid ID")
        }</span>
        <span class="cov0" title="0">var resp notificationEndpointDecoder
        err := s.Client.
                Get(prefixNotificationEndpoints, id.String()).
                DecodeJSON(&amp;resp).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp.endpoint, nil</span>
}

// FindNotificationEndpoints returns a list of notification endpoints that match filter and the total count of matching notification endpoints.
// Additional options provide pagination &amp; sorting.
func (s *NotificationEndpointService) FindNotificationEndpoints(ctx context.Context, filter influxdb.NotificationEndpointFilter, opt ...influxdb.FindOptions) ([]influxdb.NotificationEndpoint, int, error) <span class="cov0" title="0">{
        params := influxdb.FindOptionParams(opt...)
        if filter.ID != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"id", filter.ID.String()})
        }</span>
        <span class="cov0" title="0">if filter.OrgID != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"orgID", filter.OrgID.String()})
        }</span>
        <span class="cov0" title="0">if filter.Org != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"org", *filter.Org})
        }</span>

        <span class="cov0" title="0">var resp struct {
                Endpoints []notificationEndpointDecoder `json:"notificationEndpoints"`
        }
        err := s.Client.
                Get(prefixNotificationEndpoints).
                QueryParams(params...).
                DecodeJSON(&amp;resp).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">var endpoints []influxdb.NotificationEndpoint
        for _, e := range resp.Endpoints </span><span class="cov0" title="0">{
                endpoints = append(endpoints, e.endpoint)
        }</span>
        <span class="cov0" title="0">return endpoints, len(endpoints), nil</span>
}

// CreateNotificationEndpoint creates a new notification endpoint and sets b.ID with the new identifier.
// TODO(@jsteenb2): this is unsatisfactory, we have no way of grabbing the new notification endpoint without
//  serious hacky hackertoning. Put it on the list...
func (s *NotificationEndpointService) CreateNotificationEndpoint(ctx context.Context, ne influxdb.NotificationEndpoint, userID platform.ID) error <span class="cov0" title="0">{
        var resp notificationEndpointDecoder
        err := s.Client.
                PostJSON(&amp;notificationEndpointEncoder{ne: ne}, prefixNotificationEndpoints).
                DecodeJSON(&amp;resp).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // :sadpanda:
        <span class="cov0" title="0">ne.SetID(resp.endpoint.GetID())
        ne.SetOrgID(resp.endpoint.GetOrgID())
        return nil</span>
}

// UpdateNotificationEndpoint updates a single notification endpoint.
// Returns the new notification endpoint after update.
func (s *NotificationEndpointService) UpdateNotificationEndpoint(ctx context.Context, id platform.ID, ne influxdb.NotificationEndpoint, userID platform.ID) (influxdb.NotificationEndpoint, error) <span class="cov0" title="0">{
        if !id.Valid() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid ID: please provide a valid ID")
        }</span>
        <span class="cov0" title="0">var resp notificationEndpointDecoder
        err := s.Client.
                PutJSON(&amp;notificationEndpointEncoder{ne: ne}, prefixNotificationEndpoints, id.String()).
                DecodeJSON(&amp;resp).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp.endpoint, nil</span>
}

// PatchNotificationEndpoint updates a single  notification endpoint with changeset.
// Returns the new notification endpoint state after update.
func (s *NotificationEndpointService) PatchNotificationEndpoint(ctx context.Context, id platform.ID, upd influxdb.NotificationEndpointUpdate) (influxdb.NotificationEndpoint, error) <span class="cov0" title="0">{
        if !id.Valid() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid ID: please provide a valid ID")
        }</span>
        <span class="cov0" title="0">if err := upd.Valid(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var resp notificationEndpointDecoder
        err := s.Client.
                PatchJSON(upd, prefixNotificationEndpoints, id.String()).
                DecodeJSON(&amp;resp).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return resp.endpoint, nil</span>
}

// DeleteNotificationEndpoint removes a notification endpoint by ID, returns secret fields, orgID for further deletion.
// TODO: axe this delete design, makes little sense in how its currently being done. Right now, as an http client,
//  I am forced to know how the store handles this and then figure out what the server does in between me and that store,
//  then see what falls out :flushed... for now returning nothing for secrets, orgID, and only returning an error. This makes
//  the code/design smell super obvious imo
func (s *NotificationEndpointService) DeleteNotificationEndpoint(ctx context.Context, id platform.ID) ([]influxdb.SecretField, platform.ID, error) <span class="cov0" title="0">{
        if !id.Valid() </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("invalid ID: please provide a valid ID")
        }</span>
        <span class="cov0" title="0">err := s.Client.
                Delete(prefixNotificationEndpoints, id.String()).
                Do(ctx)
        return nil, 0, err</span>
}

type notificationEndpointEncoder struct {
        ne influxdb.NotificationEndpoint
}

func (n *notificationEndpointEncoder) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := json.Marshal(n.ne)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ughhh := make(map[string]interface{})
        if err := json.Unmarshal(b, &amp;ughhh); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">n.ne.BackfillSecretKeys()

        // this makes me queezy and altogether sad
        fieldMap := map[string]string{
                "-password":    "password",
                "-routing-key": "routingKey",
                "-token":       "token",
                "-username":    "username",
        }
        for _, sec := range n.ne.SecretFields() </span><span class="cov0" title="0">{
                var v string
                if sec.Value != nil </span><span class="cov0" title="0">{
                        v = *sec.Value
                }</span>
                <span class="cov0" title="0">ughhh[fieldMap[sec.Key]] = v</span>
        }
        <span class="cov0" title="0">return json.Marshal(ughhh)</span>
}

type notificationEndpointDecoder struct {
        endpoint influxdb.NotificationEndpoint
}

func (n *notificationEndpointDecoder) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        newEndpoint, err := endpoint.UnmarshalJSON(b)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">n.endpoint = newEndpoint
        return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package http

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "path"
        "time"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        pctx "github.com/influxdata/influxdb/v2/context"
        "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/notification/rule"
        "github.com/influxdata/influxdb/v2/pkg/httpc"
        "github.com/influxdata/influxdb/v2/task/taskmodel"
        "go.uber.org/zap"
)

var _ influxdb.NotificationRuleStore = (*NotificationRuleService)(nil)

type statusDecode struct {
        Status *influxdb.Status `json:"status"`
}

// NotificationRuleBackend is all services and associated parameters required to construct
// the NotificationRuleBackendHandler.
type NotificationRuleBackend struct {
        errors.HTTPErrorHandler
        log *zap.Logger

        AlgoWProxy                  FeatureProxyHandler
        NotificationRuleStore       influxdb.NotificationRuleStore
        NotificationEndpointService influxdb.NotificationEndpointService
        UserResourceMappingService  influxdb.UserResourceMappingService
        LabelService                influxdb.LabelService
        UserService                 influxdb.UserService
        OrganizationService         influxdb.OrganizationService
        TaskService                 taskmodel.TaskService
}

// NewNotificationRuleBackend returns a new instance of NotificationRuleBackend.
func NewNotificationRuleBackend(log *zap.Logger, b *APIBackend) *NotificationRuleBackend <span class="cov8" title="1">{
        return &amp;NotificationRuleBackend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,
                AlgoWProxy:       b.AlgoWProxy,

                NotificationRuleStore:       b.NotificationRuleStore,
                NotificationEndpointService: b.NotificationEndpointService,
                UserResourceMappingService:  b.UserResourceMappingService,
                LabelService:                b.LabelService,
                UserService:                 b.UserService,
                OrganizationService:         b.OrganizationService,
                TaskService:                 b.TaskService,
        }
}</span>

// NotificationRuleHandler is the handler for the notification rule service
type NotificationRuleHandler struct {
        *httprouter.Router
        errors.HTTPErrorHandler
        log *zap.Logger

        NotificationRuleStore       influxdb.NotificationRuleStore
        NotificationEndpointService influxdb.NotificationEndpointService
        UserResourceMappingService  influxdb.UserResourceMappingService
        LabelService                influxdb.LabelService
        UserService                 influxdb.UserService
        OrganizationService         influxdb.OrganizationService
        TaskService                 taskmodel.TaskService
}

const (
        prefixNotificationRules          = "/api/v2/notificationRules"
        notificationRulesIDPath          = "/api/v2/notificationRules/:id"
        notificationRulesIDQueryPath     = "/api/v2/notificationRules/:id/query"
        notificationRulesIDMembersPath   = "/api/v2/notificationRules/:id/members"
        notificationRulesIDMembersIDPath = "/api/v2/notificationRules/:id/members/:userID"
        notificationRulesIDOwnersPath    = "/api/v2/notificationRules/:id/owners"
        notificationRulesIDOwnersIDPath  = "/api/v2/notificationRules/:id/owners/:userID"
        notificationRulesIDLabelsPath    = "/api/v2/notificationRules/:id/labels"
        notificationRulesIDLabelsIDPath  = "/api/v2/notificationRules/:id/labels/:lid"
)

// NewNotificationRuleHandler returns a new instance of NotificationRuleHandler.
func NewNotificationRuleHandler(log *zap.Logger, b *NotificationRuleBackend) *NotificationRuleHandler <span class="cov8" title="1">{
        h := &amp;NotificationRuleHandler{
                Router:           NewRouter(b.HTTPErrorHandler),
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,

                NotificationRuleStore:       b.NotificationRuleStore,
                NotificationEndpointService: b.NotificationEndpointService,
                UserResourceMappingService:  b.UserResourceMappingService,
                LabelService:                b.LabelService,
                UserService:                 b.UserService,
                OrganizationService:         b.OrganizationService,
                TaskService:                 b.TaskService,
        }

        h.Handler("POST", prefixNotificationRules, withFeatureProxy(b.AlgoWProxy, http.HandlerFunc(h.handlePostNotificationRule)))
        h.HandlerFunc("GET", prefixNotificationRules, h.handleGetNotificationRules)
        h.HandlerFunc("GET", notificationRulesIDPath, h.handleGetNotificationRule)
        h.HandlerFunc("GET", notificationRulesIDQueryPath, h.handleGetNotificationRuleQuery)
        h.HandlerFunc("DELETE", notificationRulesIDPath, h.handleDeleteNotificationRule)
        h.Handler("PUT", notificationRulesIDPath, withFeatureProxy(b.AlgoWProxy, http.HandlerFunc(h.handlePutNotificationRule)))
        h.Handler("PATCH", notificationRulesIDPath, withFeatureProxy(b.AlgoWProxy, http.HandlerFunc(h.handlePatchNotificationRule)))

        memberBackend := MemberBackend{
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        b.log.With(zap.String("handler", "member")),
                ResourceType:               influxdb.NotificationRuleResourceType,
                UserType:                   influxdb.Member,
                UserResourceMappingService: b.UserResourceMappingService,
                UserService:                b.UserService,
        }
        h.HandlerFunc("POST", notificationRulesIDMembersPath, newPostMemberHandler(memberBackend))
        h.HandlerFunc("GET", notificationRulesIDMembersPath, newGetMembersHandler(memberBackend))
        h.HandlerFunc("DELETE", notificationRulesIDMembersIDPath, newDeleteMemberHandler(memberBackend))

        ownerBackend := MemberBackend{
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        b.log.With(zap.String("handler", "member")),
                ResourceType:               influxdb.NotificationRuleResourceType,
                UserType:                   influxdb.Owner,
                UserResourceMappingService: b.UserResourceMappingService,
                UserService:                b.UserService,
        }
        h.HandlerFunc("POST", notificationRulesIDOwnersPath, newPostMemberHandler(ownerBackend))
        h.HandlerFunc("GET", notificationRulesIDOwnersPath, newGetMembersHandler(ownerBackend))
        h.HandlerFunc("DELETE", notificationRulesIDOwnersIDPath, newDeleteMemberHandler(ownerBackend))

        labelBackend := &amp;LabelBackend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              b.log.With(zap.String("handler", "label")),
                LabelService:     b.LabelService,
                ResourceType:     influxdb.NotificationRuleResourceType,
        }
        h.HandlerFunc("GET", notificationRulesIDLabelsPath, newGetLabelsHandler(labelBackend))
        h.HandlerFunc("POST", notificationRulesIDLabelsPath, newPostLabelHandler(labelBackend))
        h.HandlerFunc("DELETE", notificationRulesIDLabelsIDPath, newDeleteLabelHandler(labelBackend))

        return h
}</span>

type notificationRuleLinks struct {
        Self    string `json:"self"`
        Labels  string `json:"labels"`
        Members string `json:"members"`
        Owners  string `json:"owners"`
        Query   string `json:"query"`
}

type notificationRuleResponse struct {
        influxdb.NotificationRule
        Labels          []influxdb.Label      `json:"labels"`
        Links           notificationRuleLinks `json:"links"`
        Status          string                `json:"status"`
        LatestCompleted time.Time             `json:"latestCompleted,omitempty"`
        LatestScheduled time.Time             `json:"latestScheduled,omitempty"`
        LastRunStatus   string                `json:"LastRunStatus,omitempty"`
        LastRunError    string                `json:"LastRunError,omitempty"`
        TaskID          platform.ID           `json:"taskID,omitempty"`
}

type ruleResponseMeta struct {
        Labels          []influxdb.Label      `json:"labels"`
        Links           notificationRuleLinks `json:"links"`
        Status          string                `json:"status"`
        LatestCompleted time.Time             `json:"latestCompleted,omitempty"`
        LatestScheduled time.Time             `json:"latestScheduled,omitempty"`
        LastRunStatus   string                `json:"lastRunStatus,omitempty"`
        LastRunError    string                `json:"lastRunError,omitempty"`
        TaskID          platform.ID           `json:"taskID,omitempty"`
}

func (resp *notificationRuleResponse) UnmarshalJSON(v []byte) (err error) <span class="cov0" title="0">{
        var responseMeta ruleResponseMeta
        if err = json.Unmarshal(v, &amp;responseMeta); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">resp.Labels = responseMeta.Labels
        resp.Links = responseMeta.Links
        resp.Status = responseMeta.Status
        resp.LatestCompleted = responseMeta.LatestCompleted
        resp.LatestScheduled = responseMeta.LatestScheduled
        resp.LastRunStatus = responseMeta.LastRunStatus
        resp.LastRunError = responseMeta.LastRunError

        resp.NotificationRule, err = rule.UnmarshalJSON(v)
        return</span>
}

func (resp notificationRuleResponse) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        b1, err := json.Marshal(resp.NotificationRule)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">b2, err := json.Marshal(ruleResponseMeta{
                Links:           resp.Links,
                Labels:          resp.Labels,
                Status:          resp.Status,
                LatestCompleted: resp.LatestCompleted,
                LatestScheduled: resp.LatestScheduled,
                LastRunStatus:   resp.LastRunStatus,
                LastRunError:    resp.LastRunError,
                TaskID:          resp.TaskID,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return []byte(string(b1[:len(b1)-1]) + ", " + string(b2[1:])), nil</span>
}

type notificationRulesResponse struct {
        NotificationRules []*notificationRuleResponse `json:"notificationRules"`
        Links             *influxdb.PagingLinks       `json:"links"`
}

func (h *NotificationRuleHandler) newNotificationRuleResponse(ctx context.Context, nr influxdb.NotificationRule, labels []*influxdb.Label) (*notificationRuleResponse, error) <span class="cov8" title="1">{
        // TODO(desa): this should be handled in the rule service and not exposed in http land, but is currently blocking the FE. https://github.com/influxdata/influxdb/issues/15259
        t, err := h.TaskService.FindTaskByID(ctx, nr.GetTaskID())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">res := &amp;notificationRuleResponse{
                NotificationRule: nr,
                Links: notificationRuleLinks{
                        Self:    fmt.Sprintf("/api/v2/notificationRules/%s", nr.GetID()),
                        Labels:  fmt.Sprintf("/api/v2/notificationRules/%s/labels", nr.GetID()),
                        Members: fmt.Sprintf("/api/v2/notificationRules/%s/members", nr.GetID()),
                        Owners:  fmt.Sprintf("/api/v2/notificationRules/%s/owners", nr.GetID()),
                        Query:   fmt.Sprintf("/api/v2/notificationRules/%s/query", nr.GetID()),
                },
                Labels:          []influxdb.Label{},
                Status:          t.Status,
                LatestCompleted: t.LatestCompleted,
                LatestScheduled: t.LatestScheduled,
                LastRunStatus:   t.LastRunStatus,
                LastRunError:    t.LastRunError,
                TaskID:          t.ID,
        }

        for _, l := range labels </span><span class="cov0" title="0">{
                res.Labels = append(res.Labels, *l)
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}

func (h *NotificationRuleHandler) newNotificationRulesResponse(ctx context.Context, nrs []influxdb.NotificationRule, labelService influxdb.LabelService, f influxdb.PagingFilter, opts influxdb.FindOptions) (*notificationRulesResponse, error) <span class="cov8" title="1">{
        resp := &amp;notificationRulesResponse{
                NotificationRules: []*notificationRuleResponse{},
                Links:             influxdb.NewPagingLinks(prefixNotificationRules, opts, f, len(nrs)),
        }
        for _, nr := range nrs </span><span class="cov8" title="1">{
                labels, _ := labelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: nr.GetID(), ResourceType: influxdb.NotificationRuleResourceType})
                res, err := h.newNotificationRuleResponse(ctx, nr, labels)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">resp.NotificationRules = append(resp.NotificationRules, res)</span>
        }
        <span class="cov8" title="1">return resp, nil</span>
}

func decodeGetNotificationRuleRequest(ctx context.Context, r *http.Request) (i platform.ID, err error) <span class="cov0" title="0">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return i, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov0" title="0">if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return i, err
        }</span>
        <span class="cov0" title="0">return i, nil</span>
}

func (h *NotificationRuleHandler) handleGetNotificationRules(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        filter, opts, err := decodeNotificationRuleFilter(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">nrs, _, err := h.NotificationRuleStore.FindNotificationRules(ctx, *filter, *opts)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">h.log.Debug("Notification rules retrieved", zap.String("notificationRules", fmt.Sprint(nrs)))

        res, err := h.newNotificationRulesResponse(ctx, nrs, h.LabelService, filter, *opts)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">if err := encodeResponse(ctx, w, http.StatusOK, res); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func (h *NotificationRuleHandler) handleGetNotificationRuleQuery(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id, err := decodeGetNotificationRuleRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">nr, err := h.NotificationRuleStore.FindNotificationRuleByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">edp, err := h.NotificationEndpointService.FindNotificationEndpointByID(ctx, nr.GetEndpointID())
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, &amp;errors.Error{
                        Code: errors.EInternal,
                        Op:   "http/handleGetNotificationRuleQuery",
                        Err:  err,
                }, w)
                return
        }</span>
        <span class="cov0" title="0">flux, err := nr.GenerateFlux(edp)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">h.log.Debug("Notification rule query retrieved", zap.String("notificationRuleQuery", fmt.Sprint(flux)))
        if err := encodeResponse(ctx, w, http.StatusOK, newFluxResponse(flux)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func (h *NotificationRuleHandler) handleGetNotificationRule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        id, err := decodeGetNotificationRuleRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">nr, err := h.NotificationRuleStore.FindNotificationRuleByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">h.log.Debug("Notification rule retrieved", zap.String("notificationRule", fmt.Sprint(nr)))

        labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: nr.GetID(), ResourceType: influxdb.NotificationRuleResourceType})
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">res, err := h.newNotificationRuleResponse(ctx, nr, labels)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">if err := encodeResponse(ctx, w, http.StatusOK, res); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func decodeNotificationRuleFilter(ctx context.Context, r *http.Request) (*influxdb.NotificationRuleFilter, *influxdb.FindOptions, error) <span class="cov0" title="0">{
        f := &amp;influxdb.NotificationRuleFilter{}
        urm, err := decodeUserResourceMappingFilter(ctx, r, influxdb.NotificationRuleResourceType)
        if err == nil </span><span class="cov0" title="0">{
                f.UserResourceMappingFilter = *urm
        }</span>

        <span class="cov0" title="0">opts, err := influxdb.DecodeFindOptions(r)
        if err != nil </span><span class="cov0" title="0">{
                return f, nil, err
        }</span>

        <span class="cov0" title="0">q := r.URL.Query()
        if orgIDStr := q.Get("orgID"); orgIDStr != "" </span><span class="cov0" title="0">{
                orgID, err := platform.IDFromString(orgIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return f, opts, &amp;errors.Error{
                                Code: errors.EInvalid,
                                Msg:  "orgID is invalid",
                                Err:  err,
                        }
                }</span>
                <span class="cov0" title="0">f.OrgID = orgID</span>
        } else<span class="cov0" title="0"> if orgNameStr := q.Get("org"); orgNameStr != "" </span><span class="cov0" title="0">{
                *f.Organization = orgNameStr
        }</span>

        <span class="cov0" title="0">for _, tag := range q["tag"] </span><span class="cov0" title="0">{
                tp, err := influxdb.NewTag(tag)
                // ignore malformed tag pairs
                if err == nil </span><span class="cov0" title="0">{
                        f.Tags = append(f.Tags, tp)
                }</span>
        }

        <span class="cov0" title="0">return f, opts, err</span>
}

func decodeUserResourceMappingFilter(ctx context.Context, r *http.Request, typ influxdb.ResourceType) (*influxdb.UserResourceMappingFilter, error) <span class="cov0" title="0">{
        q := r.URL.Query()
        f := &amp;influxdb.UserResourceMappingFilter{
                ResourceType: typ,
        }
        if idStr := q.Get("resourceID"); idStr != "" </span><span class="cov0" title="0">{
                id, err := platform.IDFromString(idStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">f.ResourceID = *id</span>
        }

        <span class="cov0" title="0">if idStr := q.Get("userID"); idStr != "" </span><span class="cov0" title="0">{
                id, err := platform.IDFromString(idStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">f.UserID = *id</span>
        }
        <span class="cov0" title="0">return f, nil</span>
}

type postNotificationRuleRequest struct {
        influxdb.NotificationRuleCreate
        Labels []string `json:"labels"`
}

func decodePostNotificationRuleRequest(ctx context.Context, r *http.Request) (postNotificationRuleRequest, error) <span class="cov0" title="0">{
        var pnrr postNotificationRuleRequest
        var sts statusDecode
        var dl decodeLabels

        buf := new(bytes.Buffer)
        _, err := buf.ReadFrom(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return pnrr, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>
        <span class="cov0" title="0">defer r.Body.Close()

        nr, err := rule.UnmarshalJSON(buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return pnrr, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(buf.Bytes(), &amp;sts); err != nil </span><span class="cov0" title="0">{
                return pnrr, err
        }</span>

        <span class="cov0" title="0">if err := json.Unmarshal(buf.Bytes(), &amp;dl); err != nil </span><span class="cov0" title="0">{
                return pnrr, err
        }</span>

        <span class="cov0" title="0">pnrr = postNotificationRuleRequest{
                NotificationRuleCreate: influxdb.NotificationRuleCreate{
                        NotificationRule: nr,
                        Status:           *sts.Status,
                },
                Labels: dl.Labels,
        }

        return pnrr, nil</span>
}

func decodePutNotificationRuleRequest(ctx context.Context, r *http.Request) (influxdb.NotificationRuleCreate, error) <span class="cov0" title="0">{
        var nrc influxdb.NotificationRuleCreate
        var sts statusDecode

        buf := new(bytes.Buffer)
        _, err := buf.ReadFrom(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nrc, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>
        <span class="cov0" title="0">defer r.Body.Close()
        nr, err := rule.UnmarshalJSON(buf.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nrc, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>
        <span class="cov0" title="0">params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nrc, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>
        <span class="cov0" title="0">i := new(platform.ID)
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nrc, err
        }</span>
        <span class="cov0" title="0">nr.SetID(*i)

        err = json.Unmarshal(buf.Bytes(), &amp;sts)
        if err != nil </span><span class="cov0" title="0">{
                return nrc, err
        }</span>

        <span class="cov0" title="0">nrc = influxdb.NotificationRuleCreate{
                NotificationRule: nr,
                Status:           *sts.Status,
        }

        return nrc, nil</span>
}

type patchNotificationRuleRequest struct {
        platform.ID
        Update influxdb.NotificationRuleUpdate
}

func decodePatchNotificationRuleRequest(ctx context.Context, r *http.Request) (*patchNotificationRuleRequest, error) <span class="cov0" title="0">{
        req := &amp;patchNotificationRuleRequest{}
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov0" title="0">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.ID = i

        upd := &amp;influxdb.NotificationRuleUpdate{}
        if err := json.NewDecoder(r.Body).Decode(upd); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  err.Error(),
                }
        }</span>
        <span class="cov0" title="0">if err := upd.Valid(); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  err.Error(),
                }
        }</span>

        <span class="cov0" title="0">req.Update = *upd
        return req, nil</span>
}

// handlePostNotificationRule is the HTTP handler for the POST /api/v2/notificationRules route.
func (h *NotificationRuleHandler) handlePostNotificationRule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        nr, err := decodePostNotificationRuleRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">auth, err := pctx.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">if err := h.NotificationRuleStore.CreateNotificationRule(ctx, nr.NotificationRuleCreate, auth.GetUserID()); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">h.log.Debug("Notification rule created", zap.String("notificationRule", fmt.Sprint(nr)))

        labels := h.mapNewNotificationRuleLabels(ctx, nr.NotificationRuleCreate, nr.Labels)

        res, err := h.newNotificationRuleResponse(ctx, nr, labels)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">if err := encodeResponse(ctx, w, http.StatusCreated, res); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func (h *NotificationRuleHandler) mapNewNotificationRuleLabels(ctx context.Context, nrc influxdb.NotificationRuleCreate, labels []string) []*influxdb.Label <span class="cov0" title="0">{
        var ls []*influxdb.Label
        for _, sid := range labels </span><span class="cov0" title="0">{
                var lid platform.ID
                err := lid.DecodeFromString(sid)

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">label, err := h.LabelService.FindLabelByID(ctx, lid)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">mapping := influxdb.LabelMapping{
                        LabelID:      label.ID,
                        ResourceID:   nrc.GetID(),
                        ResourceType: influxdb.NotificationRuleResourceType,
                }

                err = h.LabelService.CreateLabelMapping(ctx, &amp;mapping)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">ls = append(ls, label)</span>
        }
        <span class="cov0" title="0">return ls</span>
}

// handlePutNotificationRule is the HTTP handler for the PUT /api/v2/notificationRule route.
func (h *NotificationRuleHandler) handlePutNotificationRule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        nrc, err := decodePutNotificationRuleRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">auth, err := pctx.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">nr, err := h.NotificationRuleStore.UpdateNotificationRule(ctx, nrc.GetID(), nrc, auth.GetUserID())
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: nr.GetID(), ResourceType: influxdb.NotificationRuleResourceType})
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">h.log.Debug("Notification rule updated", zap.String("notificationRule", fmt.Sprint(nr)))

        res, err := h.newNotificationRuleResponse(ctx, nr, labels)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">if err := encodeResponse(ctx, w, http.StatusOK, res); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

// handlePatchNotificationRule is the HTTP handler for the PATCH /api/v2/notificationRule/:id route.
func (h *NotificationRuleHandler) handlePatchNotificationRule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        req, err := decodePatchNotificationRuleRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">nr, err := h.NotificationRuleStore.PatchNotificationRule(ctx, req.ID, req.Update)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: nr.GetID(), ResourceType: influxdb.NotificationRuleResourceType})
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">h.log.Debug("Notification rule patch", zap.String("notificationRule", fmt.Sprint(nr)))

        res, err := h.newNotificationRuleResponse(ctx, nr, labels)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">if err := encodeResponse(ctx, w, http.StatusOK, res); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func (h *NotificationRuleHandler) handleDeleteNotificationRule(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        i, err := decodeGetNotificationRuleRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">if err = h.NotificationRuleStore.DeleteNotificationRule(ctx, i); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">h.log.Debug("Notification rule deleted", zap.String("notificationRuleID", fmt.Sprint(i)))

        w.WriteHeader(http.StatusNoContent)</span>
}

// NotificationRuleService is an http client that implements the NotificationRuleStore interface
type NotificationRuleService struct {
        Client *httpc.Client
}

// NewNotificationRuleService wraps an httpc.Client in a NotificationRuleService
func NewNotificationRuleService(client *httpc.Client) *NotificationRuleService <span class="cov0" title="0">{
        return &amp;NotificationRuleService{
                Client: client,
        }
}</span>

type notificationRuleCreateEncoder struct {
        nrc influxdb.NotificationRuleCreate
}

func (n notificationRuleCreateEncoder) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        b, err := n.nrc.NotificationRule.MarshalJSON()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var v map[string]interface{}
        err = json.Unmarshal(b, &amp;v)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">v["status"] = n.nrc.Status
        return json.Marshal(v)</span>
}

type notificationRuleDecoder struct {
        rule influxdb.NotificationRule
}

func (n *notificationRuleDecoder) UnmarshalJSON(b []byte) error <span class="cov0" title="0">{
        newRule, err := rule.UnmarshalJSON(b)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">n.rule = newRule
        return nil</span>
}

// CreateNotificationRule creates a new NotificationRule from a NotificationRuleCreate
// the Status on the NotificationRuleCreate is used to determine the status (active/inactive) of the associated Task
func (s *NotificationRuleService) CreateNotificationRule(ctx context.Context, nr influxdb.NotificationRuleCreate, userID platform.ID) error <span class="cov0" title="0">{
        var resp notificationRuleDecoder
        err := s.Client.
                PostJSON(notificationRuleCreateEncoder{nrc: nr}, prefixNotificationRules).
                DecodeJSON(&amp;resp).
                Do(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">nr.NotificationRule.SetID(resp.rule.GetID())
        nr.NotificationRule.SetOrgID(resp.rule.GetOrgID())

        return nil</span>
}

// FindNotificationRuleByID finds and returns one Notification Rule with a matching ID
func (s *NotificationRuleService) FindNotificationRuleByID(ctx context.Context, id platform.ID) (influxdb.NotificationRule, error) <span class="cov0" title="0">{
        var resp notificationRuleResponse
        err := s.Client.
                Get(getNotificationRulesIDPath(id)).
                DecodeJSON(&amp;resp).
                Do(ctx)

        return resp.NotificationRule, err
}</span>

// FindNotificationRules returns a list of notification rules that match filter and the total count of matching notification rules.
// Additional options provide pagination &amp; sorting.
func (s *NotificationRuleService) FindNotificationRules(ctx context.Context, filter influxdb.NotificationRuleFilter, opt ...influxdb.FindOptions) ([]influxdb.NotificationRule, int, error) <span class="cov0" title="0">{
        var params = influxdb.FindOptionParams(opt...)
        if filter.OrgID != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"orgID", filter.OrgID.String()})
        }</span>

        <span class="cov0" title="0">if filter.Organization != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"org", *filter.Organization})
        }</span>

        <span class="cov0" title="0">if len(filter.Tags) != 0 </span><span class="cov0" title="0">{
                // loop over tags and append a string of format key:value for each
                for _, tag := range filter.Tags </span><span class="cov0" title="0">{
                        keyvalue := fmt.Sprintf("%s:%s", tag.Key, tag.Value)
                        params = append(params, [2]string{"tag", keyvalue})
                }</span>
        }

        <span class="cov0" title="0">var resp struct {
                NotificationRules []notificationRuleDecoder
        }
        err := s.Client.
                Get(prefixNotificationRules).
                QueryParams(params...).
                DecodeJSON(&amp;resp).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">var rules []influxdb.NotificationRule
        for _, r := range resp.NotificationRules </span><span class="cov0" title="0">{
                rules = append(rules, r.rule)
        }</span>

        <span class="cov0" title="0">return rules, len(rules), nil</span>
}

// UpdateNotificationRule updates a single notification rule.
// Returns the new notification rule after update.
func (s *NotificationRuleService) UpdateNotificationRule(ctx context.Context, id platform.ID, nr influxdb.NotificationRuleCreate, userID platform.ID) (influxdb.NotificationRule, error) <span class="cov0" title="0">{
        var resp notificationRuleDecoder
        err := s.Client.
                PutJSON(notificationRuleCreateEncoder{nrc: nr}, getNotificationRulesIDPath(id)).
                DecodeJSON(&amp;resp).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.rule, nil</span>
}

// PatchNotificationRule updates a single  notification rule with changeset.
// Returns the new notification rule state after update.
func (s *NotificationRuleService) PatchNotificationRule(ctx context.Context, id platform.ID, upd influxdb.NotificationRuleUpdate) (influxdb.NotificationRule, error) <span class="cov0" title="0">{
        var resp notificationRuleDecoder
        err := s.Client.
                PatchJSON(&amp;upd, getNotificationRulesIDPath(id)).
                DecodeJSON(&amp;resp).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.rule, nil</span>
}

// DeleteNotificationRule removes a notification rule by ID.
func (s *NotificationRuleService) DeleteNotificationRule(ctx context.Context, id platform.ID) error <span class="cov0" title="0">{
        return s.Client.
                Delete(getNotificationRulesIDPath(id)).
                Do(ctx)
}</span>

func getNotificationRulesIDPath(id platform.ID) string <span class="cov0" title="0">{
        return path.Join(prefixNotificationRules, id.String())
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package http

import (
        "net/http"
        "strings"

        "github.com/influxdata/influxdb/v2/http/legacy"
        "github.com/influxdata/influxdb/v2/kit/feature"
        kithttp "github.com/influxdata/influxdb/v2/kit/transport/http"
        "github.com/influxdata/influxdb/v2/static"
)

// PlatformHandler is a collection of all the service handlers.
type PlatformHandler struct {
        AssetHandler  http.Handler
        DocsHandler   http.HandlerFunc
        APIHandler    http.Handler
        LegacyHandler http.Handler
}

// NewPlatformHandler returns a platform handler that serves the API and associated assets.
func NewPlatformHandler(b *APIBackend, opts ...APIHandlerOptFn) *PlatformHandler <span class="cov0" title="0">{
        h := NewAuthenticationHandler(b.Logger, b.HTTPErrorHandler)
        h.Handler = feature.NewHandler(b.Logger, b.Flagger, feature.Flags(), NewAPIHandler(b, opts...))
        h.AuthorizationService = b.AuthorizationService
        h.SessionService = b.SessionService
        h.SessionRenewDisabled = b.SessionRenewDisabled
        h.UserService = b.UserService

        h.RegisterNoAuthRoute("GET", "/api/v2")
        h.RegisterNoAuthRoute("POST", "/api/v2/signin")
        h.RegisterNoAuthRoute("POST", "/api/v2/signout")
        h.RegisterNoAuthRoute("POST", "/api/v2/setup")
        h.RegisterNoAuthRoute("GET", "/api/v2/setup")
        h.RegisterNoAuthRoute("GET", "/api/v2/swagger.json")

        assetHandler := static.NewAssetHandler(b.AssetsPath)
        if b.UIDisabled </span><span class="cov0" title="0">{
                b.Logger.Debug("http server running with UI disabled")
                assetHandler = http.NotFoundHandler()
        }</span>

        <span class="cov0" title="0">wrappedHandler := kithttp.SetCORS(h)
        wrappedHandler = kithttp.SkipOptions(wrappedHandler)

        legacyBackend := newLegacyBackend(b)
        lh := newLegacyHandler(legacyBackend, *legacy.NewHandlerConfig())

        return &amp;PlatformHandler{
                AssetHandler:  assetHandler,
                DocsHandler:   Redoc("/api/v2/swagger.json"),
                APIHandler:    wrappedHandler,
                LegacyHandler: legacy.NewInflux1xAuthenticationHandler(lh, b.AuthorizerV1, b.HTTPErrorHandler),
        }</span>
}

// ServeHTTP delegates a request to the appropriate subhandler.
func (h *PlatformHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // TODO(affo): change this to be mounted prefixes: https://github.com/influxdata/idpe/issues/6689.
        if r.URL.Path == "/write" ||
                r.URL.Path == "/query" ||
                r.URL.Path == "/ping" </span><span class="cov0" title="0">{
                h.LegacyHandler.ServeHTTP(w, r)
                return
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(r.URL.Path, "/docs") </span><span class="cov0" title="0">{
                h.DocsHandler.ServeHTTP(w, r)
                return
        }</span>

        // Serve the static UI assets for any basepath that does not start with
        // addressable parts of the platform API.
        <span class="cov0" title="0">if !strings.HasPrefix(r.URL.Path, "/v1") &amp;&amp;
                !strings.HasPrefix(r.URL.Path, "/api/v2") &amp;&amp;
                !strings.HasPrefix(r.URL.Path, "/private/") </span><span class="cov0" title="0">{
                h.AssetHandler.ServeHTTP(w, r)
                return
        }</span>

        <span class="cov0" title="0">h.APIHandler.ServeHTTP(w, r)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package http

import (
        "net/http"
)

var _ http.Handler = &amp;proxyHandler{}

// withFeatureProxy wraps an HTTP handler in a proxyHandler
func withFeatureProxy(proxy FeatureProxyHandler, h http.Handler) *proxyHandler <span class="cov8" title="1">{
        if proxy == nil </span><span class="cov8" title="1">{
                proxy = &amp;NoopProxyHandler{}
        }</span>
        <span class="cov8" title="1">return &amp;proxyHandler{
                proxy:   proxy,
                handler: h,
        }</span>
}

// proxyHandler is a wrapper around an http.Handler that conditionally forwards
// a request to another HTTP backend using a proxy. If the proxy doesn't decide
// to forward the request, we fall-back to our normal http.Handler behavior.
type proxyHandler struct {
        proxy   FeatureProxyHandler
        handler http.Handler
}

// ServeHTTP implements http.Handler interface. It first
func (h *proxyHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if h.proxy.Do(w, r) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">h.handler.ServeHTTP(w, r)</span>
}

// FeatureProxyHandler is an HTTP proxy that conditionally forwards requests to
// another backend.
type FeatureProxyHandler interface {
        Do(w http.ResponseWriter, r *http.Request) bool
}

// NoopProxyHandler is a no-op FeatureProxyHandler. It should be used if
// no feature-flag driven proxying is necessary.
type NoopProxyHandler struct{}

// Do implements FeatureProxyHandler.
func (h *NoopProxyHandler) Do(http.ResponseWriter, *http.Request) bool <span class="cov8" title="1">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package http

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "io/ioutil"
        "mime"
        "net/http"
        "regexp"
        "strconv"
        "time"
        "unicode/utf8"

        "github.com/influxdata/flux"
        "github.com/influxdata/flux/ast"
        "github.com/influxdata/flux/csv"
        "github.com/influxdata/flux/lang"
        "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/jsonweb"
        "github.com/influxdata/influxdb/v2/query"
        "github.com/influxdata/influxdb/v2/query/fluxlang"
        transpiler "github.com/influxdata/influxdb/v2/query/influxql"
        "github.com/influxdata/influxql"
)

// QueryRequest is a flux query request.
type QueryRequest struct {
        Type  string `json:"type"`
        Query string `json:"query"`

        // Flux fields
        Extern  json.RawMessage `json:"extern,omitempty"`
        AST     json.RawMessage `json:"ast,omitempty"`
        Dialect QueryDialect    `json:"dialect"`
        Now     time.Time       `json:"now"`

        // InfluxQL fields
        Bucket string `json:"bucket,omitempty"`

        Org *influxdb.Organization `json:"-"`

        // PreferNoContent specifies if the Response to this request should
        // contain any result. This is done for avoiding unnecessary
        // bandwidth consumption in certain cases. For example, when the
        // query produces side effects and the results do not matter. E.g.:
        //         from(...) |&gt; ... |&gt; to()
        // For example, tasks do not use the results of queries, but only
        // care about their side effects.
        // To obtain a QueryRequest with no result, add the header
        // `Prefer: return-no-content` to the HTTP request.
        PreferNoContent bool
        // PreferNoContentWithError is the same as above, but it forces the
        // Response to contain an error if that is a Flux runtime error encoded
        // in the response body.
        // To obtain a QueryRequest with no result but runtime errors,
        // add the header `Prefer: return-no-content-with-error` to the HTTP request.
        PreferNoContentWithError bool
}

// QueryDialect is the formatting options for the query response.
type QueryDialect struct {
        Header         *bool    `json:"header"`
        Delimiter      string   `json:"delimiter"`
        CommentPrefix  string   `json:"commentPrefix"`
        DateTimeFormat string   `json:"dateTimeFormat"`
        Annotations    []string `json:"annotations"`
}

// WithDefaults adds default values to the request.
func (r QueryRequest) WithDefaults() QueryRequest <span class="cov8" title="1">{
        if r.Type == "" </span><span class="cov8" title="1">{
                r.Type = "flux"
        }</span>
        <span class="cov8" title="1">if r.Dialect.Delimiter == "" </span><span class="cov8" title="1">{
                r.Dialect.Delimiter = ","
        }</span>
        <span class="cov8" title="1">if r.Dialect.DateTimeFormat == "" </span><span class="cov8" title="1">{
                r.Dialect.DateTimeFormat = "RFC3339"
        }</span>
        <span class="cov8" title="1">if r.Dialect.Header == nil </span><span class="cov8" title="1">{
                header := true
                r.Dialect.Header = &amp;header
        }</span>
        <span class="cov8" title="1">return r</span>
}

// Validate checks the query request and returns an error if the request is invalid.
func (r QueryRequest) Validate() error <span class="cov8" title="1">{
        if r.Query == "" &amp;&amp; r.AST == nil </span><span class="cov8" title="1">{
                return errors.New(`request body requires either query or AST`)
        }</span>

        <span class="cov8" title="1">if r.Type != "flux" &amp;&amp; r.Type != "influxql" </span><span class="cov8" title="1">{
                return fmt.Errorf(`unknown query type: %s`, r.Type)
        }</span>

        <span class="cov8" title="1">if r.Type == "influxql" &amp;&amp; r.Bucket == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("bucket parameter is required for influxql queries")
        }</span>

        <span class="cov8" title="1">if len(r.Dialect.CommentPrefix) &gt; 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid dialect comment prefix: must be length 0 or 1")
        }</span>

        <span class="cov8" title="1">if len(r.Dialect.Delimiter) != 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid dialect delimeter: must be length 1")
        }</span>

        <span class="cov8" title="1">rune, size := utf8.DecodeRuneInString(r.Dialect.Delimiter)
        if rune == utf8.RuneError &amp;&amp; size == 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid dialect delimeter character")
        }</span>

        <span class="cov8" title="1">for _, a := range r.Dialect.Annotations </span><span class="cov8" title="1">{
                switch a </span>{
                case "group", "datatype", "default":<span class="cov0" title="0"></span>
                default:<span class="cov8" title="1">
                        return fmt.Errorf(`unknown dialect annotation type: %s`, a)</span>
                }
        }

        <span class="cov8" title="1">switch r.Dialect.DateTimeFormat </span>{
        case "RFC3339", "RFC3339Nano":<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                return fmt.Errorf(`unknown dialect date time format: %s`, r.Dialect.DateTimeFormat)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// QueryAnalysis is a structured response of errors.
type QueryAnalysis struct {
        Errors []queryParseError `json:"errors"`
}

type queryParseError struct {
        Line      int    `json:"line"`
        Column    int    `json:"column"`
        Character int    `json:"character"`
        Message   string `json:"message"`
}

// Analyze attempts to parse the query request and returns any errors
// encountered in a structured way.
func (r QueryRequest) Analyze(l fluxlang.FluxLanguageService) (*QueryAnalysis, error) <span class="cov0" title="0">{
        switch r.Type </span>{
        case "flux":<span class="cov0" title="0">
                return r.analyzeFluxQuery(l)</span>
        case "influxql":<span class="cov0" title="0">
                return r.analyzeInfluxQLQuery()</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("unknown query request type %s", r.Type)</span>
}

func (r QueryRequest) analyzeFluxQuery(l fluxlang.FluxLanguageService) (*QueryAnalysis, error) <span class="cov0" title="0">{
        a := &amp;QueryAnalysis{}
        pkg, err := query.Parse(l, r.Query)
        if pkg == nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">errCount := ast.Check(pkg)
        if errCount == 0 </span><span class="cov0" title="0">{
                a.Errors = []queryParseError{}
                return a, nil
        }</span>
        <span class="cov0" title="0">a.Errors = make([]queryParseError, 0, errCount)
        ast.Walk(ast.CreateVisitor(func(node ast.Node) </span><span class="cov0" title="0">{
                loc := node.Location()
                for _, err := range node.Errs() </span><span class="cov0" title="0">{
                        a.Errors = append(a.Errors, queryParseError{
                                Line:    loc.Start.Line,
                                Column:  loc.Start.Column,
                                Message: err.Msg,
                        })
                }</span>
        }), pkg)
        <span class="cov0" title="0">return a, nil</span>
}

func (r QueryRequest) analyzeInfluxQLQuery() (*QueryAnalysis, error) <span class="cov0" title="0">{
        a := &amp;QueryAnalysis{}
        _, err := influxql.ParseQuery(r.Query)
        if err == nil </span><span class="cov0" title="0">{
                a.Errors = []queryParseError{}
                return a, nil
        }</span>

        <span class="cov0" title="0">ms := influxqlParseErrorRE.FindAllStringSubmatch(err.Error(), -1)
        a.Errors = make([]queryParseError, 0, len(ms))
        for _, m := range ms </span><span class="cov0" title="0">{
                if len(m) != 4 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("influxql query error is not formatted as expected: got %d matches expected 4", len(m))
                }</span>
                <span class="cov0" title="0">msg := m[1]
                lineStr := m[2]
                line, err := strconv.Atoi(lineStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse line number from error mesage: %s -&gt; %v", lineStr, err)
                }</span>
                <span class="cov0" title="0">charStr := m[3]
                char, err := strconv.Atoi(charStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse character number from error mesage: %s -&gt; %v", charStr, err)
                }</span>

                <span class="cov0" title="0">a.Errors = append(a.Errors, queryParseError{
                        Line:      line,
                        Column:    columnFromCharacter(r.Query, char),
                        Character: char,
                        Message:   msg,
                })</span>
        }

        <span class="cov0" title="0">return a, nil</span>
}

func columnFromCharacter(q string, char int) int <span class="cov0" title="0">{
        col := 0
        for i, c := range q </span><span class="cov0" title="0">{
                if c == '\n' </span><span class="cov0" title="0">{
                        col = 0
                }</span>

                <span class="cov0" title="0">if i == char </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">col++</span>
        }

        <span class="cov0" title="0">return col</span>
}

var influxqlParseErrorRE = regexp.MustCompile(`^(.+) at line (\d+), char (\d+)$`)

// ProxyRequest returns a request to proxy from the flux.
func (r QueryRequest) ProxyRequest() (*query.ProxyRequest, error) <span class="cov8" title="1">{
        return r.proxyRequest(time.Now)
}</span>

func (r QueryRequest) proxyRequest(now func() time.Time) (*query.ProxyRequest, error) <span class="cov8" title="1">{
        if err := r.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">n := r.Now
        if n.IsZero() </span><span class="cov8" title="1">{
                n = now()
        }</span>

        // Query is preferred over AST
        <span class="cov8" title="1">var compiler flux.Compiler
        if r.Query != "" </span><span class="cov8" title="1">{
                switch r.Type </span>{
                case "influxql":<span class="cov0" title="0">
                        compiler = &amp;transpiler.Compiler{
                                Now:    &amp;n,
                                Query:  r.Query,
                                Bucket: r.Bucket,
                        }</span>
                case "flux":<span class="cov8" title="1">
                        fallthrough</span>
                default:<span class="cov8" title="1">
                        compiler = lang.FluxCompiler{
                                Now:    n,
                                Extern: r.Extern,
                                Query:  r.Query,
                        }</span>
                }
        } else<span class="cov8" title="1"> if len(r.AST) &gt; 0 </span><span class="cov8" title="1">{
                c := lang.ASTCompiler{
                        Extern: r.Extern,
                        AST:    r.AST,
                        Now:    n,
                }
                compiler = c
        }</span>

        <span class="cov8" title="1">delimiter, _ := utf8.DecodeRuneInString(r.Dialect.Delimiter)

        noHeader := false
        if r.Dialect.Header != nil </span><span class="cov8" title="1">{
                noHeader = !*r.Dialect.Header
        }</span>

        <span class="cov8" title="1">var dialect flux.Dialect
        if r.PreferNoContent </span><span class="cov0" title="0">{
                dialect = &amp;query.NoContentDialect{}
        }</span> else<span class="cov8" title="1"> {
                if r.Type == "influxql" </span><span class="cov0" title="0">{
                        // Use default transpiler dialect
                        dialect = &amp;transpiler.Dialect{}
                }</span> else<span class="cov8" title="1"> {
                        // TODO(nathanielc): Use commentPrefix and dateTimeFormat
                        // once they are supported.
                        encConfig := csv.ResultEncoderConfig{
                                NoHeader:    noHeader,
                                Delimiter:   delimiter,
                                Annotations: r.Dialect.Annotations,
                        }
                        if r.PreferNoContentWithError </span><span class="cov0" title="0">{
                                dialect = &amp;query.NoContentWithErrorDialect{
                                        ResultEncoderConfig: encConfig,
                                }
                        }</span> else<span class="cov8" title="1"> {
                                dialect = &amp;csv.Dialect{
                                        ResultEncoderConfig: encConfig,
                                }
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;query.ProxyRequest{
                Request: query.Request{
                        OrganizationID: r.Org.ID,
                        Compiler:       compiler,
                },
                Dialect: dialect,
        }, nil</span>
}

// QueryRequestFromProxyRequest converts a query.ProxyRequest into a QueryRequest.
// The ProxyRequest must contain supported compilers and dialects otherwise an error occurs.
func QueryRequestFromProxyRequest(req *query.ProxyRequest) (*QueryRequest, error) <span class="cov8" title="1">{
        qr := new(QueryRequest)
        switch c := req.Request.Compiler.(type) </span>{
        case lang.FluxCompiler:<span class="cov8" title="1">
                qr.Type = "flux"
                qr.Query = c.Query
                qr.Extern = c.Extern
                qr.Now = c.Now</span>
        case lang.ASTCompiler:<span class="cov8" title="1">
                qr.Type = "flux"
                qr.AST = c.AST
                qr.Now = c.Now</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported compiler %T", c)</span>
        }
        <span class="cov8" title="1">switch d := req.Dialect.(type) </span>{
        case *csv.Dialect:<span class="cov8" title="1">
                var header = !d.ResultEncoderConfig.NoHeader
                qr.Dialect.Header = &amp;header
                qr.Dialect.Delimiter = string(d.ResultEncoderConfig.Delimiter)
                qr.Dialect.CommentPrefix = "#"
                qr.Dialect.DateTimeFormat = "RFC3339"
                qr.Dialect.Annotations = d.ResultEncoderConfig.Annotations</span>
        case *query.NoContentDialect:<span class="cov8" title="1">
                qr.PreferNoContent = true</span>
        case *query.NoContentWithErrorDialect:<span class="cov0" title="0">
                qr.PreferNoContentWithError = true</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported dialect %T", d)</span>
        }
        <span class="cov8" title="1">return qr, nil</span>
}

const fluxContentType = "application/vnd.flux"

func decodeQueryRequest(ctx context.Context, r *http.Request, svc influxdb.OrganizationService) (*QueryRequest, int, error) <span class="cov8" title="1">{
        var req QueryRequest
        body := &amp;countReader{Reader: r.Body}

        var contentType = "application/json"
        if ct := r.Header.Get("Content-Type"); ct != "" </span><span class="cov8" title="1">{
                contentType = ct
        }</span>
        <span class="cov8" title="1">mt, _, err := mime.ParseMediaType(contentType)
        if err != nil </span><span class="cov0" title="0">{
                return nil, body.bytesRead, err
        }</span>
        <span class="cov8" title="1">switch mt </span>{
        case fluxContentType:<span class="cov8" title="1">
                octets, err := ioutil.ReadAll(body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, body.bytesRead, err
                }</span>
                <span class="cov8" title="1">req.Query = string(octets)</span>
        case "application/json":<span class="cov8" title="1">
                fallthrough</span>
        default:<span class="cov8" title="1">
                if err := json.NewDecoder(body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                        return nil, body.bytesRead,
                                fmt.Errorf("failed parsing request body as JSON; if sending a raw Flux script, set 'Content-Type: %s' in your request headers: %w", fluxContentType, err)
                }</span>
        }

        <span class="cov8" title="1">switch hv := r.Header.Get(query.PreferHeaderKey); hv </span>{
        case query.PreferNoContentHeaderValue:<span class="cov0" title="0">
                req.PreferNoContent = true</span>
        case query.PreferNoContentWErrHeaderValue:<span class="cov0" title="0">
                req.PreferNoContentWithError = true</span>
        }

        <span class="cov8" title="1">req = req.WithDefaults()
        if err := req.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, body.bytesRead, err
        }</span>

        <span class="cov8" title="1">req.Org, err = queryOrganization(ctx, r, svc)
        return &amp;req, body.bytesRead, err</span>
}

type countReader struct {
        bytesRead int
        io.Reader
}

func (r *countReader) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        n, err = r.Reader.Read(p)
        r.bytesRead += n
        return n, err
}</span>

func decodeProxyQueryRequest(ctx context.Context, r *http.Request, auth influxdb.Authorizer, svc influxdb.OrganizationService) (*query.ProxyRequest, int, error) <span class="cov8" title="1">{
        req, n, err := decodeQueryRequest(ctx, r, svc)
        if err != nil </span><span class="cov8" title="1">{
                return nil, n, err
        }</span>

        <span class="cov8" title="1">pr, err := req.ProxyRequest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, n, err
        }</span>

        <span class="cov8" title="1">var token *influxdb.Authorization
        switch a := auth.(type) </span>{
        case *influxdb.Authorization:<span class="cov8" title="1">
                token = a</span>
        case *influxdb.Session:<span class="cov0" title="0">
                token = a.EphemeralAuth(req.Org.ID)</span>
        case *jsonweb.Token:<span class="cov0" title="0">
                token = a.EphemeralAuth(req.Org.ID)</span>
        default:<span class="cov0" title="0">
                return pr, n, influxdb.ErrAuthorizerNotSupported</span>
        }

        <span class="cov8" title="1">pr.Request.Authorization = token
        return pr, n, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package http

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "net/url"
        "sort"
        "time"

        "github.com/NYTimes/gziphandler"
        "github.com/influxdata/flux"
        "github.com/influxdata/flux/ast"
        "github.com/influxdata/flux/csv"
        "github.com/influxdata/flux/iocounter"
        "github.com/influxdata/flux/lang"
        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        pcontext "github.com/influxdata/influxdb/v2/context"
        "github.com/influxdata/influxdb/v2/http/metric"
        "github.com/influxdata/influxdb/v2/kit/check"
        "github.com/influxdata/influxdb/v2/kit/feature"
        "github.com/influxdata/influxdb/v2/kit/platform"
        errors2 "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/kit/tracing"
        kithttp "github.com/influxdata/influxdb/v2/kit/transport/http"
        "github.com/influxdata/influxdb/v2/logger"
        "github.com/influxdata/influxdb/v2/query"
        "github.com/influxdata/influxdb/v2/query/fluxlang"
        "github.com/influxdata/influxdb/v2/query/influxql"
        "github.com/pkg/errors"
        prom "github.com/prometheus/client_golang/prometheus"
        "go.uber.org/zap"
)

const (
        prefixQuery   = "/api/v2/query"
        traceIDHeader = "Trace-Id"
)

// FluxBackend is all services and associated parameters required to construct
// the FluxHandler.
type FluxBackend struct {
        errors2.HTTPErrorHandler
        log                *zap.Logger
        FluxLogEnabled     bool
        QueryEventRecorder metric.EventRecorder

        AlgoWProxy          FeatureProxyHandler
        OrganizationService influxdb.OrganizationService
        ProxyQueryService   query.ProxyQueryService
        FluxLanguageService fluxlang.FluxLanguageService
        Flagger             feature.Flagger
}

// NewFluxBackend returns a new instance of FluxBackend.
func NewFluxBackend(log *zap.Logger, b *APIBackend) *FluxBackend <span class="cov8" title="1">{
        return &amp;FluxBackend{
                HTTPErrorHandler:   b.HTTPErrorHandler,
                log:                log,
                FluxLogEnabled:     b.FluxLogEnabled,
                QueryEventRecorder: b.QueryEventRecorder,
                AlgoWProxy:         b.AlgoWProxy,
                ProxyQueryService: routingQueryService{
                        InfluxQLService: b.InfluxQLService,
                        DefaultService:  b.FluxService,
                },
                OrganizationService: b.OrganizationService,
                FluxLanguageService: b.FluxLanguageService,
                Flagger:             b.Flagger,
        }
}</span>

// HTTPDialect is an encoding dialect that can write metadata to HTTP headers
type HTTPDialect interface {
        SetHeaders(w http.ResponseWriter)
}

// FluxHandler implements handling flux queries.
type FluxHandler struct {
        *httprouter.Router
        errors2.HTTPErrorHandler
        log            *zap.Logger
        FluxLogEnabled bool

        Now                 func() time.Time
        OrganizationService influxdb.OrganizationService
        ProxyQueryService   query.ProxyQueryService
        FluxLanguageService fluxlang.FluxLanguageService

        EventRecorder metric.EventRecorder

        Flagger feature.Flagger
}

// Prefix provides the route prefix.
func (*FluxHandler) Prefix() string <span class="cov0" title="0">{
        return prefixQuery
}</span>

// NewFluxHandler returns a new handler at /api/v2/query for flux queries.
func NewFluxHandler(log *zap.Logger, b *FluxBackend) *FluxHandler <span class="cov8" title="1">{
        h := &amp;FluxHandler{
                Router:           NewRouter(b.HTTPErrorHandler),
                Now:              time.Now,
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,
                FluxLogEnabled:   b.FluxLogEnabled,

                ProxyQueryService:   b.ProxyQueryService,
                OrganizationService: b.OrganizationService,
                EventRecorder:       b.QueryEventRecorder,
                FluxLanguageService: b.FluxLanguageService,
                Flagger:             b.Flagger,
        }

        // query reponses can optionally be gzip encoded
        qh := gziphandler.GzipHandler(http.HandlerFunc(h.handleQuery))
        h.Handler("POST", prefixQuery, withFeatureProxy(b.AlgoWProxy, qh))
        h.Handler("POST", "/api/v2/query/ast", withFeatureProxy(b.AlgoWProxy, http.HandlerFunc(h.postFluxAST)))
        h.Handler("POST", "/api/v2/query/analyze", withFeatureProxy(b.AlgoWProxy, http.HandlerFunc(h.postQueryAnalyze)))
        h.Handler("GET", "/api/v2/query/suggestions", withFeatureProxy(b.AlgoWProxy, http.HandlerFunc(h.getFluxSuggestions)))
        h.Handler("GET", "/api/v2/query/suggestions/:name", withFeatureProxy(b.AlgoWProxy, http.HandlerFunc(h.getFluxSuggestion)))
        return h
}</span>

func (h *FluxHandler) handleQuery(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        const op = "http/handlePostQuery"
        span, r := tracing.ExtractFromHTTPRequest(r, "FluxHandler")
        defer span.Finish()

        ctx := r.Context()
        log := h.log.With(logger.TraceFields(ctx)...)
        if id, _, found := tracing.InfoFromContext(ctx); found </span><span class="cov8" title="1">{
                w.Header().Set(traceIDHeader, id)
        }</span>

        // TODO(desa): I really don't like how we're recording the usage metrics here
        // Ideally this will be moved when we solve https://github.com/influxdata/influxdb/issues/13403
        <span class="cov8" title="1">var orgID platform.ID
        var requestBytes int
        sw := kithttp.NewStatusResponseWriter(w)
        w = sw
        defer func() </span><span class="cov8" title="1">{
                h.EventRecorder.Record(ctx, metric.Event{
                        OrgID:         orgID,
                        Endpoint:      r.URL.Path, // This should be sufficient for the time being as it should only be single endpoint.
                        RequestBytes:  requestBytes,
                        ResponseBytes: sw.ResponseBytes(),
                        Status:        sw.Code(),
                })
        }</span>()

        <span class="cov8" title="1">a, err := pcontext.GetAuthorizer(ctx)
        if err != nil </span><span class="cov8" title="1">{
                err := &amp;errors2.Error{
                        Code: errors2.EUnauthorized,
                        Msg:  "authorization is invalid or missing in the query request",
                        Op:   op,
                        Err:  err,
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">req, n, err := decodeProxyQueryRequest(ctx, r, a, h.OrganizationService)
        if err != nil &amp;&amp; err != influxdb.ErrAuthorizerNotSupported </span><span class="cov8" title="1">{
                err := &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "failed to decode request body",
                        Op:   op,
                        Err:  err,
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">req.Request.Source = r.Header.Get("User-Agent")
        orgID = req.Request.OrganizationID
        requestBytes = n

        // Transform the context into one with the request's authorization.
        ctx = pcontext.SetAuthorizer(ctx, req.Request.Authorization)
        if h.Flagger != nil </span><span class="cov8" title="1">{
                ctx, _ = feature.Annotate(ctx, h.Flagger)
        }</span>

        <span class="cov8" title="1">hd, ok := req.Dialect.(HTTPDialect)
        if !ok </span><span class="cov0" title="0">{
                err := &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  fmt.Sprintf("unsupported dialect over HTTP: %T", req.Dialect),
                        Op:   op,
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">hd.SetHeaders(w)

        cw := iocounter.Writer{Writer: w}
        stats, err := h.ProxyQueryService.Query(ctx, &amp;cw, req)
        if err != nil </span><span class="cov8" title="1">{
                if cw.Count() == 0 </span><span class="cov8" title="1">{
                        // Only record the error headers IFF nothing has been written to w.
                        h.HandleHTTPError(ctx, err, w)
                        return
                }</span>
                <span class="cov0" title="0">_ = tracing.LogError(span, err)
                log.Info("Error writing response to client",
                        zap.String("handler", "flux"),
                        zap.Error(err),
                )</span>
        }

        // Detailed logging for flux queries if enabled
        <span class="cov8" title="1">if h.FluxLogEnabled </span><span class="cov0" title="0">{
                h.logFluxQuery(cw.Count(), stats, req.Request.Compiler, err)
        }</span>

}

func (h *FluxHandler) logFluxQuery(n int64, stats flux.Statistics, compiler flux.Compiler, err error) <span class="cov0" title="0">{
        var q string
        c, ok := compiler.(lang.FluxCompiler)
        if !ok </span><span class="cov0" title="0">{
                q = "unknown"
        }</span>
        <span class="cov0" title="0">q = c.Query

        h.log.Info("Executed Flux query",
                zap.String("compiler_type", string(compiler.CompilerType())),
                zap.Int64("response_size", n),
                zap.String("query", q),
                zap.Error(err),
                zap.Duration("stat_total_duration", stats.TotalDuration),
                zap.Duration("stat_compile_duration", stats.CompileDuration),
                zap.Duration("stat_execute_duration", stats.ExecuteDuration),
                zap.Int64("stat_max_allocated", stats.MaxAllocated),
                zap.Int64("stat_total_allocated", stats.TotalAllocated),
        )</span>
}

type langRequest struct {
        Query string `json:"query"`
}

type postFluxASTResponse struct {
        AST *ast.Package `json:"ast"`
}

// postFluxAST returns a flux AST for provided flux string
func (h *FluxHandler) postFluxAST(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        span, r := tracing.ExtractFromHTTPRequest(r, "FluxHandler")
        defer span.Finish()

        var request langRequest
        ctx := r.Context()

        err := json.NewDecoder(r.Body).Decode(&amp;request)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "invalid json",
                        Err:  err,
                }, w)
                return
        }</span>

        <span class="cov8" title="1">pkg, err := query.Parse(h.FluxLanguageService, request.Query)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "invalid AST",
                        Err:  err,
                }, w)
                return
        }</span>

        <span class="cov8" title="1">res := postFluxASTResponse{
                AST: pkg,
        }

        if err := encodeResponse(ctx, w, http.StatusOK, res); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

// postQueryAnalyze parses a query and returns any query errors.
func (h *FluxHandler) postQueryAnalyze(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        span, r := tracing.ExtractFromHTTPRequest(r, "FluxHandler")
        defer span.Finish()

        ctx := r.Context()

        var req QueryRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "invalid json",
                        Err:  err,
                }, w)
                return
        }</span>

        <span class="cov0" title="0">a, err := req.Analyze(h.FluxLanguageService)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">if err := encodeResponse(ctx, w, http.StatusOK, a); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

// fluxParams contain flux funciton parameters as defined by the semantic graph
type fluxParams map[string]string

// suggestionResponse provides the parameters available for a given Flux function
type suggestionResponse struct {
        Name   string     `json:"name"`
        Params fluxParams `json:"params"`
}

// suggestionsResponse provides a list of available Flux functions
type suggestionsResponse struct {
        Functions []suggestionResponse `json:"funcs"`
}

// getFluxSuggestions returns a list of available Flux functions for the Flux Builder
func (h *FluxHandler) getFluxSuggestions(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        span, r := tracing.ExtractFromHTTPRequest(r, "FluxHandler")
        defer span.Finish()

        ctx := r.Context()
        completer := h.FluxLanguageService.Completer()
        names := completer.FunctionNames()
        var functions []suggestionResponse
        for _, name := range names </span><span class="cov0" title="0">{
                suggestion, err := completer.FunctionSuggestion(name)
                if err != nil </span><span class="cov0" title="0">{
                        h.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov0" title="0">filteredParams := make(fluxParams)
                for key, value := range suggestion.Params </span><span class="cov0" title="0">{
                        if key == "table" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">filteredParams[key] = value</span>
                }

                <span class="cov0" title="0">functions = append(functions, suggestionResponse{
                        Name:   name,
                        Params: filteredParams,
                })</span>
        }
        <span class="cov0" title="0">res := suggestionsResponse{Functions: functions}

        if err := encodeResponse(ctx, w, http.StatusOK, res); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

// getFluxSuggestion returns the function parameters for the requested function
func (h *FluxHandler) getFluxSuggestion(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        span, r := tracing.ExtractFromHTTPRequest(r, "FluxHandler")
        defer span.Finish()

        ctx := r.Context()
        name := httprouter.ParamsFromContext(ctx).ByName("name")
        completer := h.FluxLanguageService.Completer()

        suggestion, err := completer.FunctionSuggestion(name)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">res := suggestionResponse{Name: name, Params: suggestion.Params}
        if err := encodeResponse(ctx, w, http.StatusOK, res); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

// PrometheusCollectors satisifies the prom.PrometheusCollector interface.
func (h *FluxHandler) PrometheusCollectors() []prom.Collector <span class="cov0" title="0">{
        // TODO: gather and return relevant metrics.
        return nil
}</span>

var _ query.ProxyQueryService = (*FluxService)(nil)

// FluxService connects to Influx via HTTP using tokens to run queries.
type FluxService struct {
        Addr               string
        Token              string
        Name               string
        InsecureSkipVerify bool
}

// Query runs a flux query against a influx server and sends the results to the io.Writer.
// Will use the token from the context over the token within the service struct.
func (s *FluxService) Query(ctx context.Context, w io.Writer, r *query.ProxyRequest) (flux.Statistics, error) <span class="cov8" title="1">{
        span, ctx := tracing.StartSpanFromContext(ctx)
        defer span.Finish()
        u, err := NewURL(s.Addr, prefixQuery)
        if err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>
        <span class="cov8" title="1">params := url.Values{}
        params.Set(OrgID, r.Request.OrganizationID.String())
        u.RawQuery = params.Encode()

        qreq, err := QueryRequestFromProxyRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>
        <span class="cov8" title="1">var body bytes.Buffer
        if err := json.NewEncoder(&amp;body).Encode(qreq); err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>

        <span class="cov8" title="1">hreq, err := http.NewRequest("POST", u.String(), &amp;body)
        if err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>

        <span class="cov8" title="1">SetToken(s.Token, hreq)

        hreq.Header.Set("Content-Type", "application/json")
        hreq.Header.Set("Accept", "text/csv")
        if r.Request.Source != "" </span><span class="cov0" title="0">{
                hreq.Header.Add("User-Agent", r.Request.Source)
        }</span> else<span class="cov8" title="1"> if s.Name != "" </span><span class="cov0" title="0">{
                hreq.Header.Add("User-Agent", s.Name)
        }</span>

        // Now that the request is all set, we can apply header mutators.
        <span class="cov8" title="1">if err := r.Request.ApplyOptions(hreq.Header); err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>

        <span class="cov8" title="1">hreq = hreq.WithContext(ctx)
        hc := NewClient(u.Scheme, s.InsecureSkipVerify)
        resp, err := hc.Do(hreq)
        if err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := CheckError(resp); err != nil </span><span class="cov8" title="1">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>

        <span class="cov8" title="1">if _, err := io.Copy(w, resp.Body); err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>
        <span class="cov8" title="1">return flux.Statistics{}, nil</span>
}

func (s FluxService) Check(ctx context.Context) check.Response <span class="cov8" title="1">{
        return QueryHealthCheck(s.Addr, s.InsecureSkipVerify)
}</span>

var _ query.QueryService = (*FluxQueryService)(nil)

// FluxQueryService implements query.QueryService by making HTTP requests to the /api/v2/query API endpoint.
type FluxQueryService struct {
        Addr               string
        Token              string
        Name               string
        InsecureSkipVerify bool
}

// Query runs a flux query against a influx server and decodes the result
func (s *FluxQueryService) Query(ctx context.Context, r *query.Request) (flux.ResultIterator, error) <span class="cov8" title="1">{
        span, ctx := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        u, err := NewURL(s.Addr, prefixQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, tracing.LogError(span, err)
        }</span>
        <span class="cov8" title="1">params := url.Values{}
        params.Set(OrgID, r.OrganizationID.String())
        u.RawQuery = params.Encode()

        preq := &amp;query.ProxyRequest{
                Request: *r,
                Dialect: csv.DefaultDialect(),
        }
        qreq, err := QueryRequestFromProxyRequest(preq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, tracing.LogError(span, err)
        }</span>
        <span class="cov8" title="1">var body bytes.Buffer
        if err := json.NewEncoder(&amp;body).Encode(qreq); err != nil </span><span class="cov0" title="0">{
                return nil, tracing.LogError(span, err)
        }</span>

        <span class="cov8" title="1">hreq, err := http.NewRequest("POST", u.String(), &amp;body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, tracing.LogError(span, err)
        }</span>

        <span class="cov8" title="1">SetToken(s.Token, hreq)

        hreq.Header.Set("Content-Type", "application/json")
        hreq.Header.Set("Accept", "text/csv")
        if r.Source != "" </span><span class="cov0" title="0">{
                hreq.Header.Add("User-Agent", r.Source)
        }</span> else<span class="cov8" title="1"> if s.Name != "" </span><span class="cov0" title="0">{
                hreq.Header.Add("User-Agent", s.Name)
        }</span>
        <span class="cov8" title="1">hreq = hreq.WithContext(ctx)

        // Now that the request is all set, we can apply header mutators.
        if err := r.ApplyOptions(hreq.Header); err != nil </span><span class="cov0" title="0">{
                return nil, tracing.LogError(span, err)
        }</span>

        <span class="cov8" title="1">hc := NewClient(u.Scheme, s.InsecureSkipVerify)
        resp, err := hc.Do(hreq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, tracing.LogError(span, err)
        }</span>
        // Can't defer resp.Body.Close here because the CSV decoder depends on reading from resp.Body after this function returns.

        <span class="cov8" title="1">if err := CheckError(resp); err != nil </span><span class="cov8" title="1">{
                return nil, tracing.LogError(span, err)
        }</span>

        <span class="cov8" title="1">decoder := csv.NewMultiResultDecoder(csv.ResultDecoderConfig{})
        itr, err := decoder.Decode(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, tracing.LogError(span, err)
        }</span>

        <span class="cov8" title="1">return itr, nil</span>
}

func (s FluxQueryService) Check(ctx context.Context) check.Response <span class="cov8" title="1">{
        return QueryHealthCheck(s.Addr, s.InsecureSkipVerify)
}</span>

// GetQueryResponse runs a flux query with common parameters and returns the response from the query service.
func GetQueryResponse(qr *QueryRequest, addr *url.URL, org, token string, headers ...string) (*http.Response, error) <span class="cov0" title="0">{
        if len(headers)%2 != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("headers must be key value pairs")
        }</span>
        <span class="cov0" title="0">u := *addr
        u.Path = prefixQuery
        params := url.Values{}
        params.Set(Org, org)
        u.RawQuery = params.Encode()

        var body bytes.Buffer
        if err := json.NewEncoder(&amp;body).Encode(qr); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequest("POST", u.String(), &amp;body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">SetToken(token, req)

        // Default headers.
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "text/csv")
        // Apply custom headers.
        for i := 0; i &lt; len(headers); i += 2 </span><span class="cov0" title="0">{
                req.Header.Set(headers[i], headers[i+1])
        }</span>

        <span class="cov0" title="0">insecureSkipVerify := false
        hc := NewClient(u.Scheme, insecureSkipVerify)
        return hc.Do(req)</span>
}

// GetQueryResponseBody reads the body of a response from some query service.
// It also checks for errors in the response.
func GetQueryResponseBody(res *http.Response) ([]byte, error) <span class="cov0" title="0">{
        if err := CheckError(res); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        return ioutil.ReadAll(res.Body)</span>
}

// SimpleQuery runs a flux query with common parameters and returns CSV results.
func SimpleQuery(addr *url.URL, flux, org, token string, headers ...string) ([]byte, error) <span class="cov0" title="0">{
        header := true
        qr := &amp;QueryRequest{
                Type:  "flux",
                Query: flux,
                Dialect: QueryDialect{
                        Header:         &amp;header,
                        Delimiter:      ",",
                        CommentPrefix:  "#",
                        DateTimeFormat: "RFC3339",
                },
        }
        res, err := GetQueryResponse(qr, addr, org, token, headers...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return GetQueryResponseBody(res)</span>
}

func QueryHealthCheck(url string, insecureSkipVerify bool) check.Response <span class="cov8" title="1">{
        u, err := NewURL(url, "/health")
        if err != nil </span><span class="cov0" title="0">{
                return check.Response{
                        Name:    "query health",
                        Status:  check.StatusFail,
                        Message: errors.Wrap(err, "could not form URL").Error(),
                }
        }</span>

        <span class="cov8" title="1">hc := NewClient(u.Scheme, insecureSkipVerify)
        resp, err := hc.Get(u.String())
        if err != nil </span><span class="cov0" title="0">{
                return check.Response{
                        Name:    "query health",
                        Status:  check.StatusFail,
                        Message: errors.Wrap(err, "error getting response").Error(),
                }
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode/100 != 2 </span><span class="cov0" title="0">{
                return check.Response{
                        Name:    "query health",
                        Status:  check.StatusFail,
                        Message: fmt.Sprintf("http error %v", resp.StatusCode),
                }
        }</span>

        <span class="cov8" title="1">var healthResponse check.Response
        if err = json.NewDecoder(resp.Body).Decode(&amp;healthResponse); err != nil </span><span class="cov0" title="0">{
                return check.Response{
                        Name:    "query health",
                        Status:  check.StatusFail,
                        Message: errors.Wrap(err, "error decoding JSON response").Error(),
                }
        }</span>

        <span class="cov8" title="1">return healthResponse</span>
}

// routingQueryService routes queries to specific query services based on their compiler type.
type routingQueryService struct {
        // InfluxQLService handles queries with compiler type of "influxql"
        InfluxQLService query.ProxyQueryService
        // DefaultService handles all other queries
        DefaultService query.ProxyQueryService
}

func (s routingQueryService) Check(ctx context.Context) check.Response <span class="cov0" title="0">{
        // Produce combined check response
        response := check.Response{
                Name:   "internal-routingQueryService",
                Status: check.StatusPass,
        }
        def := s.DefaultService.Check(ctx)
        influxql := s.InfluxQLService.Check(ctx)
        if def.Status == check.StatusFail </span><span class="cov0" title="0">{
                response.Status = def.Status
                response.Message = def.Message
        }</span> else<span class="cov0" title="0"> if influxql.Status == check.StatusFail </span><span class="cov0" title="0">{
                response.Status = influxql.Status
                response.Message = influxql.Message
        }</span>
        <span class="cov0" title="0">response.Checks = []check.Response{def, influxql}
        sort.Sort(response.Checks)
        return response</span>
}

func (s routingQueryService) Query(ctx context.Context, w io.Writer, req *query.ProxyRequest) (flux.Statistics, error) <span class="cov0" title="0">{
        if req.Request.Compiler.CompilerType() == influxql.CompilerType </span><span class="cov0" title="0">{
                return s.InfluxQLService.Query(ctx, w, req)
        }</span>
        <span class="cov0" title="0">return s.DefaultService.Query(ctx, w, req)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package http

import (
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/influxdata/influxdb/v2/toml"
)

// ReadyHandler is a default readiness handler. The default behaviour is always ready.
func ReadyHandler() http.Handler <span class="cov8" title="1">{
        up := time.Now()
        fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "application/json; charset=utf-8")
                w.WriteHeader(http.StatusOK)

                var status = struct {
                        Status string    `json:"status"`
                        Start  time.Time `json:"started"`
                        // TODO(jsteenb2): learn why and leave comment for this being a toml.Duration
                        Up toml.Duration `json:"up"`
                }{
                        Status: "ready",
                        Start:  up,
                        Up:     toml.Duration(time.Since(up)),
                }

                enc := json.NewEncoder(w)
                enc.SetIndent("", "    ")
                if err := enc.Encode(status); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "Error encoding status data: %v\n", err)
                }</span>
        }
        <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package http

import (
        "fmt"
        "net/http"
)

const index = `&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;InfluxDB 2 API&lt;/title&gt;
    &lt;!-- needed for adaptive design --&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;
    &lt;!--
    ReDoc doesn't change outer page styles
    --&gt;
    &lt;style&gt;
      body {
        margin: 0;
        padding: 0;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;redoc spec-url='%s' suppressWarnings=true&gt;&lt;/redoc&gt;
        &lt;script src="https://cdn.jsdelivr.net/npm/redoc/bundles/redoc.standalone.js"&gt; &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
`

// Redoc servers the swagger JSON using the redoc package.
func Redoc(swagger string) http.HandlerFunc <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "text/html; charset=utf-8")
                w.WriteHeader(http.StatusOK)

                _, _ = w.Write([]byte(fmt.Sprintf(index, swagger)))
        }</span>)
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package http

import (
        "context"
        "net/http"

        platform "github.com/influxdata/influxdb/v2"
        platform2 "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
)

const (
        // OrgID is the http query parameter to specify an organization by ID.
        OrgID = "orgID"
        // Org is the http query parameter that take either the ID or Name interchangeably
        Org = "org"
        // BucketID is the http query parameter to specify an bucket by ID.
        BucketID = "bucketID"
        // Bucket is the http query parameter take either the ID or Name interchangably
        Bucket = "bucket"
)

// queryOrganization returns the organization for any http request.
//
// It checks the org= and then orgID= parameter of the request.
//
// This will try to find the organization using an ID string or
// the name.  It interprets the &amp;org= parameter as either the name
// or the ID.
func queryOrganization(ctx context.Context, r *http.Request, svc platform.OrganizationService) (o *platform.Organization, err error) <span class="cov8" title="1">{
        filter := platform.OrganizationFilter{}
        if organization := r.URL.Query().Get(Org); organization != "" </span><span class="cov8" title="1">{
                if id, err := platform2.IDFromString(organization); err == nil </span><span class="cov8" title="1">{
                        filter.ID = id
                }</span> else<span class="cov8" title="1"> {
                        filter.Name = &amp;organization
                }</span>
        }

        <span class="cov8" title="1">if reqID := r.URL.Query().Get(OrgID); reqID != "" </span><span class="cov8" title="1">{
                filter.ID, err = platform2.IDFromString(reqID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return svc.FindOrganization(ctx, filter)</span>
}

// queryBucket returns the bucket for any http request.
//
// It checks the bucket= and then bucketID= parameter of the request.
//
// This will try to find the bucket using an ID string or
// the name.  It interprets the &amp;bucket= parameter as either the name
// or the ID.
func queryBucket(ctx context.Context, orgID platform2.ID, r *http.Request, svc platform.BucketService) (b *platform.Bucket, err error) <span class="cov8" title="1">{
        filter := platform.BucketFilter{OrganizationID: &amp;orgID}
        if bucket := r.URL.Query().Get(Bucket); bucket != "" </span><span class="cov8" title="1">{
                if id, err := platform2.IDFromString(bucket); err == nil </span><span class="cov8" title="1">{
                        filter.ID = id
                }</span> else<span class="cov8" title="1"> {
                        filter.Name = &amp;bucket
                }</span>
        }
        <span class="cov8" title="1">if reqID := r.URL.Query().Get(BucketID); reqID != "" </span><span class="cov8" title="1">{
                filter.ID, err = platform2.IDFromString(reqID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">if filter.ID == nil &amp;&amp; filter.Name == nil </span><span class="cov8" title="1">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "Please provide either bucketID or bucket",
                }
        }</span>
        <span class="cov8" title="1">return svc.FindBucket(ctx, filter)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package http

import (
        "encoding/json"
        "net/http"

        "github.com/influxdata/influxdb/v2"
)

const prefixResources = "/api/v2/resources"

// NewResourceListHandler is the HTTP handler for the GET /api/v2/resources route.
func NewResourceListHandler() http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Add("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                json.NewEncoder(w).Encode(influxdb.AllResourceTypes)
        }</span>)
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package http

import (
        "compress/gzip"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "strconv"
        "time"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/authorizer"
        context2 "github.com/influxdata/influxdb/v2/context"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/kit/tracing"
        kithttp "github.com/influxdata/influxdb/v2/kit/transport/http"
        "github.com/influxdata/influxdb/v2/v1/services/meta"
        "go.uber.org/zap"
)

// RestoreBackend is all services and associated parameters required to construct the RestoreHandler.
type RestoreBackend struct {
        Logger *zap.Logger
        errors.HTTPErrorHandler

        RestoreService          influxdb.RestoreService
        SqlBackupRestoreService influxdb.SqlBackupRestoreService
        BucketService           influxdb.BucketService
        AuthorizationService    influxdb.AuthorizationService
}

// NewRestoreBackend returns a new instance of RestoreBackend.
func NewRestoreBackend(b *APIBackend) *RestoreBackend <span class="cov8" title="1">{
        return &amp;RestoreBackend{
                Logger: b.Logger.With(zap.String("handler", "restore")),

                HTTPErrorHandler:        b.HTTPErrorHandler,
                RestoreService:          b.RestoreService,
                SqlBackupRestoreService: b.SqlBackupRestoreService,
                BucketService:           b.BucketService,
                AuthorizationService:    b.AuthorizationService,
        }
}</span>

// RestoreHandler is http handler for restore service.
type RestoreHandler struct {
        *httprouter.Router
        api *kithttp.API
        errors.HTTPErrorHandler
        Logger *zap.Logger

        RestoreService          influxdb.RestoreService
        SqlBackupRestoreService influxdb.SqlBackupRestoreService
        BucketService           influxdb.BucketService
        AuthorizationService    influxdb.AuthorizationService
}

const (
        prefixRestore    = "/api/v2/restore"
        restoreKVPath    = prefixRestore + "/kv"
        restoreSqlPath   = prefixRestore + "/sql"
        restoreShardPath = prefixRestore + "/shards/:shardID"

        restoreBucketPath                   = prefixRestore + "/buckets/:bucketID" // Deprecated. Used by 2.0.x clients.
        restoreBucketMetadataDeprecatedPath = prefixRestore + "/bucket-metadata"   // Deprecated. Used by 2.1.0 of the CLI
        restoreBucketMetadataPath           = prefixRestore + "/bucketMetadata"
)

// NewRestoreHandler creates a new handler at /api/v2/restore to receive restore requests.
func NewRestoreHandler(b *RestoreBackend) *RestoreHandler <span class="cov8" title="1">{
        h := &amp;RestoreHandler{
                HTTPErrorHandler:        b.HTTPErrorHandler,
                Router:                  NewRouter(b.HTTPErrorHandler),
                Logger:                  b.Logger,
                RestoreService:          b.RestoreService,
                SqlBackupRestoreService: b.SqlBackupRestoreService,
                BucketService:           b.BucketService,
                AuthorizationService:    b.AuthorizationService,
                api:                     kithttp.NewAPI(kithttp.WithLog(b.Logger)),
        }

        h.HandlerFunc(http.MethodPost, restoreKVPath, h.handleRestoreKVStore)
        h.HandlerFunc(http.MethodPost, restoreSqlPath, h.handleRestoreSqlStore)
        h.HandlerFunc(http.MethodPost, restoreBucketPath, h.handleRestoreBucket)
        h.HandlerFunc(http.MethodPost, restoreBucketMetadataDeprecatedPath, h.handleRestoreBucketMetadata)
        h.HandlerFunc(http.MethodPost, restoreBucketMetadataPath, h.handleRestoreBucketMetadata)
        h.HandlerFunc(http.MethodPost, restoreShardPath, h.handleRestoreShard)

        return h
}</span>

func (h *RestoreHandler) getOperatorToken(ctx context.Context) (influxdb.Authorization, error) <span class="cov0" title="0">{
        // Get the token post-restore
        auths, _, err := h.AuthorizationService.FindAuthorizations(ctx, influxdb.AuthorizationFilter{})
        if err != nil </span><span class="cov0" title="0">{
                return influxdb.Authorization{}, err
        }</span>

        <span class="cov0" title="0">var operToken *influxdb.Authorization
        for _, a := range auths </span><span class="cov0" title="0">{
                authCtx := context.Background()
                authCtx = context2.SetAuthorizer(authCtx, a)
                if authorizer.IsAllowedAll(authCtx, influxdb.OperPermissions()) == nil </span><span class="cov0" title="0">{
                        operToken = a
                        break</span>
                }
        }

        <span class="cov0" title="0">if operToken == nil </span><span class="cov0" title="0">{
                return influxdb.Authorization{}, fmt.Errorf("invalid backup without an operator token, consider editing the BoltDB in the backup with 'influxd recovery'")
        }</span>

        <span class="cov0" title="0">return *operToken, nil</span>
}

func (h *RestoreHandler) handleRestoreKVStore(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        span, r := tracing.ExtractFromHTTPRequest(r, "RestoreHandler.handleRestoreKVStore")
        defer span.Finish()

        ctx := r.Context()

        var kvBytes io.Reader = r.Body
        if r.Header.Get("Content-Encoding") == "gzip" </span><span class="cov0" title="0">{
                gzr, err := gzip.NewReader(kvBytes)
                if err != nil </span><span class="cov0" title="0">{
                        err = &amp;errors.Error{
                                Code: errors.EInvalid,
                                Msg:  "failed to decode gzip request body",
                                Err:  err,
                        }
                        h.HandleHTTPError(ctx, err, w)
                }</span>
                <span class="cov0" title="0">defer gzr.Close()
                kvBytes = gzr</span>
        }

        <span class="cov0" title="0">if err := h.RestoreService.RestoreKVStore(ctx, kvBytes); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        // Get the token post-restore
        <span class="cov0" title="0">operatorToken, err := h.getOperatorToken(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        // Return the new token to the caller so it can continue the restore
        <span class="cov0" title="0">response := make(map[string]string)
        response["token"] = operatorToken.Token

        h.api.Respond(w, r, http.StatusOK, response)</span>
}

func (h *RestoreHandler) handleRestoreSqlStore(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        span, r := tracing.ExtractFromHTTPRequest(r, "RestoreHandler.handleRestoreSqlStore")
        defer span.Finish()

        ctx := r.Context()

        var sqlBytes io.Reader = r.Body
        if r.Header.Get("Content-Encoding") == "gzip" </span><span class="cov0" title="0">{
                gzr, err := gzip.NewReader(sqlBytes)
                if err != nil </span><span class="cov0" title="0">{
                        err = &amp;errors.Error{
                                Code: errors.EInvalid,
                                Msg:  "failed to decode gzip request body",
                                Err:  err,
                        }
                        h.HandleHTTPError(ctx, err, w)
                }</span>
                <span class="cov0" title="0">defer gzr.Close()
                sqlBytes = gzr</span>
        }

        <span class="cov0" title="0">if err := h.SqlBackupRestoreService.RestoreSqlStore(ctx, sqlBytes); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
}

func (h *RestoreHandler) handleRestoreBucket(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        span, r := tracing.ExtractFromHTTPRequest(r, "RestoreHandler.handleRestoreBucket")
        defer span.Finish()

        ctx := r.Context()

        // Read bucket ID.
        bucketID, err := decodeIDFromCtx(r.Context(), "bucketID")
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        // Read serialized DBI data.
        <span class="cov0" title="0">buf, err := ioutil.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">shardIDMap, err := h.RestoreService.RestoreBucket(ctx, bucketID, buf)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">if err := json.NewEncoder(w).Encode(shardIDMap); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
}

func (h *RestoreHandler) handleRestoreBucketMetadata(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        span, r := tracing.ExtractFromHTTPRequest(r, "RestoreHandler.handleRestoreBucketMetadata")
        defer span.Finish()
        ctx := r.Context()

        var b influxdb.BucketMetadataManifest
        if err := h.api.DecodeJSON(r.Body, &amp;b); err != nil </span><span class="cov0" title="0">{
                h.api.Err(w, r, err)
                return
        }</span>

        // Create the bucket - This will fail if the bucket already exists.
        // TODO: Could we support restoring to an existing bucket?
        <span class="cov0" title="0">var description string
        if b.Description != nil </span><span class="cov0" title="0">{
                description = *b.Description
        }</span>
        <span class="cov0" title="0">var rp, sgd time.Duration
        if len(b.RetentionPolicies) &gt; 0 </span><span class="cov0" title="0">{
                policy := b.RetentionPolicies[0]
                rp = policy.Duration
                sgd = policy.ShardGroupDuration
        }</span>

        <span class="cov0" title="0">bkt := influxdb.Bucket{
                OrgID:              b.OrganizationID,
                Name:               b.BucketName,
                Description:        description,
                RetentionPeriod:    rp,
                ShardGroupDuration: sgd,
        }
        if err := h.BucketService.CreateBucket(ctx, &amp;bkt); err != nil </span><span class="cov0" title="0">{
                h.api.Err(w, r, err)
                return
        }</span>

        // Restore shard-level metadata for the new bucket.
        // TODO: It's silly to marshal the DBI into binary here only to unmarshal it again within
        //  the RestoreService, but it's the easiest way to share code with the 2.0.x restore API
        //  and avoid introducing a circular dependency on the `meta` package.
        //  When we reach a point where we feel comfortable deleting the 2.0.x endpoints, consider
        //  refactoring this to pass a struct directly instead of the marshalled bytes.
        <span class="cov0" title="0">dbi := manifestToDbInfo(b)
        rawDbi, err := dbi.MarshalBinary()
        if err != nil </span><span class="cov0" title="0">{
                h.api.Err(w, r, err)
                return
        }</span>
        <span class="cov0" title="0">shardIDMap, err := h.RestoreService.RestoreBucket(ctx, bkt.ID, rawDbi)
        if err != nil </span><span class="cov0" title="0">{
                h.Logger.Warn("Cleaning up after failed bucket-restore", zap.String("bucket_id", bkt.ID.String()))
                if err2 := h.BucketService.DeleteBucket(ctx, bkt.ID); err2 != nil </span><span class="cov0" title="0">{
                        h.Logger.Error("Failed to clean up bucket after failed restore",
                                zap.String("bucket_id", bkt.ID.String()), zap.Error(err2))
                }</span>
                <span class="cov0" title="0">h.api.Err(w, r, err)
                return</span>
        }

        <span class="cov0" title="0">res := influxdb.RestoredBucketMappings{
                ID:            bkt.ID,
                Name:          bkt.Name,
                ShardMappings: make([]influxdb.RestoredShardMapping, 0, len(shardIDMap)),
        }

        for old, new := range shardIDMap </span><span class="cov0" title="0">{
                res.ShardMappings = append(res.ShardMappings, influxdb.RestoredShardMapping{OldId: old, NewId: new})
        }</span>

        <span class="cov0" title="0">h.api.Respond(w, r, http.StatusCreated, res)</span>
}

func manifestToDbInfo(m influxdb.BucketMetadataManifest) meta.DatabaseInfo <span class="cov0" title="0">{
        dbi := meta.DatabaseInfo{
                Name:                   m.BucketName,
                DefaultRetentionPolicy: m.DefaultRetentionPolicy,
                RetentionPolicies:      make([]meta.RetentionPolicyInfo, len(m.RetentionPolicies)),
        }
        for i, rp := range m.RetentionPolicies </span><span class="cov0" title="0">{
                dbi.RetentionPolicies[i] = manifestToRpInfo(rp)
        }</span>

        <span class="cov0" title="0">return dbi</span>
}

func manifestToRpInfo(m influxdb.RetentionPolicyManifest) meta.RetentionPolicyInfo <span class="cov0" title="0">{
        rpi := meta.RetentionPolicyInfo{
                Name:               m.Name,
                ReplicaN:           m.ReplicaN,
                Duration:           m.Duration,
                ShardGroupDuration: m.ShardGroupDuration,
                ShardGroups:        make([]meta.ShardGroupInfo, len(m.ShardGroups)),
                Subscriptions:      make([]meta.SubscriptionInfo, len(m.Subscriptions)),
        }

        for i, sg := range m.ShardGroups </span><span class="cov0" title="0">{
                rpi.ShardGroups[i] = manifestToSgInfo(sg)
        }</span>
        <span class="cov0" title="0">for i, s := range m.Subscriptions </span><span class="cov0" title="0">{
                rpi.Subscriptions[i] = meta.SubscriptionInfo{
                        Name:         s.Name,
                        Mode:         s.Mode,
                        Destinations: s.Destinations,
                }
        }</span>

        <span class="cov0" title="0">return rpi</span>
}

func manifestToSgInfo(m influxdb.ShardGroupManifest) meta.ShardGroupInfo <span class="cov0" title="0">{
        var delAt, truncAt time.Time
        if m.DeletedAt != nil </span><span class="cov0" title="0">{
                delAt = *m.DeletedAt
        }</span>
        <span class="cov0" title="0">if m.TruncatedAt != nil </span><span class="cov0" title="0">{
                truncAt = *m.TruncatedAt
        }</span>
        <span class="cov0" title="0">sgi := meta.ShardGroupInfo{
                ID:          m.ID,
                StartTime:   m.StartTime,
                EndTime:     m.EndTime,
                DeletedAt:   delAt,
                TruncatedAt: truncAt,
                Shards:      make([]meta.ShardInfo, len(m.Shards)),
        }

        for i, sh := range m.Shards </span><span class="cov0" title="0">{
                sgi.Shards[i] = manifestToShardInfo(sh)
        }</span>

        <span class="cov0" title="0">return sgi</span>
}

func manifestToShardInfo(m influxdb.ShardManifest) meta.ShardInfo <span class="cov0" title="0">{
        si := meta.ShardInfo{
                ID:     m.ID,
                Owners: make([]meta.ShardOwner, len(m.ShardOwners)),
        }
        for i, so := range m.ShardOwners </span><span class="cov0" title="0">{
                si.Owners[i] = meta.ShardOwner{NodeID: so.NodeID}
        }</span>

        <span class="cov0" title="0">return si</span>
}

func (h *RestoreHandler) handleRestoreShard(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        span, r := tracing.ExtractFromHTTPRequest(r, "RestoreHandler.handleRestoreShard")
        defer span.Finish()

        ctx := r.Context()

        params := httprouter.ParamsFromContext(ctx)
        shardID, err := strconv.ParseUint(params.ByName("shardID"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">var tsmBytes io.Reader = r.Body
        if r.Header.Get("Content-Encoding") == "gzip" </span><span class="cov0" title="0">{
                gzr, err := gzip.NewReader(tsmBytes)
                if err != nil </span><span class="cov0" title="0">{
                        err = &amp;errors.Error{
                                Code: errors.EInvalid,
                                Msg:  "failed to decode gzip request body",
                                Err:  err,
                        }
                        h.HandleHTTPError(ctx, err, w)
                }</span>
                <span class="cov0" title="0">defer gzr.Close()
                tsmBytes = gzr</span>
        }

        <span class="cov0" title="0">if err := h.RestoreService.RestoreShard(ctx, shardID, tsmBytes); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package http

import (
        "fmt"
        "net/http"
        "os"
        "runtime/debug"
        "sync"

        "github.com/go-chi/chi"
        "github.com/go-chi/chi/middleware"
        "github.com/go-stack/stack"
        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        kithttp "github.com/influxdata/influxdb/v2/kit/transport/http"
        influxlogger "github.com/influxdata/influxdb/v2/logger"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// NewRouter returns a new router with a 404 handler, a 405 handler, and a panic handler.
func NewRouter(h errors.HTTPErrorHandler) *httprouter.Router <span class="cov8" title="1">{
        b := baseHandler{HTTPErrorHandler: h}
        router := httprouter.New()
        router.NotFound = http.HandlerFunc(b.notFound)
        router.MethodNotAllowed = http.HandlerFunc(b.methodNotAllowed)
        router.PanicHandler = b.panic
        router.AddMatchedRouteToContext = true
        return router
}</span>

// NewBaseChiRouter returns a new chi router with a 404 handler, a 405 handler, and a panic handler.
func NewBaseChiRouter(api *kithttp.API) chi.Router <span class="cov8" title="1">{
        router := chi.NewRouter()
        router.NotFound(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                api.Err(w, r, &amp;errors.Error{
                        Code: errors.ENotFound,
                        Msg:  "path not found",
                })
        }</span>)
        <span class="cov8" title="1">router.MethodNotAllowed(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                api.Err(w, r, &amp;errors.Error{
                        Code: errors.EMethodNotAllowed,
                        Msg:  fmt.Sprintf("allow: %s", w.Header().Get("Allow")),
                })

        }</span>)
        <span class="cov8" title="1">router.Use(
                panicMW(api),
                kithttp.SkipOptions,
                middleware.StripSlashes,
                kithttp.SetCORS,
        )
        return router</span>
}

type baseHandler struct {
        errors.HTTPErrorHandler
}

// notFound represents a 404 handler that return a JSON response.
func (h baseHandler) notFound(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        pe := &amp;errors.Error{
                Code: errors.ENotFound,
                Msg:  "path not found",
        }

        h.HandleHTTPError(ctx, pe, w)
}</span>

// methodNotAllowed represents a 405 handler that return a JSON response.
func (h baseHandler) methodNotAllowed(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        allow := w.Header().Get("Allow")
        pe := &amp;errors.Error{
                Code: errors.EMethodNotAllowed,
                Msg:  fmt.Sprintf("allow: %s", allow),
        }

        h.HandleHTTPError(ctx, pe, w)
}</span>

// panic handles panics recovered from http handlers.
// It returns a json response with http status code 500 and the recovered error message.
func (h baseHandler) panic(w http.ResponseWriter, r *http.Request, rcv interface{}) <span class="cov8" title="1">{
        ctx := r.Context()
        pe := &amp;errors.Error{
                Code: errors.EInternal,
                Msg:  "a panic has occurred",
                Err:  fmt.Errorf("%s: %v", r.URL.String(), rcv),
        }

        l := getPanicLogger()
        if entry := l.Check(zapcore.ErrorLevel, pe.Msg); entry != nil </span><span class="cov8" title="1">{
                entry.Stack = string(debug.Stack())
                entry.Write(zap.Error(pe.Err))
        }</span>

        <span class="cov8" title="1">h.HandleHTTPError(ctx, pe, w)</span>
}

func panicMW(api *kithttp.API) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                fn := func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                panicErr := recover()
                                if panicErr == nil </span><span class="cov8" title="1">{
                                        return
                                }</span>

                                <span class="cov0" title="0">pe := &amp;errors.Error{
                                        Code: errors.EInternal,
                                        Msg:  "a panic has occurred",
                                        Err:  fmt.Errorf("%s: %v", r.URL.String(), panicErr),
                                }

                                l := getPanicLogger()
                                if entry := l.Check(zapcore.ErrorLevel, pe.Msg); entry != nil </span><span class="cov0" title="0">{
                                        entry.Stack = fmt.Sprintf("%+v", stack.Trace())
                                        entry.Write(zap.Error(pe.Err))
                                }</span>

                                <span class="cov0" title="0">api.Err(w, r, pe)</span>
                        }()
                        <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
                }
                <span class="cov8" title="1">return http.HandlerFunc(fn)</span>
        }
}

var panicLogger = zap.NewNop()
var panicLoggerOnce sync.Once

// getPanicLogger returns a logger for panicHandler.
func getPanicLogger() *zap.Logger <span class="cov8" title="1">{
        panicLoggerOnce.Do(func() </span><span class="cov8" title="1">{
                conf := influxlogger.NewConfig()
                logger, err := conf.New(os.Stderr)
                if err == nil </span><span class="cov8" title="1">{
                        panicLogger = logger.With(zap.String("handler", "panic"))
                }</span>
        })

        <span class="cov8" title="1">return panicLogger</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package http

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "path"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        pctx "github.com/influxdata/influxdb/v2/context"
        "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "go.uber.org/zap"
)

const (
        prefixOrganizations = "/api/v2/orgs"
        prefixBuckets       = "/api/v2/buckets"
)

// ScraperBackend is all services and associated parameters required to construct
// the ScraperHandler.
type ScraperBackend struct {
        errors.HTTPErrorHandler
        log *zap.Logger

        ScraperStorageService      influxdb.ScraperTargetStoreService
        BucketService              influxdb.BucketService
        OrganizationService        influxdb.OrganizationService
        UserService                influxdb.UserService
        UserResourceMappingService influxdb.UserResourceMappingService
        LabelService               influxdb.LabelService
}

// NewScraperBackend returns a new instance of ScraperBackend.
func NewScraperBackend(log *zap.Logger, b *APIBackend) *ScraperBackend <span class="cov8" title="1">{
        return &amp;ScraperBackend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,

                ScraperStorageService:      b.ScraperTargetStoreService,
                BucketService:              b.BucketService,
                OrganizationService:        b.OrganizationService,
                UserService:                b.UserService,
                UserResourceMappingService: b.UserResourceMappingService,
                LabelService:               b.LabelService,
        }
}</span>

// ScraperHandler represents an HTTP API handler for scraper targets.
type ScraperHandler struct {
        *httprouter.Router
        errors.HTTPErrorHandler
        log                        *zap.Logger
        UserService                influxdb.UserService
        UserResourceMappingService influxdb.UserResourceMappingService
        LabelService               influxdb.LabelService
        ScraperStorageService      influxdb.ScraperTargetStoreService
        BucketService              influxdb.BucketService
        OrganizationService        influxdb.OrganizationService
}

const (
        prefixTargets          = "/api/v2/scrapers"
        targetsIDMembersPath   = prefixTargets + "/:id/members"
        targetsIDMembersIDPath = prefixTargets + "/:id/members/:userID"
        targetsIDOwnersPath    = prefixTargets + "/:id/owners"
        targetsIDOwnersIDPath  = prefixTargets + "/:id/owners/:userID"
        targetsIDLabelsPath    = prefixTargets + "/:id/labels"
        targetsIDLabelsIDPath  = prefixTargets + "/:id/labels/:lid"
)

// NewScraperHandler returns a new instance of ScraperHandler.
func NewScraperHandler(log *zap.Logger, b *ScraperBackend) *ScraperHandler <span class="cov8" title="1">{
        h := &amp;ScraperHandler{
                Router:                     NewRouter(b.HTTPErrorHandler),
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        log,
                UserService:                b.UserService,
                UserResourceMappingService: b.UserResourceMappingService,
                LabelService:               b.LabelService,
                ScraperStorageService:      b.ScraperStorageService,
                BucketService:              b.BucketService,
                OrganizationService:        b.OrganizationService,
        }
        h.HandlerFunc("POST", prefixTargets, h.handlePostScraperTarget)
        h.HandlerFunc("GET", prefixTargets, h.handleGetScraperTargets)
        h.HandlerFunc("GET", prefixTargets+"/:id", h.handleGetScraperTarget)
        h.HandlerFunc("PATCH", prefixTargets+"/:id", h.handlePatchScraperTarget)
        h.HandlerFunc("DELETE", prefixTargets+"/:id", h.handleDeleteScraperTarget)

        memberBackend := MemberBackend{
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        b.log.With(zap.String("handler", "member")),
                ResourceType:               influxdb.ScraperResourceType,
                UserType:                   influxdb.Member,
                UserResourceMappingService: b.UserResourceMappingService,
                UserService:                b.UserService,
        }
        h.HandlerFunc("POST", targetsIDMembersPath, newPostMemberHandler(memberBackend))
        h.HandlerFunc("GET", targetsIDMembersPath, newGetMembersHandler(memberBackend))
        h.HandlerFunc("DELETE", targetsIDMembersIDPath, newDeleteMemberHandler(memberBackend))

        ownerBackend := MemberBackend{
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        b.log.With(zap.String("handler", "member")),
                ResourceType:               influxdb.ScraperResourceType,
                UserType:                   influxdb.Owner,
                UserResourceMappingService: b.UserResourceMappingService,
                UserService:                b.UserService,
        }
        h.HandlerFunc("POST", targetsIDOwnersPath, newPostMemberHandler(ownerBackend))
        h.HandlerFunc("GET", targetsIDOwnersPath, newGetMembersHandler(ownerBackend))
        h.HandlerFunc("DELETE", targetsIDOwnersIDPath, newDeleteMemberHandler(ownerBackend))

        labelBackend := &amp;LabelBackend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              b.log.With(zap.String("handler", "label")),
                LabelService:     b.LabelService,
                ResourceType:     influxdb.ScraperResourceType,
        }
        h.HandlerFunc("GET", targetsIDLabelsPath, newGetLabelsHandler(labelBackend))
        h.HandlerFunc("POST", targetsIDLabelsPath, newPostLabelHandler(labelBackend))
        h.HandlerFunc("DELETE", targetsIDLabelsIDPath, newDeleteLabelHandler(labelBackend))

        return h
}</span>

// handlePostScraperTarget is HTTP handler for the POST /api/v2/scrapers route.
func (h *ScraperHandler) handlePostScraperTarget(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeScraperTargetAddRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">auth, err := pctx.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := h.ScraperStorageService.AddTarget(ctx, req, auth.GetUserID()); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Scraper created", zap.String("scraper", fmt.Sprint(req)))

        resp, err := h.newTargetResponse(ctx, *req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusCreated, resp); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

// handleDeleteScraperTarget is the HTTP handler for the DELETE /api/v2/scrapers/:id route.
func (h *ScraperHandler) handleDeleteScraperTarget(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        id, err := decodeScraperTargetIDRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := h.ScraperStorageService.RemoveTarget(ctx, *id); err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Scraper deleted", zap.String("scraperTargetID", fmt.Sprint(id)))

        w.WriteHeader(http.StatusNoContent)</span>
}

// handlePatchScraperTarget is the HTTP handler for the PATCH /api/v2/scrapers/:id route.
func (h *ScraperHandler) handlePatchScraperTarget(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        update, err := decodeScraperTargetUpdateRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">auth, err := pctx.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">target, err := h.ScraperStorageService.UpdateTarget(ctx, update, auth.GetUserID())
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Scraper updated", zap.String("scraper", fmt.Sprint(target)))

        resp, err := h.newTargetResponse(ctx, *target)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusOK, resp); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func (h *ScraperHandler) handleGetScraperTarget(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        id, err := decodeScraperTargetIDRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">target, err := h.ScraperStorageService.GetTargetByID(ctx, *id)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Scraper retrieved", zap.String("scraper", fmt.Sprint(target)))

        resp, err := h.newTargetResponse(ctx, *target)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusOK, resp); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type getScraperTargetsRequest struct {
        filter influxdb.ScraperTargetFilter
}

func decodeScraperTargetsRequest(ctx context.Context, r *http.Request) (*getScraperTargetsRequest, error) <span class="cov8" title="1">{
        qp := r.URL.Query()
        req := &amp;getScraperTargetsRequest{}

        initialID := platform.InvalidID()
        if ids, ok := qp["id"]; ok </span><span class="cov8" title="1">{
                req.filter.IDs = make(map[platform.ID]bool)
                for _, id := range ids </span><span class="cov8" title="1">{
                        i := initialID
                        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">req.filter.IDs[i] = false</span>
                }
        }
        <span class="cov8" title="1">if name := qp.Get("name"); name != "" </span><span class="cov8" title="1">{
                req.filter.Name = &amp;name
        }</span>
        <span class="cov8" title="1">if orgID := qp.Get("orgID"); orgID != "" </span><span class="cov8" title="1">{
                id := platform.InvalidID()
                if err := id.DecodeFromString(orgID); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">req.filter.OrgID = &amp;id</span>
        } else<span class="cov8" title="1"> if org := qp.Get("org"); org != "" </span><span class="cov8" title="1">{
                req.filter.Org = &amp;org
        }</span>

        <span class="cov8" title="1">return req, nil</span>
}

// handleGetScraperTargets is the HTTP handler for the GET /api/v2/scrapers route.
func (h *ScraperHandler) handleGetScraperTargets(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeScraperTargetsRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">targets, err := h.ScraperStorageService.ListTargets(ctx, req.filter)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Scrapers retrieved", zap.String("scrapers", fmt.Sprint(targets)))

        resp, err := h.newListTargetsResponse(ctx, targets)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusOK, resp); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func decodeScraperTargetUpdateRequest(ctx context.Context, r *http.Request) (*influxdb.ScraperTarget, error) <span class="cov8" title="1">{
        update := &amp;influxdb.ScraperTarget{}
        if err := json.NewDecoder(r.Body).Decode(update); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">id, err := decodeScraperTargetIDRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">update.ID = *id
        return update, nil</span>
}

func decodeScraperTargetAddRequest(ctx context.Context, r *http.Request) (*influxdb.ScraperTarget, error) <span class="cov8" title="1">{
        req := &amp;influxdb.ScraperTarget{}
        if err := json.NewDecoder(r.Body).Decode(req); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return req, nil</span>
}

func decodeScraperTargetIDRequest(ctx context.Context, r *http.Request) (*platform.ID, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;i, nil</span>
}

// ScraperService connects to Influx via HTTP using tokens to manage scraper targets.
type ScraperService struct {
        Addr               string
        Token              string
        InsecureSkipVerify bool
        // OpPrefix is for update invalid ops
        OpPrefix string
}

// ListTargets returns a list of all scraper targets.
func (s *ScraperService) ListTargets(ctx context.Context, filter influxdb.ScraperTargetFilter) ([]influxdb.ScraperTarget, error) <span class="cov8" title="1">{
        url, err := NewURL(s.Addr, prefixTargets)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">query := url.Query()
        if filter.IDs != nil </span><span class="cov8" title="1">{
                for id := range filter.IDs </span><span class="cov8" title="1">{
                        query.Add("id", id.String())
                }</span>
        }
        <span class="cov8" title="1">if filter.Name != nil </span><span class="cov8" title="1">{
                query.Set("name", *filter.Name)
        }</span>
        <span class="cov8" title="1">if filter.OrgID != nil </span><span class="cov8" title="1">{
                query.Set("orgID", filter.OrgID.String())
        }</span>
        <span class="cov8" title="1">if filter.Org != nil </span><span class="cov8" title="1">{
                query.Set("org", *filter.Org)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("GET", url.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req.URL.RawQuery = query.Encode()
        SetToken(s.Token, req)

        hc := NewClient(url.Scheme, s.InsecureSkipVerify)
        resp, err := hc.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()
        if err := CheckError(resp); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var targetsResp getTargetsResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;targetsResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">targets := make([]influxdb.ScraperTarget, len(targetsResp.Targets))
        for k, v := range targetsResp.Targets </span><span class="cov8" title="1">{
                targets[k] = v.ScraperTarget
        }</span>

        <span class="cov8" title="1">return targets, nil</span>
}

// UpdateTarget updates a single scraper target with changeset.
// Returns the new target state after update.
func (s *ScraperService) UpdateTarget(ctx context.Context, update *influxdb.ScraperTarget, userID platform.ID) (*influxdb.ScraperTarget, error) <span class="cov8" title="1">{
        if !update.ID.Valid() </span><span class="cov8" title="1">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Op:   s.OpPrefix + influxdb.OpUpdateTarget,
                        Msg:  "provided scraper target ID has invalid format",
                }
        }</span>
        <span class="cov8" title="1">url, err := NewURL(s.Addr, targetIDPath(update.ID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">octets, err := json.Marshal(update)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("PATCH", url.String(), bytes.NewReader(octets))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        SetToken(s.Token, req)
        hc := NewClient(url.Scheme, s.InsecureSkipVerify)

        resp, err := hc.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := CheckError(resp); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var targetResp targetResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;targetResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;targetResp.ScraperTarget, nil</span>
}

// AddTarget creates a new scraper target and sets target.ID with the new identifier.
func (s *ScraperService) AddTarget(ctx context.Context, target *influxdb.ScraperTarget, userID platform.ID) error <span class="cov8" title="1">{
        url, err := NewURL(s.Addr, prefixTargets)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !target.OrgID.Valid() </span><span class="cov8" title="1">{
                return &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "provided organization ID has invalid format",
                        Op:   s.OpPrefix + influxdb.OpAddTarget,
                }
        }</span>
        <span class="cov8" title="1">if !target.BucketID.Valid() </span><span class="cov8" title="1">{
                return &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "provided bucket ID has invalid format",
                        Op:   s.OpPrefix + influxdb.OpAddTarget,
                }
        }</span>

        <span class="cov8" title="1">octets, err := json.Marshal(target)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("POST", url.String(), bytes.NewReader(octets))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        SetToken(s.Token, req)

        hc := NewClient(url.Scheme, s.InsecureSkipVerify)

        resp, err := hc.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // TODO(jsternberg): Should this check for a 201 explicitly?
        if err := CheckError(resp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">targetResp := new(targetResponse)
        if err := json.NewDecoder(resp.Body).Decode(targetResp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// RemoveTarget removes a scraper target by ID.
func (s *ScraperService) RemoveTarget(ctx context.Context, id platform.ID) error <span class="cov8" title="1">{
        url, err := NewURL(s.Addr, targetIDPath(id))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("DELETE", url.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">SetToken(s.Token, req)

        hc := NewClient(url.Scheme, s.InsecureSkipVerify)
        resp, err := hc.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        return CheckErrorStatus(http.StatusNoContent, resp)</span>
}

// GetTargetByID returns a single target by ID.
func (s *ScraperService) GetTargetByID(ctx context.Context, id platform.ID) (*influxdb.ScraperTarget, error) <span class="cov8" title="1">{
        url, err := NewURL(s.Addr, targetIDPath(id))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest("GET", url.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">SetToken(s.Token, req)

        hc := NewClient(url.Scheme, s.InsecureSkipVerify)
        resp, err := hc.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := CheckError(resp); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var targetResp targetResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;targetResp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;targetResp.ScraperTarget, nil</span>
}

func targetIDPath(id platform.ID) string <span class="cov8" title="1">{
        return path.Join(prefixTargets, id.String())
}</span>

type getTargetsLinks struct {
        Self string `json:"self"`
}

type getTargetsResponse struct {
        Links   getTargetsLinks  `json:"links"`
        Targets []targetResponse `json:"configurations"`
}

type targetLinks struct {
        Self         string `json:"self"`
        Bucket       string `json:"bucket,omitempty"`
        Organization string `json:"organization,omitempty"`
        Members      string `json:"members"`
        Owners       string `json:"owners"`
}

type targetResponse struct {
        influxdb.ScraperTarget
        Org    string      `json:"org,omitempty"`
        Bucket string      `json:"bucket,omitempty"`
        Links  targetLinks `json:"links"`
}

func (h *ScraperHandler) newListTargetsResponse(ctx context.Context, targets []influxdb.ScraperTarget) (getTargetsResponse, error) <span class="cov8" title="1">{
        res := getTargetsResponse{
                Links: getTargetsLinks{
                        Self: prefixTargets,
                },
                Targets: make([]targetResponse, 0, len(targets)),
        }

        for _, target := range targets </span><span class="cov8" title="1">{
                resp, err := h.newTargetResponse(ctx, target)
                if err != nil </span><span class="cov0" title="0">{
                        return res, err
                }</span>
                <span class="cov8" title="1">res.Targets = append(res.Targets, resp)</span>
        }

        <span class="cov8" title="1">return res, nil</span>
}

func (h *ScraperHandler) newTargetResponse(ctx context.Context, target influxdb.ScraperTarget) (targetResponse, error) <span class="cov8" title="1">{
        res := targetResponse{
                Links: targetLinks{
                        Self:    targetIDPath(target.ID),
                        Members: fmt.Sprintf("/api/v2/scrapers/%s/members", target.ID),
                        Owners:  fmt.Sprintf("/api/v2/scrapers/%s/owners", target.ID),
                },
                ScraperTarget: target,
        }
        bucket, err := h.BucketService.FindBucketByID(ctx, target.BucketID)
        if err == nil </span><span class="cov8" title="1">{
                res.Bucket = bucket.Name
                res.BucketID = bucket.ID
                res.Links.Bucket = bucketIDPath(bucket.ID)
        }</span> else<span class="cov0" title="0"> {
                res.BucketID = platform.InvalidID()
        }</span>

        <span class="cov8" title="1">org, err := h.OrganizationService.FindOrganizationByID(ctx, target.OrgID)
        if err == nil </span><span class="cov8" title="1">{
                res.Org = org.Name
                res.OrgID = org.ID
                res.Links.Organization = organizationIDPath(org.ID)
        }</span> else<span class="cov0" title="0"> {
                res.OrgID = platform.InvalidID()
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}

func organizationIDPath(id platform.ID) string <span class="cov8" title="1">{
        return path.Join(prefixOrganizations, id.String())
}</span>

func bucketIDPath(id platform.ID) string <span class="cov8" title="1">{
        return path.Join(prefixBuckets, id.String())
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package http

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"

        "github.com/influxdata/flux"
        "github.com/influxdata/flux/lang"
        platform "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/kit/check"
        "github.com/influxdata/influxdb/v2/kit/tracing"
        "github.com/influxdata/influxdb/v2/query"
        "github.com/influxdata/influxdb/v2/query/influxql"
)

type SourceProxyQueryService struct {
        Addr               string
        InsecureSkipVerify bool
        platform.SourceFields
}

func (s *SourceProxyQueryService) Query(ctx context.Context, w io.Writer, req *query.ProxyRequest) (flux.Statistics, error) <span class="cov0" title="0">{
        switch req.Request.Compiler.CompilerType() </span>{
        case influxql.CompilerType:<span class="cov0" title="0">
                return s.queryInfluxQL(ctx, w, req)</span>
        case lang.FluxCompilerType:<span class="cov0" title="0">
                return s.queryFlux(ctx, w, req)</span>
        }
        <span class="cov0" title="0">return flux.Statistics{}, fmt.Errorf("compiler type not supported")</span>
}

func (s *SourceProxyQueryService) queryFlux(ctx context.Context, w io.Writer, req *query.ProxyRequest) (flux.Statistics, error) <span class="cov0" title="0">{
        span, ctx := tracing.StartSpanFromContext(ctx)
        defer span.Finish()
        u, err := NewURL(s.Addr, "/api/v2/query")
        if err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>
        <span class="cov0" title="0">var body bytes.Buffer
        if err := json.NewEncoder(&amp;body).Encode(req); err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>

        <span class="cov0" title="0">hreq, err := http.NewRequest("POST", u.String(), &amp;body)
        if err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>
        <span class="cov0" title="0">hreq.Header.Set("Authorization", fmt.Sprintf("Token %s", s.Token))
        hreq.Header.Set("Content-Type", "application/json")
        hreq = hreq.WithContext(ctx)

        hc := NewClient(u.Scheme, s.InsecureSkipVerify)
        resp, err := hc.Do(hreq)
        if err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()
        if err := CheckError(resp); err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>

        <span class="cov0" title="0">if _, err = io.Copy(w, resp.Body); err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>

        <span class="cov0" title="0">return flux.Statistics{}, nil</span>
}

func (s *SourceProxyQueryService) queryInfluxQL(ctx context.Context, w io.Writer, req *query.ProxyRequest) (flux.Statistics, error) <span class="cov0" title="0">{
        span, ctx := tracing.StartSpanFromContext(ctx)
        defer span.Finish()
        compiler, ok := req.Request.Compiler.(*influxql.Compiler)

        if !ok </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, fmt.Errorf("compiler is not of type 'influxql'"))
        }</span>

        <span class="cov0" title="0">u, err := NewURL(s.Addr, "/query")
        if err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>

        <span class="cov0" title="0">body := url.Values{}
        body.Add("db", compiler.DB)
        body.Add("org", compiler.Cluster)
        body.Add("q", compiler.Query)
        body.Add("rp", compiler.RP)
        hreq, err := http.NewRequest("POST", u.String(), strings.NewReader(body.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>
        <span class="cov0" title="0">hreq.Header.Set("Content-Type", "application/x-www-form-urlencoded")
        hreq.Header.Set("Authorization", fmt.Sprintf("Token %s", s.Token))
        hreq = hreq.WithContext(ctx)

        hc := NewClient(u.Scheme, s.InsecureSkipVerify)
        resp, err := hc.Do(hreq)
        if err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if err := CheckError(resp); err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>

        <span class="cov0" title="0">if _, err = io.Copy(w, resp.Body); err != nil </span><span class="cov0" title="0">{
                return flux.Statistics{}, tracing.LogError(span, err)
        }</span>

        <span class="cov0" title="0">return flux.Statistics{}, nil</span>
}

func (s *SourceProxyQueryService) Check(context.Context) check.Response <span class="cov0" title="0">{
        return QueryHealthCheck(s.Addr, s.InsecureSkipVerify)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package http

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/influxdata/flux"
        "github.com/influxdata/flux/csv"
        "github.com/influxdata/flux/lang"
        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/pkg/httpc"
        "github.com/influxdata/influxdb/v2/query"
        "github.com/influxdata/influxdb/v2/query/influxql"
        "go.uber.org/zap"
)

const (
        prefixSources = "/api/v2/sources"
)

type sourceResponse struct {
        *influxdb.Source
        Links map[string]interface{} `json:"links"`
}

func newSourceResponse(s *influxdb.Source) *sourceResponse <span class="cov8" title="1">{
        s.Password = ""
        s.SharedSecret = ""

        if s.Type == influxdb.SelfSourceType </span><span class="cov8" title="1">{
                return &amp;sourceResponse{
                        Source: s,
                        Links: map[string]interface{}{
                                "self":    fmt.Sprintf("%s/%s", prefixSources, s.ID.String()),
                                "query":   fmt.Sprintf("%s/%s/query", prefixSources, s.ID.String()),
                                "buckets": fmt.Sprintf("%s/%s/buckets", prefixSources, s.ID.String()),
                                "health":  fmt.Sprintf("%s/%s/health", prefixSources, s.ID.String()),
                        },
                }
        }</span>

        <span class="cov8" title="1">return &amp;sourceResponse{
                Source: s,
                Links: map[string]interface{}{
                        "self":    fmt.Sprintf("%s/%s", prefixSources, s.ID.String()),
                        "query":   fmt.Sprintf("%s/%s/query", prefixSources, s.ID.String()),
                        "buckets": fmt.Sprintf("%s/%s/buckets", prefixSources, s.ID.String()),
                        "health":  fmt.Sprintf("%s/%s/health", prefixSources, s.ID.String()),
                },
        }</span>
}

type sourcesResponse struct {
        Sources []*sourceResponse      `json:"sources"`
        Links   map[string]interface{} `json:"links"`
}

func newSourcesResponse(srcs []*influxdb.Source) *sourcesResponse <span class="cov0" title="0">{
        res := &amp;sourcesResponse{
                Links: map[string]interface{}{
                        "self": prefixSources,
                },
        }

        res.Sources = make([]*sourceResponse, 0, len(srcs))
        for _, src := range srcs </span><span class="cov0" title="0">{
                res.Sources = append(res.Sources, newSourceResponse(src))
        }</span>

        <span class="cov0" title="0">return res</span>
}

// SourceBackend is all services and associated parameters required to construct
// the SourceHandler.
type SourceBackend struct {
        errors.HTTPErrorHandler
        log *zap.Logger

        SourceService   influxdb.SourceService
        LabelService    influxdb.LabelService
        BucketService   influxdb.BucketService
        NewQueryService func(s *influxdb.Source) (query.ProxyQueryService, error)
}

// NewSourceBackend returns a new instance of SourceBackend.
func NewSourceBackend(log *zap.Logger, b *APIBackend) *SourceBackend <span class="cov8" title="1">{
        return &amp;SourceBackend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,

                SourceService:   b.SourceService,
                LabelService:    b.LabelService,
                BucketService:   b.BucketService,
                NewQueryService: b.NewQueryService,
        }
}</span>

// SourceHandler is a handler for sources
type SourceHandler struct {
        *httprouter.Router
        errors.HTTPErrorHandler
        log           *zap.Logger
        SourceService influxdb.SourceService
        LabelService  influxdb.LabelService
        BucketService influxdb.BucketService

        // TODO(desa): this was done so in order to remove an import cycle and to allow
        // for http mocking.
        NewQueryService func(s *influxdb.Source) (query.ProxyQueryService, error)
}

// NewSourceHandler returns a new instance of SourceHandler.
func NewSourceHandler(log *zap.Logger, b *SourceBackend) *SourceHandler <span class="cov8" title="1">{
        h := &amp;SourceHandler{
                Router:           NewRouter(b.HTTPErrorHandler),
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,

                SourceService:   b.SourceService,
                LabelService:    b.LabelService,
                BucketService:   b.BucketService,
                NewQueryService: b.NewQueryService,
        }

        h.HandlerFunc("POST", prefixSources, h.handlePostSource)
        h.HandlerFunc("GET", "/api/v2/sources", h.handleGetSources)
        h.HandlerFunc("GET", "/api/v2/sources/:id", h.handleGetSource)
        h.HandlerFunc("PATCH", "/api/v2/sources/:id", h.handlePatchSource)
        h.HandlerFunc("DELETE", "/api/v2/sources/:id", h.handleDeleteSource)

        h.HandlerFunc("GET", "/api/v2/sources/:id/buckets", h.handleGetSourcesBuckets)
        h.HandlerFunc("POST", "/api/v2/sources/:id/query", h.handlePostSourceQuery)
        h.HandlerFunc("GET", "/api/v2/sources/:id/health", h.handleGetSourceHealth)

        return h
}</span>

func decodeSourceQueryRequest(r *http.Request) (*query.ProxyRequest, error) <span class="cov0" title="0">{
        // starts here
        request := struct {
                Spec           *flux.Spec  `json:"spec"`
                Query          string      `json:"query"`
                Type           string      `json:"type"`
                DB             string      `json:"db"`
                RP             string      `json:"rp"`
                Cluster        string      `json:"cluster"`
                OrganizationID platform.ID `json:"organizationID"`
                // TODO(desa): support influxql dialect
                Dialect csv.Dialect `json:"dialect"`
        }{}

        err := json.NewDecoder(r.Body).Decode(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req := &amp;query.ProxyRequest{}
        req.Dialect = request.Dialect

        req.Request.OrganizationID = request.OrganizationID

        switch request.Type </span>{
        case lang.FluxCompilerType:<span class="cov0" title="0">
                req.Request.Compiler = lang.FluxCompiler{
                        Query: request.Query,
                }</span>
        case influxql.CompilerType:<span class="cov0" title="0">
                req.Request.Compiler = &amp;influxql.Compiler{
                        Cluster: request.Cluster,
                        DB:      request.DB,
                        RP:      request.RP,
                        Query:   request.Query,
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("compiler type not supported")</span>
        }

        <span class="cov0" title="0">return req, nil</span>
}

// handlePostSourceQuery is the HTTP handler for POST /api/v2/sources/:id/query
func (h *SourceHandler) handlePostSourceQuery(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        gsr, err := decodeGetSourceRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">req, err := decodeSourceQueryRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">s, err := h.SourceService.FindSourceByID(ctx, gsr.SourceID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">querySvc, err := h.NewQueryService(s)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">_, err = querySvc.Query(ctx, w, req)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
}

// handleGetSourcesBuckets is the HTTP handler for the GET /api/v2/sources/:id/buckets route.
func (h *SourceHandler) handleGetSourcesBuckets(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        req, err := decodeGetSourceBucketsRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">_, err = h.SourceService.FindSourceByID(ctx, req.getSourceRequest.SourceID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">bs, _, err := h.BucketService.FindBuckets(ctx, req.getBucketsRequest.filter)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">if err := encodeResponse(ctx, w, http.StatusOK, newBucketsResponse(ctx, req.opts, req.filter, bs, h.LabelService)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type getSourceBucketsRequest struct {
        *getSourceRequest
        *getBucketsRequest
}

func decodeGetSourceBucketsRequest(ctx context.Context, r *http.Request) (*getSourceBucketsRequest, error) <span class="cov0" title="0">{
        getSrcReq, err := decodeGetSourceRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">getBucketsReq, err := decodeGetBucketsRequest(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;getSourceBucketsRequest{
                getBucketsRequest: getBucketsReq,
                getSourceRequest:  getSrcReq,
        }, nil</span>
}

type getBucketsRequest struct {
        filter influxdb.BucketFilter
        opts   influxdb.FindOptions
}

func decodeGetBucketsRequest(r *http.Request) (*getBucketsRequest, error) <span class="cov0" title="0">{
        qp := r.URL.Query()
        req := &amp;getBucketsRequest{}

        opts, err := influxdb.DecodeFindOptions(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">req.opts = *opts

        if orgID := qp.Get("orgID"); orgID != "" </span><span class="cov0" title="0">{
                id, err := platform.IDFromString(orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req.filter.OrganizationID = id</span>
        }

        <span class="cov0" title="0">if org := qp.Get("org"); org != "" </span><span class="cov0" title="0">{
                req.filter.Org = &amp;org
        }</span>

        <span class="cov0" title="0">if name := qp.Get("name"); name != "" </span><span class="cov0" title="0">{
                req.filter.Name = &amp;name
        }</span>

        <span class="cov0" title="0">if bucketID := qp.Get("id"); bucketID != "" </span><span class="cov0" title="0">{
                id, err := platform.IDFromString(bucketID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req.filter.ID = id</span>
        }

        <span class="cov0" title="0">return req, nil</span>
}

type bucketResponse struct {
        bucket
        Links  map[string]string `json:"links"`
        Labels []influxdb.Label  `json:"labels"`
}

type bucket struct {
        ID                  platform.ID     `json:"id,omitempty"`
        OrgID               platform.ID     `json:"orgID,omitempty"`
        Type                string          `json:"type"`
        Description         string          `json:"description,omitempty"`
        Name                string          `json:"name"`
        RetentionPolicyName string          `json:"rp,omitempty"` // This to support v1 sources
        RetentionRules      []retentionRule `json:"retentionRules"`
        influxdb.CRUDLog
}

func newBucket(pb *influxdb.Bucket) *bucket <span class="cov0" title="0">{
        if pb == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">rules := []retentionRule{
                {
                        Type:                      "expire",
                        EverySeconds:              int64(pb.RetentionPeriod.Round(time.Second) / time.Second),
                        ShardGroupDurationSeconds: int64(pb.ShardGroupDuration.Round(time.Second) / time.Second),
                },
        }

        return &amp;bucket{
                ID:                  pb.ID,
                OrgID:               pb.OrgID,
                Type:                pb.Type.String(),
                Name:                pb.Name,
                Description:         pb.Description,
                RetentionPolicyName: pb.RetentionPolicyName,
                RetentionRules:      rules,
                CRUDLog:             pb.CRUDLog,
        }</span>
}

// retentionRule is the retention rule action for a bucket.
type retentionRule struct {
        Type                      string `json:"type"`
        EverySeconds              int64  `json:"everySeconds"`
        ShardGroupDurationSeconds int64  `json:"shardGroupDurationSeconds"`
}

func NewBucketResponse(b *influxdb.Bucket, labels []*influxdb.Label) *bucketResponse <span class="cov0" title="0">{
        res := &amp;bucketResponse{
                Links: map[string]string{
                        "labels":  fmt.Sprintf("/api/v2/buckets/%s/labels", b.ID),
                        "logs":    fmt.Sprintf("/api/v2/buckets/%s/logs", b.ID),
                        "members": fmt.Sprintf("/api/v2/buckets/%s/members", b.ID),
                        "org":     fmt.Sprintf("/api/v2/orgs/%s", b.OrgID),
                        "owners":  fmt.Sprintf("/api/v2/buckets/%s/owners", b.ID),
                        "self":    fmt.Sprintf("/api/v2/buckets/%s", b.ID),
                        "write":   fmt.Sprintf("/api/v2/write?org=%s&amp;bucket=%s", b.OrgID, b.ID),
                },
                bucket: *newBucket(b),
                Labels: []influxdb.Label{},
        }

        for _, l := range labels </span><span class="cov0" title="0">{
                res.Labels = append(res.Labels, *l)
        }</span>

        <span class="cov0" title="0">return res</span>
}

type bucketsResponse struct {
        Links   *influxdb.PagingLinks `json:"links"`
        Buckets []*bucketResponse     `json:"buckets"`
}

func newBucketsResponse(ctx context.Context, opts influxdb.FindOptions, f influxdb.BucketFilter, bs []*influxdb.Bucket, labelService influxdb.LabelService) *bucketsResponse <span class="cov0" title="0">{
        rs := make([]*bucketResponse, 0, len(bs))
        for _, b := range bs </span><span class="cov0" title="0">{
                labels, _ := labelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: b.ID, ResourceType: influxdb.BucketsResourceType})
                rs = append(rs, NewBucketResponse(b, labels))
        }</span>
        <span class="cov0" title="0">return &amp;bucketsResponse{
                Links:   influxdb.NewPagingLinks(prefixBuckets, opts, f, len(bs)),
                Buckets: rs,
        }</span>
}

// handlePostSource is the HTTP handler for the POST /api/v2/sources route.
func (h *SourceHandler) handlePostSource(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        req, err := decodePostSourceRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">if err := h.SourceService.CreateSource(ctx, req.Source); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">res := newSourceResponse(req.Source)
        h.log.Debug("Source created", zap.String("source", fmt.Sprint(res)))
        if err := encodeResponse(ctx, w, http.StatusCreated, res); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type postSourceRequest struct {
        Source *influxdb.Source
}

func decodePostSourceRequest(ctx context.Context, r *http.Request) (*postSourceRequest, error) <span class="cov0" title="0">{
        b := &amp;influxdb.Source{}
        if err := json.NewDecoder(r.Body).Decode(b); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;postSourceRequest{
                Source: b,
        }, nil</span>
}

// handleGetSource is the HTTP handler for the GET /api/v2/sources/:id route.
func (h *SourceHandler) handleGetSource(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        req, err := decodeGetSourceRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">s, err := h.SourceService.FindSourceByID(ctx, req.SourceID)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">res := newSourceResponse(s)
        h.log.Debug("Source retrieved", zap.String("source", fmt.Sprint(res)))

        if err := encodeResponse(ctx, w, http.StatusOK, res); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

// handleGetSourceHealth is the HTTP handler for the GET /v1/sources/:id/health route.
func (h *SourceHandler) handleGetSourceHealth(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        msg := `{"name":"sources","message":"source is %shealthy","status":"%s","checks":[]}`
        w.Header().Set("Content-Type", "application/json; charset=utf-8")

        req, err := decodeGetSourceRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">if _, err := h.SourceService.FindSourceByID(ctx, req.SourceID); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        // todo(leodido) &gt; check source is actually healthy and reply with 503 if not
        // w.WriteHeader(http.StatusServiceUnavailable)
        // fmt.Fprintln(w, fmt.Sprintf(msg, "not ", "fail"))

        <span class="cov0" title="0">w.WriteHeader(http.StatusOK)
        fmt.Fprintln(w, fmt.Sprintf(msg, "", "pass"))</span>
}

type getSourceRequest struct {
        SourceID platform.ID
}

func decodeGetSourceRequest(ctx context.Context, r *http.Request) (*getSourceRequest, error) <span class="cov0" title="0">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov0" title="0">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req := &amp;getSourceRequest{
                SourceID: i,
        }

        return req, nil</span>
}

// handleDeleteSource is the HTTP handler for the DELETE /api/v2/sources/:id route.
func (h *SourceHandler) handleDeleteSource(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        req, err := decodeDeleteSourceRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">if err := h.SourceService.DeleteSource(ctx, req.SourceID); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">h.log.Debug("Source deleted", zap.String("sourceID", fmt.Sprint(req.SourceID)))

        w.WriteHeader(http.StatusNoContent)</span>
}

type deleteSourceRequest struct {
        SourceID platform.ID
}

func decodeDeleteSourceRequest(ctx context.Context, r *http.Request) (*deleteSourceRequest, error) <span class="cov0" title="0">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov0" title="0">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req := &amp;deleteSourceRequest{
                SourceID: i,
        }

        return req, nil</span>
}

// handleGetSources is the HTTP handler for the GET /api/v2/sources route.
func (h *SourceHandler) handleGetSources(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        req, err := decodeGetSourcesRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">srcs, _, err := h.SourceService.FindSources(ctx, req.findOptions)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">res := newSourcesResponse(srcs)
        h.log.Debug("Sources retrieved", zap.String("sources", fmt.Sprint(res)))

        if err := encodeResponse(ctx, w, http.StatusOK, res); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type getSourcesRequest struct {
        findOptions influxdb.FindOptions
}

func decodeGetSourcesRequest(ctx context.Context, r *http.Request) (*getSourcesRequest, error) <span class="cov0" title="0">{
        req := &amp;getSourcesRequest{}
        return req, nil
}</span>

// handlePatchSource is the HTTP handler for the PATH /api/v2/sources route.
func (h *SourceHandler) handlePatchSource(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        req, err := decodePatchSourceRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">b, err := h.SourceService.UpdateSource(ctx, req.SourceID, req.Update)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">h.log.Debug("Source updated", zap.String("source", fmt.Sprint(b)))

        if err := encodeResponse(ctx, w, http.StatusOK, b); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type patchSourceRequest struct {
        Update   influxdb.SourceUpdate
        SourceID platform.ID
}

func decodePatchSourceRequest(ctx context.Context, r *http.Request) (*patchSourceRequest, error) <span class="cov0" title="0">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov0" title="0">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var upd influxdb.SourceUpdate
        if err := json.NewDecoder(r.Body).Decode(&amp;upd); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;patchSourceRequest{
                Update:   upd,
                SourceID: i,
        }, nil</span>
}

// SourceService connects to Influx via HTTP using tokens to manage sources
type SourceService struct {
        Client *httpc.Client
}

// FindSourceByID returns a single source by ID.
func (s *SourceService) FindSourceByID(ctx context.Context, id platform.ID) (*influxdb.Source, error) <span class="cov0" title="0">{
        var b influxdb.Source
        err := s.Client.
                Get(prefixSources, id.String()).
                DecodeJSON(&amp;b).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;b, nil</span>
}

// FindSources returns a list of sources that match filter and the total count of matching sources.
// Additional options provide pagination &amp; sorting.
func (s *SourceService) FindSources(ctx context.Context, opt influxdb.FindOptions) ([]*influxdb.Source, int, error) <span class="cov0" title="0">{
        var bs []*influxdb.Source
        err := s.Client.
                Get(prefixSources).
                DecodeJSON(&amp;bs).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return bs, len(bs), nil</span>
}

// CreateSource creates a new source and sets b.ID with the new identifier.
func (s *SourceService) CreateSource(ctx context.Context, b *influxdb.Source) error <span class="cov0" title="0">{
        return s.Client.
                PostJSON(b, prefixSources).
                DecodeJSON(b).
                Do(ctx)
}</span>

// UpdateSource updates a single source with changeset.
// Returns the new source state after update.
func (s *SourceService) UpdateSource(ctx context.Context, id platform.ID, upd influxdb.SourceUpdate) (*influxdb.Source, error) <span class="cov0" title="0">{
        var b influxdb.Source
        err := s.Client.
                PatchJSON(upd, prefixSources, id.String()).
                DecodeJSON(&amp;b).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;b, nil</span>
}

// DeleteSource removes a source by ID.
func (s *SourceService) DeleteSource(ctx context.Context, id platform.ID) error <span class="cov0" title="0">{
        return s.Client.
                Delete(prefixSources, id.String()).
                StatusFn(func(resp *http.Response) error </span><span class="cov0" title="0">{
                        return CheckErrorStatus(http.StatusNoContent, resp)
                }</span>).
                Do(ctx)

}
</pre>
		
		<pre class="file" id="file41" style="display: none">package http

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "net/url"
        "path"
        "strconv"
        "time"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        pcontext "github.com/influxdata/influxdb/v2/context"
        "github.com/influxdata/influxdb/v2/kit/platform"
        errors2 "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/kit/tracing"
        "github.com/influxdata/influxdb/v2/kv"
        "github.com/influxdata/influxdb/v2/pkg/httpc"
        "github.com/influxdata/influxdb/v2/task/options"
        "github.com/influxdata/influxdb/v2/task/taskmodel"
        "go.uber.org/zap"
)

// TaskBackend is all services and associated parameters required to construct
// the TaskHandler.
type TaskBackend struct {
        errors2.HTTPErrorHandler
        log *zap.Logger

        AlgoWProxy                 FeatureProxyHandler
        TaskService                taskmodel.TaskService
        AuthorizationService       influxdb.AuthorizationService
        OrganizationService        influxdb.OrganizationService
        UserResourceMappingService influxdb.UserResourceMappingService
        LabelService               influxdb.LabelService
        UserService                influxdb.UserService
        BucketService              influxdb.BucketService
}

// NewTaskBackend returns a new instance of TaskBackend.
func NewTaskBackend(log *zap.Logger, b *APIBackend) *TaskBackend <span class="cov8" title="1">{
        return &amp;TaskBackend{
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        log,
                AlgoWProxy:                 b.AlgoWProxy,
                TaskService:                b.TaskService,
                AuthorizationService:       b.AuthorizationService,
                OrganizationService:        b.OrganizationService,
                UserResourceMappingService: b.UserResourceMappingService,
                LabelService:               b.LabelService,
                UserService:                b.UserService,
                BucketService:              b.BucketService,
        }
}</span>

// TaskHandler represents an HTTP API handler for tasks.
type TaskHandler struct {
        *httprouter.Router
        errors2.HTTPErrorHandler
        log *zap.Logger

        TaskService                taskmodel.TaskService
        AuthorizationService       influxdb.AuthorizationService
        OrganizationService        influxdb.OrganizationService
        UserResourceMappingService influxdb.UserResourceMappingService
        LabelService               influxdb.LabelService
        UserService                influxdb.UserService
        BucketService              influxdb.BucketService
}

const (
        prefixTasks            = "/api/v2/tasks"
        tasksIDPath            = "/api/v2/tasks/:id"
        tasksIDLogsPath        = "/api/v2/tasks/:id/logs"
        tasksIDMembersPath     = "/api/v2/tasks/:id/members"
        tasksIDMembersIDPath   = "/api/v2/tasks/:id/members/:userID"
        tasksIDOwnersPath      = "/api/v2/tasks/:id/owners"
        tasksIDOwnersIDPath    = "/api/v2/tasks/:id/owners/:userID"
        tasksIDRunsPath        = "/api/v2/tasks/:id/runs"
        tasksIDRunsIDPath      = "/api/v2/tasks/:id/runs/:rid"
        tasksIDRunsIDLogsPath  = "/api/v2/tasks/:id/runs/:rid/logs"
        tasksIDRunsIDRetryPath = "/api/v2/tasks/:id/runs/:rid/retry"
        tasksIDLabelsPath      = "/api/v2/tasks/:id/labels"
        tasksIDLabelsIDPath    = "/api/v2/tasks/:id/labels/:lid"
)

// NewTaskHandler returns a new instance of TaskHandler.
func NewTaskHandler(log *zap.Logger, b *TaskBackend) *TaskHandler <span class="cov8" title="1">{
        h := &amp;TaskHandler{
                Router:           NewRouter(b.HTTPErrorHandler),
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,

                TaskService:                b.TaskService,
                AuthorizationService:       b.AuthorizationService,
                OrganizationService:        b.OrganizationService,
                UserResourceMappingService: b.UserResourceMappingService,
                LabelService:               b.LabelService,
                UserService:                b.UserService,
                BucketService:              b.BucketService,
        }

        h.HandlerFunc("GET", prefixTasks, h.handleGetTasks)
        h.Handler("POST", prefixTasks, withFeatureProxy(b.AlgoWProxy, http.HandlerFunc(h.handlePostTask)))

        h.HandlerFunc("GET", tasksIDPath, h.handleGetTask)
        h.Handler("PATCH", tasksIDPath, withFeatureProxy(b.AlgoWProxy, http.HandlerFunc(h.handleUpdateTask)))
        h.HandlerFunc("DELETE", tasksIDPath, h.handleDeleteTask)

        h.HandlerFunc("GET", tasksIDLogsPath, h.handleGetLogs)
        h.HandlerFunc("GET", tasksIDRunsIDLogsPath, h.handleGetLogs)

        memberBackend := MemberBackend{
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        b.log.With(zap.String("handler", "member")),
                ResourceType:               influxdb.TasksResourceType,
                UserType:                   influxdb.Member,
                UserResourceMappingService: b.UserResourceMappingService,
                UserService:                b.UserService,
        }
        h.HandlerFunc("POST", tasksIDMembersPath, newPostMemberHandler(memberBackend))
        h.HandlerFunc("GET", tasksIDMembersPath, newGetMembersHandler(memberBackend))
        h.HandlerFunc("DELETE", tasksIDMembersIDPath, newDeleteMemberHandler(memberBackend))

        ownerBackend := MemberBackend{
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        b.log.With(zap.String("handler", "member")),
                ResourceType:               influxdb.TasksResourceType,
                UserType:                   influxdb.Owner,
                UserResourceMappingService: b.UserResourceMappingService,
                UserService:                b.UserService,
        }
        h.HandlerFunc("POST", tasksIDOwnersPath, newPostMemberHandler(ownerBackend))
        h.HandlerFunc("GET", tasksIDOwnersPath, newGetMembersHandler(ownerBackend))
        h.HandlerFunc("DELETE", tasksIDOwnersIDPath, newDeleteMemberHandler(ownerBackend))

        h.HandlerFunc("GET", tasksIDRunsPath, h.handleGetRuns)
        h.HandlerFunc("POST", tasksIDRunsPath, h.handleForceRun)
        h.HandlerFunc("GET", tasksIDRunsIDPath, h.handleGetRun)
        h.HandlerFunc("POST", tasksIDRunsIDRetryPath, h.handleRetryRun)
        h.HandlerFunc("DELETE", tasksIDRunsIDPath, h.handleCancelRun)

        labelBackend := &amp;LabelBackend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              b.log.With(zap.String("handler", "label")),
                LabelService:     b.LabelService,
                ResourceType:     influxdb.TasksResourceType,
        }
        h.HandlerFunc("GET", tasksIDLabelsPath, newGetLabelsHandler(labelBackend))
        h.HandlerFunc("POST", tasksIDLabelsPath, newPostLabelHandler(labelBackend))
        h.HandlerFunc("DELETE", tasksIDLabelsIDPath, newDeleteLabelHandler(labelBackend))

        return h
}</span>

// Task is a package-specific Task format that preserves the expected format for the API,
// where time values are represented as strings
type Task struct {
        ID              platform.ID            `json:"id"`
        OrganizationID  platform.ID            `json:"orgID"`
        Organization    string                 `json:"org"`
        OwnerID         platform.ID            `json:"ownerID"`
        Name            string                 `json:"name"`
        Description     string                 `json:"description,omitempty"`
        Status          string                 `json:"status"`
        Flux            string                 `json:"flux"`
        Every           string                 `json:"every,omitempty"`
        Cron            string                 `json:"cron,omitempty"`
        Offset          string                 `json:"offset,omitempty"`
        LatestCompleted string                 `json:"latestCompleted,omitempty"`
        LastRunStatus   string                 `json:"lastRunStatus,omitempty"`
        LastRunError    string                 `json:"lastRunError,omitempty"`
        CreatedAt       string                 `json:"createdAt,omitempty"`
        UpdatedAt       string                 `json:"updatedAt,omitempty"`
        Metadata        map[string]interface{} `json:"metadata,omitempty"`
}

type taskResponse struct {
        Links  map[string]string `json:"links"`
        Labels []influxdb.Label  `json:"labels"`
        Task
}

// NewFrontEndTask converts a internal task type to a task that we want to display to users
func NewFrontEndTask(t taskmodel.Task) Task <span class="cov8" title="1">{
        latestCompleted := ""
        if !t.LatestCompleted.IsZero() </span><span class="cov0" title="0">{
                latestCompleted = t.LatestCompleted.Format(time.RFC3339)
        }</span>
        <span class="cov8" title="1">createdAt := ""
        if !t.CreatedAt.IsZero() </span><span class="cov0" title="0">{
                createdAt = t.CreatedAt.Format(time.RFC3339)
        }</span>
        <span class="cov8" title="1">updatedAt := ""
        if !t.UpdatedAt.IsZero() </span><span class="cov0" title="0">{
                updatedAt = t.UpdatedAt.Format(time.RFC3339)
        }</span>
        <span class="cov8" title="1">offset := ""
        if t.Offset != 0*time.Second </span><span class="cov0" title="0">{
                offset = customParseDuration(t.Offset)
        }</span>

        <span class="cov8" title="1">return Task{
                ID:              t.ID,
                OrganizationID:  t.OrganizationID,
                Organization:    t.Organization,
                OwnerID:         t.OwnerID,
                Name:            t.Name,
                Description:     t.Description,
                Status:          t.Status,
                Flux:            t.Flux,
                Every:           t.Every,
                Cron:            t.Cron,
                Offset:          offset,
                LatestCompleted: latestCompleted,
                LastRunStatus:   t.LastRunStatus,
                LastRunError:    t.LastRunError,
                CreatedAt:       createdAt,
                UpdatedAt:       updatedAt,
                Metadata:        t.Metadata,
        }</span>
}

func convertTask(t Task) *taskmodel.Task <span class="cov0" title="0">{
        var (
                latestCompleted time.Time
                createdAt       time.Time
                updatedAt       time.Time
                offset          time.Duration
        )

        if t.LatestCompleted != "" </span><span class="cov0" title="0">{
                latestCompleted, _ = time.Parse(time.RFC3339, t.LatestCompleted)
        }</span>

        <span class="cov0" title="0">if t.CreatedAt != "" </span><span class="cov0" title="0">{
                createdAt, _ = time.Parse(time.RFC3339, t.CreatedAt)
        }</span>

        <span class="cov0" title="0">if t.UpdatedAt != "" </span><span class="cov0" title="0">{
                updatedAt, _ = time.Parse(time.RFC3339, t.UpdatedAt)
        }</span>

        <span class="cov0" title="0">if t.Offset != "" </span><span class="cov0" title="0">{
                var duration options.Duration
                if err := duration.Parse(t.Offset); err == nil </span><span class="cov0" title="0">{
                        offset, _ = duration.DurationFrom(time.Now())
                }</span>
        }

        <span class="cov0" title="0">return &amp;taskmodel.Task{
                ID:              t.ID,
                OrganizationID:  t.OrganizationID,
                Organization:    t.Organization,
                OwnerID:         t.OwnerID,
                Name:            t.Name,
                Description:     t.Description,
                Status:          t.Status,
                Flux:            t.Flux,
                Every:           t.Every,
                Cron:            t.Cron,
                Offset:          offset,
                LatestCompleted: latestCompleted,
                LastRunStatus:   t.LastRunStatus,
                LastRunError:    t.LastRunError,
                CreatedAt:       createdAt,
                UpdatedAt:       updatedAt,
                Metadata:        t.Metadata,
        }</span>
}

func customParseDuration(d time.Duration) string <span class="cov0" title="0">{
        str := ""
        if d &lt; 0 </span><span class="cov0" title="0">{
                str = "-"
                d = d * -1
        }</span>

        // parse hours
        <span class="cov0" title="0">hours := d / time.Hour
        if hours != 0 </span><span class="cov0" title="0">{
                str = fmt.Sprintf("%s%dh", str, hours)
        }</span>
        <span class="cov0" title="0">if d%time.Hour == 0 </span><span class="cov0" title="0">{
                return str
        }</span>
        // parse minutes
        <span class="cov0" title="0">d = d - (time.Duration(hours) * time.Hour)

        min := d / time.Minute
        if min != 0 </span><span class="cov0" title="0">{
                str = fmt.Sprintf("%s%dm", str, min)
        }</span>
        <span class="cov0" title="0">if d%time.Minute == 0 </span><span class="cov0" title="0">{
                return str
        }</span>

        // parse seconds
        <span class="cov0" title="0">d = d - time.Duration(min)*time.Minute
        sec := d / time.Second

        if sec != 0 </span><span class="cov0" title="0">{
                str = fmt.Sprintf("%s%ds", str, sec)
        }</span>
        <span class="cov0" title="0">return str</span>
}

func newTaskResponse(t taskmodel.Task, labels []*influxdb.Label) taskResponse <span class="cov8" title="1">{
        response := taskResponse{
                Links: map[string]string{
                        "self":    fmt.Sprintf("/api/v2/tasks/%s", t.ID),
                        "members": fmt.Sprintf("/api/v2/tasks/%s/members", t.ID),
                        "owners":  fmt.Sprintf("/api/v2/tasks/%s/owners", t.ID),
                        "labels":  fmt.Sprintf("/api/v2/tasks/%s/labels", t.ID),
                        "runs":    fmt.Sprintf("/api/v2/tasks/%s/runs", t.ID),
                        "logs":    fmt.Sprintf("/api/v2/tasks/%s/logs", t.ID),
                },
                Task:   NewFrontEndTask(t),
                Labels: []influxdb.Label{},
        }

        for _, l := range labels </span><span class="cov8" title="1">{
                response.Labels = append(response.Labels, *l)
        }</span>

        <span class="cov8" title="1">return response</span>
}

func newTasksPagingLinks(basePath string, ts []*taskmodel.Task, f taskmodel.TaskFilter) *influxdb.PagingLinks <span class="cov8" title="1">{
        var self, next string
        u := url.URL{
                Path: basePath,
        }

        values := url.Values{}
        for k, vs := range f.QueryParams() </span><span class="cov8" title="1">{
                for _, v := range vs </span><span class="cov8" title="1">{
                        if v != "" </span><span class="cov8" title="1">{
                                values.Add(k, v)
                        }</span>
                }
        }

        <span class="cov8" title="1">u.RawQuery = values.Encode()
        self = u.String()

        if len(ts) &gt;= f.Limit </span><span class="cov8" title="1">{
                values.Set("after", ts[f.Limit-1].ID.String())
                u.RawQuery = values.Encode()
                next = u.String()
        }</span>

        <span class="cov8" title="1">links := &amp;influxdb.PagingLinks{
                Self: self,
                Next: next,
        }

        return links</span>
}

type tasksResponse struct {
        Links *influxdb.PagingLinks `json:"links"`
        Tasks []taskResponse        `json:"tasks"`
}

func newTasksResponse(ctx context.Context, ts []*taskmodel.Task, f taskmodel.TaskFilter, labelService influxdb.LabelService) tasksResponse <span class="cov8" title="1">{
        rs := tasksResponse{
                Links: newTasksPagingLinks(prefixTasks, ts, f),
                Tasks: make([]taskResponse, len(ts)),
        }

        for i := range ts </span><span class="cov8" title="1">{
                labels, _ := labelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: ts[i].ID, ResourceType: influxdb.TasksResourceType})
                rs.Tasks[i] = newTaskResponse(*ts[i], labels)
        }</span>
        <span class="cov8" title="1">return rs</span>
}

type runResponse struct {
        Links map[string]string `json:"links,omitempty"`
        httpRun
}

// httpRun is a version of the Run object used to communicate over the API
// it uses a pointer to a time.Time instead of a time.Time so that we can pass a nil
// value for empty time values
type httpRun struct {
        ID           platform.ID     `json:"id,omitempty"`
        TaskID       platform.ID     `json:"taskID"`
        Status       string          `json:"status"`
        ScheduledFor *time.Time      `json:"scheduledFor"`
        StartedAt    *time.Time      `json:"startedAt,omitempty"`
        FinishedAt   *time.Time      `json:"finishedAt,omitempty"`
        RequestedAt  *time.Time      `json:"requestedAt,omitempty"`
        Log          []taskmodel.Log `json:"log,omitempty"`
}

func newRunResponse(r taskmodel.Run) runResponse <span class="cov8" title="1">{
        run := httpRun{
                ID:           r.ID,
                TaskID:       r.TaskID,
                Status:       r.Status,
                Log:          r.Log,
                ScheduledFor: &amp;r.ScheduledFor,
        }

        if !r.StartedAt.IsZero() </span><span class="cov8" title="1">{
                run.StartedAt = &amp;r.StartedAt
        }</span>
        <span class="cov8" title="1">if !r.FinishedAt.IsZero() </span><span class="cov8" title="1">{
                run.FinishedAt = &amp;r.FinishedAt
        }</span>
        <span class="cov8" title="1">if !r.RequestedAt.IsZero() </span><span class="cov8" title="1">{
                run.RequestedAt = &amp;r.RequestedAt
        }</span>

        <span class="cov8" title="1">return runResponse{
                Links: map[string]string{
                        "self":  fmt.Sprintf("/api/v2/tasks/%s/runs/%s", r.TaskID, r.ID),
                        "task":  fmt.Sprintf("/api/v2/tasks/%s", r.TaskID),
                        "logs":  fmt.Sprintf("/api/v2/tasks/%s/runs/%s/logs", r.TaskID, r.ID),
                        "retry": fmt.Sprintf("/api/v2/tasks/%s/runs/%s/retry", r.TaskID, r.ID),
                },
                httpRun: run,
        }</span>
}

func convertRun(r httpRun) *taskmodel.Run <span class="cov0" title="0">{
        run := &amp;taskmodel.Run{
                ID:     r.ID,
                TaskID: r.TaskID,
                Status: r.Status,
                Log:    r.Log,
        }

        if r.StartedAt != nil </span><span class="cov0" title="0">{
                run.StartedAt = *r.StartedAt
        }</span>

        <span class="cov0" title="0">if r.FinishedAt != nil </span><span class="cov0" title="0">{
                run.FinishedAt = *r.FinishedAt
        }</span>

        <span class="cov0" title="0">if r.RequestedAt != nil </span><span class="cov0" title="0">{
                run.RequestedAt = *r.RequestedAt
        }</span>

        <span class="cov0" title="0">if r.ScheduledFor != nil </span><span class="cov0" title="0">{
                run.ScheduledFor = *r.ScheduledFor
        }</span>

        <span class="cov0" title="0">return run</span>
}

type runsResponse struct {
        Links map[string]string `json:"links"`
        Runs  []*runResponse    `json:"runs"`
}

func newRunsResponse(rs []*taskmodel.Run, taskID platform.ID) runsResponse <span class="cov8" title="1">{
        r := runsResponse{
                Links: map[string]string{
                        "self": fmt.Sprintf("/api/v2/tasks/%s/runs", taskID),
                        "task": fmt.Sprintf("/api/v2/tasks/%s", taskID),
                },
                Runs: make([]*runResponse, len(rs)),
        }

        for i := range rs </span><span class="cov8" title="1">{
                rs := newRunResponse(*rs[i])
                r.Runs[i] = &amp;rs
        }</span>
        <span class="cov8" title="1">return r</span>
}

func (h *TaskHandler) handleGetTasks(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeGetTasksRequest(ctx, r, h.OrganizationService)
        if err != nil </span><span class="cov8" title="1">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EInvalid,
                        Msg:  "failed to decode request",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">tasks, _, err := h.TaskService.FindTasks(ctx, req.filter)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Tasks retrieved", zap.String("tasks", fmt.Sprint(tasks)))
        if err := encodeResponse(ctx, w, http.StatusOK, newTasksResponse(ctx, tasks, req.filter, h.LabelService)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type getTasksRequest struct {
        filter taskmodel.TaskFilter
}

func decodeGetTasksRequest(ctx context.Context, r *http.Request, orgs influxdb.OrganizationService) (*getTasksRequest, error) <span class="cov8" title="1">{
        qp := r.URL.Query()
        req := &amp;getTasksRequest{}

        if after := qp.Get("after"); after != "" </span><span class="cov8" title="1">{
                id, err := platform.IDFromString(after)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">req.filter.After = id</span>
        }

        <span class="cov8" title="1">if orgName := qp.Get("org"); orgName != "" </span><span class="cov8" title="1">{
                o, err := orgs.FindOrganization(ctx, influxdb.OrganizationFilter{Name: &amp;orgName})
                if err != nil </span><span class="cov8" title="1">{
                        if pErr, ok := err.(*errors2.Error); ok &amp;&amp; pErr != nil </span><span class="cov8" title="1">{
                                if kv.IsNotFound(err) || pErr.Code == errors2.EUnauthorized </span><span class="cov0" title="0">{
                                        return nil, &amp;errors2.Error{
                                                Err: errors.New("org not found or unauthorized"),
                                                Msg: "org " + orgName + " not found or unauthorized",
                                        }
                                }</span>
                        }
                        <span class="cov8" title="1">return nil, err</span>
                }
                <span class="cov8" title="1">req.filter.Organization = o.Name
                req.filter.OrganizationID = &amp;o.ID</span>
        }
        <span class="cov8" title="1">if oid := qp.Get("orgID"); oid != "" </span><span class="cov0" title="0">{
                orgID, err := platform.IDFromString(oid)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req.filter.OrganizationID = orgID</span>
        }

        <span class="cov8" title="1">if userID := qp.Get("user"); userID != "" </span><span class="cov0" title="0">{
                id, err := platform.IDFromString(userID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req.filter.User = id</span>
        }

        <span class="cov8" title="1">if limit := qp.Get("limit"); limit != "" </span><span class="cov8" title="1">{
                lim, err := strconv.Atoi(limit)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if lim &lt; 1 || lim &gt; taskmodel.TaskMaxPageSize </span><span class="cov0" title="0">{
                        return nil, &amp;errors2.Error{
                                Code: errors2.EUnprocessableEntity,
                                Msg:  fmt.Sprintf("limit must be between 1 and %d", taskmodel.TaskMaxPageSize),
                        }
                }</span>
                <span class="cov8" title="1">req.filter.Limit = lim</span>
        } else<span class="cov8" title="1"> {
                req.filter.Limit = taskmodel.TaskDefaultPageSize
        }</span>

        <span class="cov8" title="1">if status := qp.Get("status"); status == "active" </span><span class="cov0" title="0">{
                req.filter.Status = &amp;status
        }</span> else<span class="cov8" title="1"> if status := qp.Get("status"); status == "inactive" </span><span class="cov0" title="0">{
                req.filter.Status = &amp;status
        }</span>

        <span class="cov8" title="1">switch typ := qp.Get("type"); typ </span>{
        case "basic":<span class="cov0" title="0">
                req.filter.Type = &amp;taskmodel.TaskBasicType</span>
        case "system":<span class="cov0" title="0">
                fallthrough</span>
        case "":<span class="cov8" title="1">
                req.filter.Type = &amp;taskmodel.TaskSystemType</span>
        default:<span class="cov0" title="0">
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  fmt.Sprintf("%q is not a valid task type", typ),
                }</span>
        }

        <span class="cov8" title="1">if name := qp.Get("name"); name != "" </span><span class="cov0" title="0">{
                req.filter.Name = &amp;name
        }</span>

        <span class="cov8" title="1">return req, nil</span>
}

func (h *TaskHandler) handlePostTask(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodePostTaskRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EInvalid,
                        Msg:  "failed to decode request",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := h.populateTaskCreateOrg(ctx, &amp;req.TaskCreate); err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err: err,
                        Msg: "could not identify organization",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if !req.TaskCreate.OrganizationID.Valid() </span><span class="cov0" title="0">{
                err := &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "invalid organization id",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">task, err := h.TaskService.CreateTask(ctx, req.TaskCreate)
        if err != nil </span><span class="cov8" title="1">{
                if e, ok := err.(AuthzError); ok </span><span class="cov0" title="0">{
                        h.log.Error("Failed authentication", zap.Errors("error messages", []error{err, e.AuthzError()}))
                }</span>

                // if the error is not already a influxdb.error then make it into one
                <span class="cov8" title="1">if _, ok := err.(*errors2.Error); !ok </span><span class="cov8" title="1">{
                        err = &amp;errors2.Error{
                                Err:  err,
                                Code: errors2.EInternal,
                                Msg:  "failed to create task",
                        }
                }</span>

                <span class="cov8" title="1">h.HandleHTTPError(ctx, err, w)
                return</span>
        }

        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusCreated, newTaskResponse(*task, []*influxdb.Label{})); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type postTaskRequest struct {
        TaskCreate taskmodel.TaskCreate
}

func decodePostTaskRequest(ctx context.Context, r *http.Request) (*postTaskRequest, error) <span class="cov8" title="1">{
        var tc taskmodel.TaskCreate
        if err := json.NewDecoder(r.Body).Decode(&amp;tc); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // pull auth from ctx, populate OwnerID
        <span class="cov8" title="1">auth, err := pcontext.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tc.OwnerID = auth.GetUserID()
        // when creating a task we set the type so we can filter later.
        tc.Type = taskmodel.TaskSystemType

        if err := tc.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;postTaskRequest{
                TaskCreate: tc,
        }, nil</span>
}

func (h *TaskHandler) handleGetTask(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeGetTaskRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EInvalid,
                        Msg:  "failed to decode request",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">task, err := h.TaskService.FindTaskByID(ctx, req.TaskID)
        if err != nil </span><span class="cov8" title="1">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.ENotFound,
                        Msg:  "failed to find task",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: task.ID, ResourceType: influxdb.TasksResourceType})
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err: err,
                        Msg: "failed to find resource labels",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Task retrieved", zap.String("tasks", fmt.Sprint(task)))
        if err := encodeResponse(ctx, w, http.StatusOK, newTaskResponse(*task, labels)); err != nil </span><span class="cov8" title="1">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type getTaskRequest struct {
        TaskID platform.ID
}

func decodeGetTaskRequest(ctx context.Context, r *http.Request) (*getTaskRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req := &amp;getTaskRequest{
                TaskID: i,
        }

        return req, nil</span>
}

func (h *TaskHandler) handleUpdateTask(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeUpdateTaskRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EInvalid,
                        Msg:  "failed to decode request",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">task, err := h.TaskService.UpdateTask(ctx, req.TaskID, req.Update)
        if err != nil </span><span class="cov8" title="1">{
                err := &amp;errors2.Error{
                        Err: err,
                        Msg: "failed to update task",
                }
                if err.Err == taskmodel.ErrTaskNotFound </span><span class="cov8" title="1">{
                        err.Code = errors2.ENotFound
                }</span>
                <span class="cov8" title="1">h.HandleHTTPError(ctx, err, w)
                return</span>
        }

        <span class="cov8" title="1">labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: task.ID, ResourceType: influxdb.TasksResourceType})
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err: err,
                        Msg: "failed to find resource labels",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Tasks updated", zap.String("task", fmt.Sprint(task)))
        if err := encodeResponse(ctx, w, http.StatusOK, newTaskResponse(*task, labels)); err != nil </span><span class="cov8" title="1">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type updateTaskRequest struct {
        Update taskmodel.TaskUpdate
        TaskID platform.ID
}

func decodeUpdateTaskRequest(ctx context.Context, r *http.Request) (*updateTaskRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "you must provide a task ID",
                }
        }</span>

        <span class="cov8" title="1">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var upd taskmodel.TaskUpdate
        if err := json.NewDecoder(r.Body).Decode(&amp;upd); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := upd.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;updateTaskRequest{
                Update: upd,
                TaskID: i,
        }, nil</span>
}

func (h *TaskHandler) handleDeleteTask(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeDeleteTaskRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EInvalid,
                        Msg:  "failed to decode request",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if err := h.TaskService.DeleteTask(ctx, req.TaskID); err != nil </span><span class="cov8" title="1">{
                err := &amp;errors2.Error{
                        Err: err,
                        Msg: "failed to delete task",
                }
                if err.Err == taskmodel.ErrTaskNotFound </span><span class="cov8" title="1">{
                        err.Code = errors2.ENotFound
                }</span>
                <span class="cov8" title="1">h.HandleHTTPError(ctx, err, w)
                return</span>
        }
        <span class="cov8" title="1">h.log.Debug("Tasks deleted", zap.String("taskID", fmt.Sprint(req.TaskID)))
        w.WriteHeader(http.StatusNoContent)</span>
}

type deleteTaskRequest struct {
        TaskID platform.ID
}

func decodeDeleteTaskRequest(ctx context.Context, r *http.Request) (*deleteTaskRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "you must provide a task ID",
                }
        }</span>

        <span class="cov8" title="1">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;deleteTaskRequest{
                TaskID: i,
        }, nil</span>
}

func (h *TaskHandler) handleGetLogs(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        req, err := decodeGetLogsRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EInvalid,
                        Msg:  "failed to decode request",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">auth, err := pcontext.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EUnauthorized,
                        Msg:  "failed to get authorizer",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if k := auth.Kind(); k != influxdb.AuthorizationKind </span><span class="cov0" title="0">{
                // Get the authorization for the task, if allowed.
                authz, err := h.getAuthorizationForTask(ctx, auth, req.filter.Task)
                if err != nil </span><span class="cov0" title="0">{
                        h.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                // We were able to access the authorizer for the task, so reassign that on the context for the rest of this call.
                <span class="cov0" title="0">ctx = pcontext.SetAuthorizer(ctx, authz)</span>
        }

        <span class="cov8" title="1">logs, _, err := h.TaskService.FindLogs(ctx, req.filter)
        if err != nil </span><span class="cov8" title="1">{
                err := &amp;errors2.Error{
                        Err: err,
                        Msg: "failed to find task logs",
                }
                if err.Err == taskmodel.ErrTaskNotFound || err.Err == taskmodel.ErrNoRunsFound </span><span class="cov8" title="1">{
                        err.Code = errors2.ENotFound
                }</span>
                <span class="cov8" title="1">h.HandleHTTPError(ctx, err, w)
                return</span>
        }

        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusOK, &amp;getLogsResponse{Events: logs}); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type getLogsRequest struct {
        filter taskmodel.LogFilter
}

type getLogsResponse struct {
        Events []*taskmodel.Log `json:"events"`
}

func decodeGetLogsRequest(ctx context.Context, r *http.Request) (*getLogsRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "you must provide a task ID",
                }
        }</span>

        <span class="cov8" title="1">req := &amp;getLogsRequest{}
        taskID, err := platform.IDFromString(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.filter.Task = *taskID

        if runID := params.ByName("rid"); runID != "" </span><span class="cov8" title="1">{
                id, err := platform.IDFromString(runID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">req.filter.Run = id</span>
        }

        <span class="cov8" title="1">return req, nil</span>
}

func (h *TaskHandler) handleGetRuns(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        req, err := decodeGetRunsRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EInvalid,
                        Msg:  "failed to decode request",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">auth, err := pcontext.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EUnauthorized,
                        Msg:  "failed to get authorizer",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if k := auth.Kind(); k != influxdb.AuthorizationKind </span><span class="cov0" title="0">{
                // Get the authorization for the task, if allowed.
                authz, err := h.getAuthorizationForTask(ctx, auth, req.filter.Task)
                if err != nil </span><span class="cov0" title="0">{
                        h.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                // We were able to access the authorizer for the task, so reassign that on the context for the rest of this call.
                <span class="cov0" title="0">ctx = pcontext.SetAuthorizer(ctx, authz)</span>
        }

        <span class="cov8" title="1">runs, _, err := h.TaskService.FindRuns(ctx, req.filter)
        if err != nil </span><span class="cov8" title="1">{
                err := &amp;errors2.Error{
                        Err: err,
                        Msg: "failed to find runs",
                }
                if err.Err == taskmodel.ErrTaskNotFound || err.Err == taskmodel.ErrNoRunsFound </span><span class="cov8" title="1">{
                        err.Code = errors2.ENotFound
                }</span>
                <span class="cov8" title="1">h.HandleHTTPError(ctx, err, w)
                return</span>
        }

        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusOK, newRunsResponse(runs, req.filter.Task)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type getRunsRequest struct {
        filter taskmodel.RunFilter
}

func decodeGetRunsRequest(ctx context.Context, r *http.Request) (*getRunsRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "you must provide a task ID",
                }
        }</span>

        <span class="cov8" title="1">req := &amp;getRunsRequest{}
        taskID, err := platform.IDFromString(id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">req.filter.Task = *taskID

        qp := r.URL.Query()

        if id := qp.Get("after"); id != "" </span><span class="cov0" title="0">{
                afterID, err := platform.IDFromString(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req.filter.After = afterID</span>
        }

        <span class="cov8" title="1">if limit := qp.Get("limit"); limit != "" </span><span class="cov0" title="0">{
                i, err := strconv.Atoi(limit)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if i &lt; 1 || i &gt; taskmodel.TaskMaxPageSize </span><span class="cov0" title="0">{
                        return nil, taskmodel.ErrOutOfBoundsLimit
                }</span>
                <span class="cov0" title="0">req.filter.Limit = i</span>
        }

        <span class="cov8" title="1">var at, bt string
        var afterTime, beforeTime time.Time
        if at = qp.Get("afterTime"); at != "" </span><span class="cov0" title="0">{
                afterTime, err = time.Parse(time.RFC3339, at)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req.filter.AfterTime = at</span>
        }

        <span class="cov8" title="1">if bt = qp.Get("beforeTime"); bt != "" </span><span class="cov0" title="0">{
                beforeTime, err = time.Parse(time.RFC3339, bt)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">req.filter.BeforeTime = bt</span>
        }

        <span class="cov8" title="1">if at != "" &amp;&amp; bt != "" &amp;&amp; !beforeTime.After(afterTime) </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EUnprocessableEntity,
                        Msg:  "beforeTime must be later than afterTime",
                }
        }</span>

        <span class="cov8" title="1">return req, nil</span>
}

func (h *TaskHandler) handleForceRun(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        req, err := decodeForceRunRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EInvalid,
                        Msg:  "failed to decode request",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">run, err := h.TaskService.ForceRun(ctx, req.TaskID, req.Timestamp)
        if err != nil </span><span class="cov8" title="1">{
                err := &amp;errors2.Error{
                        Err: err,
                        Msg: "failed to force run",
                }
                if err.Err == taskmodel.ErrTaskNotFound </span><span class="cov8" title="1">{
                        err.Code = errors2.ENotFound
                }</span>
                <span class="cov8" title="1">h.HandleHTTPError(ctx, err, w)
                return</span>
        }
        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusCreated, newRunResponse(*run)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type forceRunRequest struct {
        TaskID    platform.ID
        Timestamp int64
}

func decodeForceRunRequest(ctx context.Context, r *http.Request) (forceRunRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        tid := params.ByName("id")
        if tid == "" </span><span class="cov0" title="0">{
                return forceRunRequest{}, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "you must provide a task ID",
                }
        }</span>

        <span class="cov8" title="1">var ti platform.ID
        if err := ti.DecodeFromString(tid); err != nil </span><span class="cov0" title="0">{
                return forceRunRequest{}, err
        }</span>

        <span class="cov8" title="1">var req struct {
                ScheduledFor string `json:"scheduledFor"`
        }

        if r.ContentLength != 0 &amp;&amp; r.ContentLength &lt; 1000 </span><span class="cov8" title="1">{ // prevent attempts to use up memory since r.Body should include at most one item (RunManually)
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        return forceRunRequest{}, err
                }</span>
        }

        <span class="cov8" title="1">var t time.Time
        if req.ScheduledFor == "" </span><span class="cov8" title="1">{
                t = time.Now()
        }</span> else<span class="cov0" title="0"> {
                var err error
                t, err = time.Parse(time.RFC3339, req.ScheduledFor)
                if err != nil </span><span class="cov0" title="0">{
                        return forceRunRequest{}, err
                }</span>
        }

        <span class="cov8" title="1">return forceRunRequest{
                TaskID:    ti,
                Timestamp: t.Unix(),
        }, nil</span>
}

func (h *TaskHandler) handleGetRun(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        req, err := decodeGetRunRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EInvalid,
                        Msg:  "failed to decode request",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">auth, err := pcontext.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EUnauthorized,
                        Msg:  "failed to get authorizer",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if k := auth.Kind(); k != influxdb.AuthorizationKind </span><span class="cov0" title="0">{
                // Get the authorization for the task, if allowed.
                authz, err := h.getAuthorizationForTask(ctx, auth, req.TaskID)
                if err != nil </span><span class="cov0" title="0">{
                        h.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                // We were able to access the authorizer for the task, so reassign that on the context for the rest of this call.
                <span class="cov0" title="0">ctx = pcontext.SetAuthorizer(ctx, authz)</span>
        }

        <span class="cov8" title="1">run, err := h.TaskService.FindRunByID(ctx, req.TaskID, req.RunID)
        if err != nil </span><span class="cov8" title="1">{
                err := &amp;errors2.Error{
                        Err: err,
                        Msg: "failed to find run",
                }
                if err.Err == taskmodel.ErrTaskNotFound || err.Err == taskmodel.ErrRunNotFound </span><span class="cov8" title="1">{
                        err.Code = errors2.ENotFound
                }</span>
                <span class="cov8" title="1">h.HandleHTTPError(ctx, err, w)
                return</span>
        }

        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusOK, newRunResponse(*run)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type getRunRequest struct {
        TaskID platform.ID
        RunID  platform.ID
}

func decodeGetRunRequest(ctx context.Context, r *http.Request) (*getRunRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        tid := params.ByName("id")
        if tid == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "you must provide a task ID",
                }
        }</span>
        <span class="cov8" title="1">rid := params.ByName("rid")
        if rid == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "you must provide a run ID",
                }
        }</span>

        <span class="cov8" title="1">var ti, ri platform.ID
        if err := ti.DecodeFromString(tid); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := ri.DecodeFromString(rid); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;getRunRequest{
                RunID:  ri,
                TaskID: ti,
        }, nil</span>
}

type cancelRunRequest struct {
        RunID  platform.ID
        TaskID platform.ID
}

func decodeCancelRunRequest(ctx context.Context, r *http.Request) (*cancelRunRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        rid := params.ByName("rid")
        if rid == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "you must provide a run ID",
                }
        }</span>
        <span class="cov8" title="1">tid := params.ByName("id")
        if tid == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "you must provide a task ID",
                }
        }</span>

        <span class="cov8" title="1">var i platform.ID
        if err := i.DecodeFromString(rid); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">var t platform.ID
        if err := t.DecodeFromString(tid); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;cancelRunRequest{
                RunID:  i,
                TaskID: t,
        }, nil</span>
}

func (h *TaskHandler) handleCancelRun(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        req, err := decodeCancelRunRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EInvalid,
                        Msg:  "failed to decode request",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">err = h.TaskService.CancelRun(ctx, req.TaskID, req.RunID)
        if err != nil </span><span class="cov8" title="1">{
                err := &amp;errors2.Error{
                        Err: err,
                        Msg: "failed to cancel run",
                }
                if err.Err == taskmodel.ErrTaskNotFound || err.Err == taskmodel.ErrRunNotFound </span><span class="cov8" title="1">{
                        err.Code = errors2.ENotFound
                }</span>
                <span class="cov8" title="1">h.HandleHTTPError(ctx, err, w)
                return</span>
        }
}

func (h *TaskHandler) handleRetryRun(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()

        req, err := decodeRetryRunRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EInvalid,
                        Msg:  "failed to decode request",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">auth, err := pcontext.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                err = &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EUnauthorized,
                        Msg:  "failed to get authorizer",
                }
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">if k := auth.Kind(); k != influxdb.AuthorizationKind </span><span class="cov0" title="0">{
                // Get the authorization for the task, if allowed.
                authz, err := h.getAuthorizationForTask(ctx, auth, req.TaskID)
                if err != nil </span><span class="cov0" title="0">{
                        h.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                // We were able to access the authorizer for the task, so reassign that on the context for the rest of this call.
                <span class="cov0" title="0">ctx = pcontext.SetAuthorizer(ctx, authz)</span>
        }

        <span class="cov8" title="1">run, err := h.TaskService.RetryRun(ctx, req.TaskID, req.RunID)
        if err != nil </span><span class="cov8" title="1">{
                err := &amp;errors2.Error{
                        Err: err,
                        Msg: "failed to retry run",
                }
                if err.Err == taskmodel.ErrTaskNotFound || err.Err == taskmodel.ErrRunNotFound </span><span class="cov8" title="1">{
                        err.Code = errors2.ENotFound
                }</span>
                <span class="cov8" title="1">h.HandleHTTPError(ctx, err, w)
                return</span>
        }
        <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusOK, newRunResponse(*run)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type retryRunRequest struct {
        RunID, TaskID platform.ID
}

func decodeRetryRunRequest(ctx context.Context, r *http.Request) (*retryRunRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        tid := params.ByName("id")
        if tid == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "you must provide a task ID",
                }
        }</span>
        <span class="cov8" title="1">rid := params.ByName("rid")
        if rid == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EInvalid,
                        Msg:  "you must provide a run ID",
                }
        }</span>

        <span class="cov8" title="1">var ti, ri platform.ID
        if err := ti.DecodeFromString(tid); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := ri.DecodeFromString(rid); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;retryRunRequest{
                RunID:  ri,
                TaskID: ti,
        }, nil</span>
}

func (h *TaskHandler) populateTaskCreateOrg(ctx context.Context, tc *taskmodel.TaskCreate) error <span class="cov8" title="1">{
        if tc.OrganizationID.Valid() &amp;&amp; tc.Organization != "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if !tc.OrganizationID.Valid() &amp;&amp; tc.Organization == "" </span><span class="cov0" title="0">{
                return errors.New("missing orgID and organization name")
        }</span>

        <span class="cov8" title="1">if tc.OrganizationID.Valid() </span><span class="cov8" title="1">{
                o, err := h.OrganizationService.FindOrganizationByID(ctx, tc.OrganizationID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">tc.Organization = o.Name</span>
        } else<span class="cov8" title="1"> {
                o, err := h.OrganizationService.FindOrganization(ctx, influxdb.OrganizationFilter{Name: &amp;tc.Organization})
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">tc.OrganizationID = o.ID</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// getAuthorizationForTask looks up the authorization associated with taskID,
// ensuring that the authorizer on ctx is allowed to view the task and the authorization.
//
// This method returns a *influxdb.Error, suitable for directly passing to h.HandleHTTPError.
func (h *TaskHandler) getAuthorizationForTask(ctx context.Context, auth influxdb.Authorizer, taskID platform.ID) (*influxdb.Authorization, *errors2.Error) <span class="cov0" title="0">{
        sess, ok := auth.(*influxdb.Session)
        if !ok </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Code: errors2.EUnauthorized,
                        Msg:  "unable to authorize session",
                }
        }</span>
        // First look up the task, if we're allowed.
        // This assumes h.TaskService validates access.
        <span class="cov0" title="0">t, err := h.TaskService.FindTaskByID(ctx, taskID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors2.Error{
                        Err:  err,
                        Code: errors2.EUnauthorized,
                        Msg:  "task ID unknown or unauthorized",
                }
        }</span>

        <span class="cov0" title="0">return sess.EphemeralAuth(t.OrganizationID), nil</span>
}

// TaskService connects to Influx via HTTP using tokens to manage tasks.
type TaskService struct {
        Client *httpc.Client
}

// FindTaskByID returns a single task
func (t TaskService) FindTaskByID(ctx context.Context, id platform.ID) (*taskmodel.Task, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        var tr taskResponse
        err := t.Client.Get(taskIDPath(id)).DecodeJSON(&amp;tr).Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return convertTask(tr.Task), nil</span>
}

// FindTasks returns a list of tasks that match a filter (limit 100) and the total count
// of matching tasks.
func (t TaskService) FindTasks(ctx context.Context, filter taskmodel.TaskFilter) ([]*taskmodel.Task, int, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        // slice of 2-capacity string slices for storing parameter key-value pairs
        var params [][2]string

        if filter.After != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"after", filter.After.String()})
        }</span>
        <span class="cov0" title="0">if filter.OrganizationID != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"orgID", filter.OrganizationID.String()})
        }</span>
        <span class="cov0" title="0">if filter.Organization != "" </span><span class="cov0" title="0">{
                params = append(params, [2]string{"org", filter.Organization})
        }</span>
        <span class="cov0" title="0">if filter.User != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"user", filter.User.String()})
        }</span>
        <span class="cov0" title="0">if filter.Limit != 0 </span><span class="cov0" title="0">{
                params = append(params, [2]string{"limit", strconv.Itoa(filter.Limit)})
        }</span>

        <span class="cov0" title="0">if filter.Status != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"status", *filter.Status})
        }</span>

        <span class="cov0" title="0">if filter.Type != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"type", *filter.Type})
        }</span>

        <span class="cov0" title="0">var tr tasksResponse
        err := t.Client.
                Get(prefixTasks).
                QueryParams(params...).
                DecodeJSON(&amp;tr).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">tasks := make([]*taskmodel.Task, len(tr.Tasks))
        for i := range tr.Tasks </span><span class="cov0" title="0">{
                tasks[i] = convertTask(tr.Tasks[i].Task)
        }</span>
        <span class="cov0" title="0">return tasks, len(tasks), nil</span>
}

// CreateTask creates a new task.
func (t TaskService) CreateTask(ctx context.Context, tc taskmodel.TaskCreate) (*taskmodel.Task, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()
        var tr taskResponse

        err := t.Client.
                PostJSON(tc, prefixTasks).
                DecodeJSON(&amp;tr).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return convertTask(tr.Task), nil</span>
}

// UpdateTask updates a single task with changeset.
func (t TaskService) UpdateTask(ctx context.Context, id platform.ID, upd taskmodel.TaskUpdate) (*taskmodel.Task, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        var tr taskResponse
        err := t.Client.
                PatchJSON(&amp;upd, taskIDPath(id)).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return convertTask(tr.Task), nil</span>
}

// DeleteTask removes a task by ID and purges all associated data and scheduled runs.
func (t TaskService) DeleteTask(ctx context.Context, id platform.ID) error <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        return t.Client.
                Delete(taskIDPath(id)).
                Do(ctx)
}</span>

// FindLogs returns logs for a run.
func (t TaskService) FindLogs(ctx context.Context, filter taskmodel.LogFilter) ([]*taskmodel.Log, int, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        if !filter.Task.Valid() </span><span class="cov0" title="0">{
                return nil, 0, errors.New("task ID required")
        }</span>

        <span class="cov0" title="0">var urlPath string
        if filter.Run == nil </span><span class="cov0" title="0">{
                urlPath = path.Join(taskIDPath(filter.Task), "logs")
        }</span> else<span class="cov0" title="0"> {
                urlPath = path.Join(taskIDRunIDPath(filter.Task, *filter.Run), "logs")
        }</span>

        <span class="cov0" title="0">var logs getLogsResponse
        err := t.Client.
                Get(urlPath).
                DecodeJSON(&amp;logs).
                Do(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return logs.Events, len(logs.Events), nil</span>
}

// FindRuns returns a list of runs that match a filter and the total count of returned runs.
func (t TaskService) FindRuns(ctx context.Context, filter taskmodel.RunFilter) ([]*taskmodel.Run, int, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        var params [][2]string

        if !filter.Task.Valid() </span><span class="cov0" title="0">{
                return nil, 0, errors.New("task ID required")
        }</span>

        <span class="cov0" title="0">if filter.After != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"after", filter.After.String()})
        }</span>

        <span class="cov0" title="0">if filter.Limit &lt; 0 || filter.Limit &gt; taskmodel.TaskMaxPageSize </span><span class="cov0" title="0">{
                return nil, 0, taskmodel.ErrOutOfBoundsLimit
        }</span>

        <span class="cov0" title="0">params = append(params, [2]string{"limit", strconv.Itoa(filter.Limit)})

        var rs runsResponse
        err := t.Client.
                Get(taskIDRunsPath(filter.Task)).
                QueryParams(params...).
                DecodeJSON(&amp;rs).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">runs := make([]*taskmodel.Run, len(rs.Runs))
        for i := range rs.Runs </span><span class="cov0" title="0">{
                runs[i] = convertRun(rs.Runs[i].httpRun)
        }</span>

        <span class="cov0" title="0">return runs, len(runs), nil</span>
}

// FindRunByID returns a single run of a specific task.
func (t TaskService) FindRunByID(ctx context.Context, taskID, runID platform.ID) (*taskmodel.Run, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        var rs = &amp;runResponse{}
        err := t.Client.
                Get(taskIDRunIDPath(taskID, runID)).
                DecodeJSON(rs).
                Do(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if errors2.ErrorCode(err) == errors2.ENotFound </span><span class="cov0" title="0">{
                        // ErrRunNotFound is expected as part of the FindRunByID contract,
                        // so return that actual error instead of a different error that looks like it.
                        // TODO cleanup backend error implementation
                        return nil, taskmodel.ErrRunNotFound
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return convertRun(rs.httpRun), nil</span>
}

// RetryRun creates and returns a new run (which is a retry of another run).
func (t TaskService) RetryRun(ctx context.Context, taskID, runID platform.ID) (*taskmodel.Run, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        var rs runResponse
        err := t.Client.
                Post(nil, path.Join(taskIDRunIDPath(taskID, runID), "retry")).
                DecodeJSON(&amp;rs).
                Do(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if errors2.ErrorCode(err) == errors2.ENotFound </span><span class="cov0" title="0">{
                        // ErrRunNotFound is expected as part of the RetryRun contract,
                        // so return that actual error instead of a different error that looks like it.
                        // TODO cleanup backend task error implementation
                        return nil, taskmodel.ErrRunNotFound
                }</span>
                // RequestStillQueuedError is also part of the contract.
                <span class="cov0" title="0">if e := taskmodel.ParseRequestStillQueuedError(err.Error()); e != nil </span><span class="cov0" title="0">{
                        return nil, *e
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return convertRun(rs.httpRun), nil</span>
}

// ForceRun starts a run manually right now.
func (t TaskService) ForceRun(ctx context.Context, taskID platform.ID, scheduledFor int64) (*taskmodel.Run, error) <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        type body struct {
                scheduledFor string
        }
        b := body{scheduledFor: time.Unix(scheduledFor, 0).UTC().Format(time.RFC3339)}

        rs := &amp;runResponse{}
        err := t.Client.
                PostJSON(b, taskIDRunsPath(taskID)).
                DecodeJSON(&amp;rs).
                Do(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if errors2.ErrorCode(err) == errors2.ENotFound </span><span class="cov0" title="0">{
                        // ErrRunNotFound is expected as part of the RetryRun contract,
                        // so return that actual error instead of a different error that looks like it.
                        return nil, taskmodel.ErrRunNotFound
                }</span>

                // RequestStillQueuedError is also part of the contract.
                <span class="cov0" title="0">if e := taskmodel.ParseRequestStillQueuedError(err.Error()); e != nil </span><span class="cov0" title="0">{
                        return nil, *e
                }</span>

                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return convertRun(rs.httpRun), nil</span>
}

func cancelPath(taskID, runID platform.ID) string <span class="cov0" title="0">{
        return path.Join(taskID.String(), runID.String())
}</span>

// CancelRun stops a longer running run.
func (t TaskService) CancelRun(ctx context.Context, taskID, runID platform.ID) error <span class="cov0" title="0">{
        span, _ := tracing.StartSpanFromContext(ctx)
        defer span.Finish()

        err := t.Client.
                Delete(cancelPath(taskID, runID)).
                Do(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func taskIDPath(id platform.ID) string <span class="cov0" title="0">{
        return path.Join(prefixTasks, id.String())
}</span>

func taskIDRunsPath(id platform.ID) string <span class="cov0" title="0">{
        return path.Join(prefixTasks, id.String(), "runs")
}</span>

func taskIDRunIDPath(taskID, runID platform.ID) string <span class="cov0" title="0">{
        return path.Join(prefixTasks, taskID.String(), "runs", runID.String())
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package http

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "github.com/golang/gddo/httputil"
        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        pctx "github.com/influxdata/influxdb/v2/context"
        "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/pkg/httpc"
        "github.com/influxdata/influxdb/v2/telegraf/plugins"
        "go.uber.org/zap"
)

// TelegrafBackend is all services and associated parameters required to construct
// the TelegrafHandler.
type TelegrafBackend struct {
        errors.HTTPErrorHandler
        log *zap.Logger

        TelegrafService            influxdb.TelegrafConfigStore
        UserResourceMappingService influxdb.UserResourceMappingService
        LabelService               influxdb.LabelService
        UserService                influxdb.UserService
        OrganizationService        influxdb.OrganizationService
}

// NewTelegrafBackend returns a new instance of TelegrafBackend.
func NewTelegrafBackend(log *zap.Logger, b *APIBackend) *TelegrafBackend <span class="cov8" title="1">{
        return &amp;TelegrafBackend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,

                TelegrafService:            b.TelegrafService,
                UserResourceMappingService: b.UserResourceMappingService,
                LabelService:               b.LabelService,
                UserService:                b.UserService,
                OrganizationService:        b.OrganizationService,
        }
}</span>

// TelegrafHandler is the handler for the telegraf service
type TelegrafHandler struct {
        *httprouter.Router
        errors.HTTPErrorHandler
        log *zap.Logger

        TelegrafService            influxdb.TelegrafConfigStore
        UserResourceMappingService influxdb.UserResourceMappingService
        LabelService               influxdb.LabelService
        UserService                influxdb.UserService
        OrganizationService        influxdb.OrganizationService
}

const (
        prefixTelegraf           = "/api/v2/telegrafs"
        telegrafsIDPath          = "/api/v2/telegrafs/:id"
        telegrafsIDMembersPath   = "/api/v2/telegrafs/:id/members"
        telegrafsIDMembersIDPath = "/api/v2/telegrafs/:id/members/:userID"
        telegrafsIDOwnersPath    = "/api/v2/telegrafs/:id/owners"
        telegrafsIDOwnersIDPath  = "/api/v2/telegrafs/:id/owners/:userID"
        telegrafsIDLabelsPath    = "/api/v2/telegrafs/:id/labels"
        telegrafsIDLabelsIDPath  = "/api/v2/telegrafs/:id/labels/:lid"

        prefixTelegrafPlugins = "/api/v2/telegraf"
        telegrafPluginsPath   = "/api/v2/telegraf/plugins"
)

// NewTelegrafHandler returns a new instance of TelegrafHandler.
func NewTelegrafHandler(log *zap.Logger, b *TelegrafBackend) *TelegrafHandler <span class="cov8" title="1">{
        h := &amp;TelegrafHandler{
                Router:           NewRouter(b.HTTPErrorHandler),
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,

                TelegrafService:            b.TelegrafService,
                UserResourceMappingService: b.UserResourceMappingService,
                LabelService:               b.LabelService,
                UserService:                b.UserService,
                OrganizationService:        b.OrganizationService,
        }
        h.HandlerFunc("POST", prefixTelegraf, h.handlePostTelegraf)
        h.HandlerFunc("GET", prefixTelegraf, h.handleGetTelegrafs)
        h.HandlerFunc("GET", telegrafsIDPath, h.handleGetTelegraf)
        h.HandlerFunc("DELETE", telegrafsIDPath, h.handleDeleteTelegraf)
        h.HandlerFunc("PUT", telegrafsIDPath, h.handlePutTelegraf)

        h.HandlerFunc("GET", telegrafPluginsPath, h.handleGetTelegrafPlugins)

        memberBackend := MemberBackend{
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        b.log.With(zap.String("handler", "member")),
                ResourceType:               influxdb.TelegrafsResourceType,
                UserType:                   influxdb.Member,
                UserResourceMappingService: b.UserResourceMappingService,
                UserService:                b.UserService,
        }
        h.HandlerFunc("POST", telegrafsIDMembersPath, newPostMemberHandler(memberBackend))
        h.HandlerFunc("GET", telegrafsIDMembersPath, newGetMembersHandler(memberBackend))
        h.HandlerFunc("DELETE", telegrafsIDMembersIDPath, newDeleteMemberHandler(memberBackend))

        ownerBackend := MemberBackend{
                HTTPErrorHandler:           b.HTTPErrorHandler,
                log:                        b.log.With(zap.String("handler", "member")),
                ResourceType:               influxdb.TelegrafsResourceType,
                UserType:                   influxdb.Owner,
                UserResourceMappingService: b.UserResourceMappingService,
                UserService:                b.UserService,
        }
        h.HandlerFunc("POST", telegrafsIDOwnersPath, newPostMemberHandler(ownerBackend))
        h.HandlerFunc("GET", telegrafsIDOwnersPath, newGetMembersHandler(ownerBackend))
        h.HandlerFunc("DELETE", telegrafsIDOwnersIDPath, newDeleteMemberHandler(ownerBackend))

        labelBackend := &amp;LabelBackend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              b.log.With(zap.String("handler", "label")),
                LabelService:     b.LabelService,
                ResourceType:     influxdb.TelegrafsResourceType,
        }
        h.HandlerFunc("GET", telegrafsIDLabelsPath, newGetLabelsHandler(labelBackend))
        h.HandlerFunc("POST", telegrafsIDLabelsPath, newPostLabelHandler(labelBackend))
        h.HandlerFunc("DELETE", telegrafsIDLabelsIDPath, newDeleteLabelHandler(labelBackend))

        return h
}</span>

type telegrafLinks struct {
        Self    string `json:"self"`
        Labels  string `json:"labels"`
        Members string `json:"members"`
        Owners  string `json:"owners"`
}

type telegrafResponse struct {
        *influxdb.TelegrafConfig
        Labels []influxdb.Label `json:"labels"`
        Links  telegrafLinks    `json:"links"`
}

type telegrafResponses struct {
        TelegrafConfigs []*telegrafResponse `json:"configurations"`
}

func getTelegrafPlugins(t string) (*plugins.TelegrafPlugins, error) <span class="cov0" title="0">{
        if len(t) == 0 </span><span class="cov0" title="0">{
                return plugins.AvailablePlugins()
        }</span>

        <span class="cov0" title="0">return plugins.ListAvailablePlugins(t)</span>
}

func (h *TelegrafHandler) handleGetTelegrafPlugins(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        telPlugins, err := getTelegrafPlugins(r.URL.Query().Get("type"))
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">if err := encodeResponse(ctx, w, http.StatusOK, telPlugins); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func newTelegrafResponse(tc *influxdb.TelegrafConfig, labels []*influxdb.Label) *telegrafResponse <span class="cov8" title="1">{
        res := &amp;telegrafResponse{
                TelegrafConfig: tc,
                Links: telegrafLinks{
                        Self:    fmt.Sprintf("/api/v2/telegrafs/%s", tc.ID),
                        Labels:  fmt.Sprintf("/api/v2/telegrafs/%s/labels", tc.ID),
                        Members: fmt.Sprintf("/api/v2/telegrafs/%s/members", tc.ID),
                        Owners:  fmt.Sprintf("/api/v2/telegrafs/%s/owners", tc.ID),
                },
                Labels: []influxdb.Label{},
        }

        for _, l := range labels </span><span class="cov0" title="0">{
                res.Labels = append(res.Labels, *l)
        }</span>

        <span class="cov8" title="1">return res</span>
}

func newTelegrafResponses(ctx context.Context, tcs []*influxdb.TelegrafConfig, labelService influxdb.LabelService) *telegrafResponses <span class="cov8" title="1">{
        resp := &amp;telegrafResponses{
                TelegrafConfigs: make([]*telegrafResponse, len(tcs)),
        }
        for i, c := range tcs </span><span class="cov8" title="1">{
                labels, _ := labelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: c.ID, ResourceType: influxdb.TelegrafsResourceType})
                resp.TelegrafConfigs[i] = newTelegrafResponse(c, labels)
        }</span>
        <span class="cov8" title="1">return resp</span>
}

func decodeGetTelegrafRequest(ctx context.Context) (i platform.ID, err error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return i, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return i, err
        }</span>
        <span class="cov8" title="1">return i, nil</span>
}

func (h *TelegrafHandler) handleGetTelegrafs(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        filter, err := decodeTelegrafConfigFilter(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">tcs, _, err := h.TelegrafService.FindTelegrafConfigs(ctx, *filter)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Telegrafs retrieved", zap.String("telegrafs", fmt.Sprint(tcs)))

        if err := encodeResponse(ctx, w, http.StatusOK, newTelegrafResponses(ctx, tcs, h.LabelService)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func (h *TelegrafHandler) handleGetTelegraf(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        id, err := decodeGetTelegrafRequest(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">tc, err := h.TelegrafService.FindTelegrafConfigByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Telegraf retrieved", zap.String("telegraf", fmt.Sprint(tc)))

        offers := []string{"application/toml", "application/json", "application/octet-stream"}
        defaultOffer := "application/toml"
        mimeType := httputil.NegotiateContentType(r, offers, defaultOffer)
        switch mimeType </span>{
        case "application/octet-stream":<span class="cov8" title="1">
                w.Header().Set("Content-Type", "application/octet-stream")
                w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=\"%s.toml\"", strings.Replace(strings.TrimSpace(tc.Name), " ", "_", -1)))
                w.WriteHeader(http.StatusOK)
                w.Write([]byte(tc.Config))</span>
        case "application/json":<span class="cov8" title="1">
                labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: tc.ID, ResourceType: influxdb.TelegrafsResourceType})
                if err != nil </span><span class="cov0" title="0">{
                        h.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov8" title="1">if err := encodeResponse(ctx, w, http.StatusOK, newTelegrafResponse(tc, labels)); err != nil </span><span class="cov0" title="0">{
                        logEncodingError(h.log, r, err)
                        return
                }</span>
        case "application/toml":<span class="cov8" title="1">
                w.Header().Set("Content-Type", "application/toml; charset=utf-8")
                w.WriteHeader(http.StatusOK)
                w.Write([]byte(tc.Config))</span>
        }
}

func decodeTelegrafConfigFilter(ctx context.Context, r *http.Request) (*influxdb.TelegrafConfigFilter, error) <span class="cov8" title="1">{
        f := &amp;influxdb.TelegrafConfigFilter{}
        q := r.URL.Query()

        if orgIDStr := q.Get("orgID"); orgIDStr != "" </span><span class="cov8" title="1">{
                orgID, err := platform.IDFromString(orgIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return f, &amp;errors.Error{
                                Code: errors.EInvalid,
                                Msg:  "orgID is invalid",
                                Err:  err,
                        }
                }</span>
                <span class="cov8" title="1">f.OrgID = orgID</span>
        } else<span class="cov8" title="1"> if orgNameStr := q.Get("org"); orgNameStr != "" </span><span class="cov8" title="1">{
                f.Organization = &amp;orgNameStr
        }</span>

        <span class="cov8" title="1">return f, nil</span>
}

// handlePostTelegraf is the HTTP handler for the POST /api/v2/telegrafs route.
func (h *TelegrafHandler) handlePostTelegraf(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        tc := new(influxdb.TelegrafConfig)
        if err := json.NewDecoder(r.Body).Decode(tc); err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">auth, err := pctx.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">if err := h.TelegrafService.CreateTelegrafConfig(ctx, tc, auth.GetUserID()); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">h.log.Debug("Telegraf created", zap.String("telegraf", fmt.Sprint(tc)))

        if err := encodeResponse(ctx, w, http.StatusCreated, newTelegrafResponse(tc, []*influxdb.Label{})); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func decodePutTelegrafRequest(ctx context.Context, r *http.Request) (*influxdb.TelegrafConfig, error) <span class="cov0" title="0">{
        tc := new(influxdb.TelegrafConfig)
        if err := json.NewDecoder(r.Body).Decode(tc); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>
        <span class="cov0" title="0">i := new(platform.ID)
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tc.ID = *i
        return tc, nil</span>
}

// handlePutTelegraf is the HTTP handler for the POST /api/v2/telegrafs route.
func (h *TelegrafHandler) handlePutTelegraf(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()

        tc, err := decodePutTelegrafRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Debug("Failed to decode request", zap.Error(err))
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">auth, err := pctx.GetAuthorizer(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">tc, err = h.TelegrafService.UpdateTelegrafConfig(ctx, tc.ID, tc, auth.GetUserID())
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: tc.ID, ResourceType: influxdb.TelegrafsResourceType})
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">h.log.Debug("Telegraf updated", zap.String("telegraf", fmt.Sprint(tc)))

        if err := encodeResponse(ctx, w, http.StatusOK, newTelegrafResponse(tc, labels)); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func (h *TelegrafHandler) handleDeleteTelegraf(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := r.Context()
        i, err := decodeGetTelegrafRequest(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov0" title="0">if err = h.TelegrafService.DeleteTelegrafConfig(ctx, i); err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov0" title="0">h.log.Debug("Telegraf deleted", zap.String("telegrafID", fmt.Sprint(i)))

        w.WriteHeader(http.StatusNoContent)</span>
}

// TelegrafService is an http client that speaks to the telegraf service via HTTP.
type TelegrafService struct {
        client *httpc.Client
        *UserResourceMappingService
}

// NewTelegrafService is a constructor for a telegraf service.
func NewTelegrafService(httpClient *httpc.Client) *TelegrafService <span class="cov0" title="0">{
        return &amp;TelegrafService{
                client: httpClient,
                UserResourceMappingService: &amp;UserResourceMappingService{
                        Client: httpClient,
                },
        }
}</span>

var _ influxdb.TelegrafConfigStore = (*TelegrafService)(nil)

// FindTelegrafConfigByID returns a single telegraf config by ID.
func (s *TelegrafService) FindTelegrafConfigByID(ctx context.Context, id platform.ID) (*influxdb.TelegrafConfig, error) <span class="cov0" title="0">{
        var cfg influxdb.TelegrafConfig
        err := s.client.
                Get(prefixTelegraf, id.String()).
                Header("Accept", "application/json").
                DecodeJSON(&amp;cfg).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

// FindTelegrafConfigs returns a list of telegraf configs that match filter and the total count of matching telegraf configs.
// Additional options provide pagination &amp; sorting.
func (s *TelegrafService) FindTelegrafConfigs(ctx context.Context, f influxdb.TelegrafConfigFilter, opt ...influxdb.FindOptions) ([]*influxdb.TelegrafConfig, int, error) <span class="cov0" title="0">{
        params := influxdb.FindOptionParams(opt...)
        if f.OrgID != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"orgID", f.OrgID.String()})
        }</span>
        <span class="cov0" title="0">if f.Organization != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"organization", *f.Organization})
        }</span>

        <span class="cov0" title="0">var resp struct {
                Configs []*influxdb.TelegrafConfig `json:"configurations"`
        }
        err := s.client.
                Get(prefixTelegraf).
                QueryParams(params...).
                DecodeJSON(&amp;resp).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return resp.Configs, len(resp.Configs), nil</span>
}

// CreateTelegrafConfig creates a new telegraf config and sets b.ID with the new identifier.
func (s *TelegrafService) CreateTelegrafConfig(ctx context.Context, tc *influxdb.TelegrafConfig, userID platform.ID) error <span class="cov0" title="0">{
        var teleResp influxdb.TelegrafConfig
        err := s.client.
                PostJSON(tc, prefixTelegraf).
                DecodeJSON(&amp;teleResp).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*tc = teleResp
        return nil</span>
}

// UpdateTelegrafConfig updates a single telegraf config.
// Returns the new telegraf config after update.
func (s *TelegrafService) UpdateTelegrafConfig(ctx context.Context, id platform.ID, tc *influxdb.TelegrafConfig, userID platform.ID) (*influxdb.TelegrafConfig, error) <span class="cov0" title="0">{
        var teleResp influxdb.TelegrafConfig
        err := s.client.
                PutJSON(tc, prefixTelegraf, id.String()).
                DecodeJSON(&amp;teleResp).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;teleResp, nil</span>
}

// DeleteTelegrafConfig removes a telegraf config by ID.
func (s *TelegrafService) DeleteTelegrafConfig(ctx context.Context, id platform.ID) error <span class="cov0" title="0">{
        return s.client.
                Delete(prefixTelegraf, id.String()).
                Do(ctx)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package http

import (
        "errors"
        "fmt"
        "net/http"
        "strings"
)

const (
        tokenScheme  = "Token "
        bearerScheme = "Bearer "
)

// errors
var (
        ErrAuthHeaderMissing = errors.New("authorization Header is missing")
        ErrAuthBadScheme     = errors.New("authorization Header Scheme is invalid")
)

// GetToken will parse the token from http Authorization Header.
func GetToken(r *http.Request) (string, error) <span class="cov8" title="1">{
        header := r.Header.Get("Authorization")
        if header == "" </span><span class="cov8" title="1">{
                return "", ErrAuthHeaderMissing
        }</span>

        <span class="cov8" title="1">if len(header) &gt;= len(tokenScheme) &amp;&amp;
                strings.EqualFold(header[:len(tokenScheme)], tokenScheme) </span><span class="cov8" title="1">{
                return header[len(tokenScheme):], nil
        }</span> else<span class="cov8" title="1"> if len(header) &gt; len(bearerScheme) &amp;&amp;
                strings.EqualFold(header[:len(bearerScheme)], bearerScheme) </span><span class="cov8" title="1">{
                return header[len(bearerScheme):], nil
        }</span>

        <span class="cov8" title="1">return "", ErrAuthBadScheme</span>
}

// SetToken adds the token to the request.
func SetToken(token string, req *http.Request) <span class="cov8" title="1">{
        req.Header.Set("Authorization", fmt.Sprintf("%s%s", tokenScheme, token))
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package http

import (
        "net/http"

        useragent "github.com/mileusna/useragent"
)

func userAgent(r *http.Request) string <span class="cov8" title="1">{
        header := r.Header.Get("User-Agent")
        if header == "" </span><span class="cov0" title="0">{
                return "unknown"
        }</span>

        <span class="cov8" title="1">ua := useragent.Parse(header)
        return ua.Name</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package http

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "path"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/pkg/httpc"
        "go.uber.org/zap"
)

type resourceUserResponse struct {
        Role influxdb.UserType `json:"role"`
        *influxdb.UserResponse
}

func newUserResponse(u *influxdb.User) *influxdb.UserResponse <span class="cov8" title="1">{
        return &amp;influxdb.UserResponse{
                Links: map[string]string{
                        "self": fmt.Sprintf("/api/v2/users/%s", u.ID),
                        "logs": fmt.Sprintf("/api/v2/users/%s/logs", u.ID),
                },
                User: *u,
        }
}</span>

func newResourceUserResponse(u *influxdb.User, userType influxdb.UserType) *resourceUserResponse <span class="cov8" title="1">{
        return &amp;resourceUserResponse{
                Role:         userType,
                UserResponse: newUserResponse(u),
        }
}</span>

type resourceUsersResponse struct {
        Links map[string]string       `json:"links"`
        Users []*resourceUserResponse `json:"users"`
}

func newResourceUsersResponse(opts influxdb.FindOptions, f influxdb.UserResourceMappingFilter, users []*influxdb.User) *resourceUsersResponse <span class="cov8" title="1">{
        rs := resourceUsersResponse{
                Links: map[string]string{
                        "self": fmt.Sprintf("/api/v2/%s/%s/%ss", f.ResourceType, f.ResourceID, f.UserType),
                },
                Users: make([]*resourceUserResponse, 0, len(users)),
        }

        for _, user := range users </span><span class="cov8" title="1">{
                rs.Users = append(rs.Users, newResourceUserResponse(user, f.UserType))
        }</span>
        <span class="cov8" title="1">return &amp;rs</span>
}

// MemberBackend is all services and associated parameters required to construct
// member handler.
type MemberBackend struct {
        errors.HTTPErrorHandler
        log *zap.Logger

        ResourceType influxdb.ResourceType
        UserType     influxdb.UserType

        UserResourceMappingService influxdb.UserResourceMappingService
        UserService                influxdb.UserService
}

// newPostMemberHandler returns a handler func for a POST to /members or /owners endpoints
func newPostMemberHandler(b MemberBackend) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ctx := r.Context()
                req, err := decodePostMemberRequest(ctx, r)
                if err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov8" title="1">user, err := b.UserService.FindUserByID(ctx, req.MemberID)
                if err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov8" title="1">mapping := &amp;influxdb.UserResourceMapping{
                        ResourceID:   req.ResourceID,
                        ResourceType: b.ResourceType,
                        UserID:       req.MemberID,
                        UserType:     b.UserType,
                }

                if err := b.UserResourceMappingService.CreateUserResourceMapping(ctx, mapping); err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>
                <span class="cov8" title="1">b.log.Debug("Member/owner created", zap.String("mapping", fmt.Sprint(mapping)))

                if err := encodeResponse(ctx, w, http.StatusCreated, newResourceUserResponse(user, b.UserType)); err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>
        }
}

type postMemberRequest struct {
        MemberID   platform.ID
        ResourceID platform.ID
}

func decodePostMemberRequest(ctx context.Context, r *http.Request) (*postMemberRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">var rid platform.ID
        if err := rid.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">u := &amp;influxdb.User{}
        if err := json.NewDecoder(r.Body).Decode(u); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !u.ID.Valid() </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "user id missing or invalid",
                }
        }</span>

        <span class="cov8" title="1">return &amp;postMemberRequest{
                MemberID:   u.ID,
                ResourceID: rid,
        }, nil</span>
}

// newGetMembersHandler returns a handler func for a GET to /members or /owners endpoints
func newGetMembersHandler(b MemberBackend) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                ctx := r.Context()
                req, err := decodeGetMembersRequest(ctx, r)
                if err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov8" title="1">filter := influxdb.UserResourceMappingFilter{
                        ResourceID:   req.ResourceID,
                        ResourceType: b.ResourceType,
                        UserType:     b.UserType,
                }

                opts := influxdb.FindOptions{}
                mappings, _, err := b.UserResourceMappingService.FindUserResourceMappings(ctx, filter)
                if err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov8" title="1">users := make([]*influxdb.User, 0, len(mappings))
                for _, m := range mappings </span><span class="cov8" title="1">{
                        if m.MappingType == influxdb.OrgMappingType </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">user, err := b.UserService.FindUserByID(ctx, m.UserID)
                        if err != nil </span><span class="cov0" title="0">{
                                b.HandleHTTPError(ctx, err, w)
                                return
                        }</span>

                        <span class="cov8" title="1">users = append(users, user)</span>
                }
                <span class="cov8" title="1">b.log.Debug("Members/owners retrieved", zap.String("users", fmt.Sprint(users)))

                if err := encodeResponse(ctx, w, http.StatusOK, newResourceUsersResponse(opts, filter, users)); err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>
        }
}

type getMembersRequest struct {
        MemberID   platform.ID
        ResourceID platform.ID
}

func decodeGetMembersRequest(ctx context.Context, r *http.Request) (*getMembersRequest, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">var i platform.ID
        if err := i.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req := &amp;getMembersRequest{
                ResourceID: i,
        }

        return req, nil</span>
}

// newDeleteMemberHandler returns a handler func for a DELETE to /members or /owners endpoints
func newDeleteMemberHandler(b MemberBackend) http.HandlerFunc <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ctx := r.Context()
                req, err := decodeDeleteMemberRequest(ctx, r)
                if err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>

                <span class="cov0" title="0">if err := b.UserResourceMappingService.DeleteUserResourceMapping(ctx, req.ResourceID, req.MemberID); err != nil </span><span class="cov0" title="0">{
                        b.HandleHTTPError(ctx, err, w)
                        return
                }</span>
                <span class="cov0" title="0">b.log.Debug("Member deleted", zap.String("resourceID", req.ResourceID.String()), zap.String("memberID", req.MemberID.String()))

                w.WriteHeader(http.StatusNoContent)</span>
        }
}

type deleteMemberRequest struct {
        MemberID   platform.ID
        ResourceID platform.ID
}

func decodeDeleteMemberRequest(ctx context.Context, r *http.Request) (*deleteMemberRequest, error) <span class="cov0" title="0">{
        params := httprouter.ParamsFromContext(ctx)
        id := params.ByName("id")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing resource id",
                }
        }</span>

        <span class="cov0" title="0">var rid platform.ID
        if err := rid.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">id = params.ByName("userID")
        if id == "" </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing member id",
                }
        }</span>

        <span class="cov0" title="0">var mid platform.ID
        if err := mid.DecodeFromString(id); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;deleteMemberRequest{
                MemberID:   mid,
                ResourceID: rid,
        }, nil</span>
}

// UserResourceMappingService is the struct of urm service
type UserResourceMappingService struct {
        Client *httpc.Client
}

// FindUserResourceMappings returns the user resource mappings
func (s *UserResourceMappingService) FindUserResourceMappings(ctx context.Context, f influxdb.UserResourceMappingFilter, opt ...influxdb.FindOptions) ([]*influxdb.UserResourceMapping, int, error) <span class="cov0" title="0">{
        var results resourceUsersResponse
        err := s.Client.
                Get(resourceIDPath(f.ResourceType, f.ResourceID, string(f.UserType)+"s")).
                DecodeJSON(&amp;results).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">urs := make([]*influxdb.UserResourceMapping, len(results.Users))
        for k, item := range results.Users </span><span class="cov0" title="0">{
                urs[k] = &amp;influxdb.UserResourceMapping{
                        ResourceID:   f.ResourceID,
                        ResourceType: f.ResourceType,
                        UserID:       item.User.ID,
                        UserType:     item.Role,
                }
        }</span>
        <span class="cov0" title="0">return urs, len(urs), nil</span>
}

// CreateUserResourceMapping will create a user resource mapping
func (s *UserResourceMappingService) CreateUserResourceMapping(ctx context.Context, m *influxdb.UserResourceMapping) error <span class="cov0" title="0">{
        if err := m.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">urlPath := resourceIDPath(m.ResourceType, m.ResourceID, string(m.UserType)+"s")
        return s.Client.
                PostJSON(influxdb.User{ID: m.UserID}, urlPath).
                DecodeJSON(m).
                Do(ctx)</span>
}

// DeleteUserResourceMapping will delete user resource mapping based in criteria.
func (s *UserResourceMappingService) DeleteUserResourceMapping(ctx context.Context, resourceID platform.ID, userID platform.ID) error <span class="cov0" title="0">{
        urlPath := resourceIDUserPath(influxdb.OrgsResourceType, resourceID, influxdb.Member, userID)
        return s.Client.
                Delete(urlPath).
                Do(ctx)
}</span>

// SpecificURMSvc returns a urm service with specific resource and user types.
// this will help us stay compatible with the existing service contract but also allow for urm deletes to go through the correct
// api
func (s *UserResourceMappingService) SpecificURMSvc(rt influxdb.ResourceType, ut influxdb.UserType) *SpecificURMSvc <span class="cov0" title="0">{
        return &amp;SpecificURMSvc{
                Client: s.Client,
                rt:     rt,
                ut:     ut,
        }
}</span>

// SpecificURMSvc is a URM client that speaks to a specific resource with a specified user type
type SpecificURMSvc struct {
        Client *httpc.Client
        rt     influxdb.ResourceType
        ut     influxdb.UserType
}

// FindUserResourceMappings returns the user resource mappings
func (s *SpecificURMSvc) FindUserResourceMappings(ctx context.Context, f influxdb.UserResourceMappingFilter, opt ...influxdb.FindOptions) ([]*influxdb.UserResourceMapping, int, error) <span class="cov0" title="0">{
        var results resourceUsersResponse
        err := s.Client.
                Get(resourceIDPath(s.rt, f.ResourceID, string(s.ut)+"s")).
                DecodeJSON(&amp;results).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">urs := make([]*influxdb.UserResourceMapping, len(results.Users))
        for k, item := range results.Users </span><span class="cov0" title="0">{
                urs[k] = &amp;influxdb.UserResourceMapping{
                        ResourceID:   f.ResourceID,
                        ResourceType: f.ResourceType,
                        UserID:       item.User.ID,
                        UserType:     item.Role,
                }
        }</span>
        <span class="cov0" title="0">return urs, len(urs), nil</span>
}

// CreateUserResourceMapping will create a user resource mapping
func (s *SpecificURMSvc) CreateUserResourceMapping(ctx context.Context, m *influxdb.UserResourceMapping) error <span class="cov0" title="0">{
        if err := m.Validate(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">urlPath := resourceIDPath(s.rt, m.ResourceID, string(s.ut)+"s")
        return s.Client.
                PostJSON(influxdb.User{ID: m.UserID}, urlPath).
                DecodeJSON(m).
                Do(ctx)</span>
}

// DeleteUserResourceMapping will delete user resource mapping based in criteria.
func (s *SpecificURMSvc) DeleteUserResourceMapping(ctx context.Context, resourceID platform.ID, userID platform.ID) error <span class="cov0" title="0">{
        urlPath := resourceIDUserPath(s.rt, resourceID, s.ut, userID)
        return s.Client.
                Delete(urlPath).
                Do(ctx)
}</span>

func resourceIDPath(resourceType influxdb.ResourceType, resourceID platform.ID, p string) string <span class="cov0" title="0">{
        return path.Join("/api/v2/", string(resourceType), resourceID.String(), p)
}</span>

func resourceIDUserPath(resourceType influxdb.ResourceType, resourceID platform.ID, userType influxdb.UserType, userID platform.ID) string <span class="cov0" title="0">{
        return path.Join("/api/v2/", string(resourceType), resourceID.String(), string(userType)+"s", userID.String())
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package http

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/pkg/httpc"
        "go.uber.org/zap"
)

const (
        prefixVariables = "/api/v2/variables"
)

// VariableBackend is all services and associated parameters required to construct
// the VariableHandler.
type VariableBackend struct {
        errors.HTTPErrorHandler
        log             *zap.Logger
        VariableService influxdb.VariableService
        LabelService    influxdb.LabelService
}

// NewVariableBackend creates a backend used by the variable handler.
func NewVariableBackend(log *zap.Logger, b *APIBackend) *VariableBackend <span class="cov8" title="1">{
        return &amp;VariableBackend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,
                VariableService:  b.VariableService,
                LabelService:     b.LabelService,
        }
}</span>

// VariableHandler is the handler for the variable service
type VariableHandler struct {
        *httprouter.Router

        errors.HTTPErrorHandler
        log *zap.Logger

        VariableService influxdb.VariableService
        LabelService    influxdb.LabelService
}

// NewVariableHandler creates a new VariableHandler
func NewVariableHandler(log *zap.Logger, b *VariableBackend) *VariableHandler <span class="cov8" title="1">{
        h := &amp;VariableHandler{
                Router:           NewRouter(b.HTTPErrorHandler),
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              log,

                VariableService: b.VariableService,
                LabelService:    b.LabelService,
        }

        entityPath := fmt.Sprintf("%s/:id", prefixVariables)
        entityLabelsPath := fmt.Sprintf("%s/labels", entityPath)
        entityLabelsIDPath := fmt.Sprintf("%s/:lid", entityLabelsPath)

        h.HandlerFunc("GET", prefixVariables, h.handleGetVariables)
        h.HandlerFunc("POST", prefixVariables, h.handlePostVariable)
        h.HandlerFunc("GET", entityPath, h.handleGetVariable)
        h.HandlerFunc("PATCH", entityPath, h.handlePatchVariable)
        h.HandlerFunc("PUT", entityPath, h.handlePutVariable)
        h.HandlerFunc("DELETE", entityPath, h.handleDeleteVariable)

        labelBackend := &amp;LabelBackend{
                HTTPErrorHandler: b.HTTPErrorHandler,
                log:              b.log.With(zap.String("handler", "label")),
                LabelService:     b.LabelService,
                ResourceType:     influxdb.VariablesResourceType,
        }
        h.HandlerFunc("GET", entityLabelsPath, newGetLabelsHandler(labelBackend))
        h.HandlerFunc("POST", entityLabelsPath, newPostLabelHandler(labelBackend))
        h.HandlerFunc("DELETE", entityLabelsIDPath, newDeleteLabelHandler(labelBackend))

        return h
}</span>

type getVariablesResponse struct {
        Variables []variableResponse    `json:"variables"`
        Links     *influxdb.PagingLinks `json:"links"`
}

func (r getVariablesResponse) Toinfluxdb() []*influxdb.Variable <span class="cov8" title="1">{
        variables := make([]*influxdb.Variable, len(r.Variables))
        for i := range r.Variables </span><span class="cov8" title="1">{
                variables[i] = r.Variables[i].Variable
        }</span>
        <span class="cov8" title="1">return variables</span>
}

func newGetVariablesResponse(ctx context.Context, variables []*influxdb.Variable, f influxdb.VariableFilter, opts influxdb.FindOptions, labelService influxdb.LabelService) getVariablesResponse <span class="cov8" title="1">{
        num := len(variables)
        resp := getVariablesResponse{
                Variables: make([]variableResponse, 0, num),
                Links:     influxdb.NewPagingLinks(prefixVariables, opts, f, num),
        }

        for _, variable := range variables </span><span class="cov8" title="1">{
                labels, _ := labelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: variable.ID, ResourceType: influxdb.VariablesResourceType})
                resp.Variables = append(resp.Variables, newVariableResponse(variable, labels))
        }</span>

        <span class="cov8" title="1">return resp</span>
}

type getVariablesRequest struct {
        filter influxdb.VariableFilter
        opts   influxdb.FindOptions
}

func decodeGetVariablesRequest(ctx context.Context, r *http.Request) (*getVariablesRequest, error) <span class="cov8" title="1">{
        opts, err := influxdb.DecodeFindOptions(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req := &amp;getVariablesRequest{
                opts: *opts,
        }
        qp := r.URL.Query()
        if orgID := qp.Get("orgID"); orgID != "" </span><span class="cov8" title="1">{
                id, err := platform.IDFromString(orgID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">req.filter.OrganizationID = id</span>
        }

        <span class="cov8" title="1">if org := qp.Get("org"); org != "" </span><span class="cov0" title="0">{
                req.filter.Organization = &amp;org
        }</span>

        <span class="cov8" title="1">return req, nil</span>
}

func (h *VariableHandler) handleGetVariables(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodeGetVariablesRequest(ctx, r)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">variables, err := h.VariableService.FindVariables(ctx, req.filter, req.opts)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, &amp;errors.Error{
                        Code: errors.EInternal,
                        Msg:  "could not read variables",
                        Err:  err,
                }, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Variables retrieved", zap.String("vars", fmt.Sprint(variables)))
        err = encodeResponse(ctx, w, http.StatusOK, newGetVariablesResponse(ctx, variables, req.filter, req.opts, h.LabelService))
        if err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

func requestVariableID(ctx context.Context) (platform.ID, error) <span class="cov8" title="1">{
        params := httprouter.ParamsFromContext(ctx)
        urlID := params.ByName("id")
        if urlID == "" </span><span class="cov0" title="0">{
                return platform.InvalidID(), &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  "url missing id",
                }
        }</span>

        <span class="cov8" title="1">id, err := platform.IDFromString(urlID)
        if err != nil </span><span class="cov8" title="1">{
                return platform.InvalidID(), err
        }</span>

        <span class="cov8" title="1">return *id, nil</span>
}

func (h *VariableHandler) handleGetVariable(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        id, err := requestVariableID(ctx)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">variable, err := h.VariableService.FindVariableByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: variable.ID, ResourceType: influxdb.VariablesResourceType})
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Variable retrieved", zap.String("var", fmt.Sprint(variable)))
        err = encodeResponse(ctx, w, http.StatusOK, newVariableResponse(variable, labels))
        if err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type variableLinks struct {
        Self   string `json:"self"`
        Labels string `json:"labels"`
        Org    string `json:"org"`
}

type variableResponse struct {
        *influxdb.Variable
        Labels []influxdb.Label `json:"labels"`
        Links  variableLinks    `json:"links"`
}

func newVariableResponse(m *influxdb.Variable, labels []*influxdb.Label) variableResponse <span class="cov8" title="1">{
        res := variableResponse{
                Variable: m,
                Labels:   []influxdb.Label{},
                Links: variableLinks{
                        Self:   fmt.Sprintf("/api/v2/variables/%s", m.ID),
                        Labels: fmt.Sprintf("/api/v2/variables/%s/labels", m.ID),
                        Org:    fmt.Sprintf("/api/v2/orgs/%s", m.OrganizationID),
                },
        }

        for _, l := range labels </span><span class="cov8" title="1">{
                res.Labels = append(res.Labels, *l)
        }</span>
        <span class="cov8" title="1">return res</span>
}

func (h *VariableHandler) handlePostVariable(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodePostVariableRequest(r)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">err = h.VariableService.CreateVariable(ctx, req.variable)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Variable created", zap.String("var", fmt.Sprint(req.variable)))
        if err := encodeResponse(ctx, w, http.StatusCreated, newVariableResponse(req.variable, []*influxdb.Label{})); err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type postVariableRequest struct {
        variable *influxdb.Variable
}

func (r *postVariableRequest) Valid() error <span class="cov8" title="1">{
        return r.variable.Valid()
}</span>

func decodePostVariableRequest(r *http.Request) (*postVariableRequest, error) <span class="cov8" title="1">{
        m := &amp;influxdb.Variable{}

        err := json.NewDecoder(r.Body).Decode(m)
        if err != nil </span><span class="cov8" title="1">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  err.Error(),
                }
        }</span>

        <span class="cov8" title="1">req := &amp;postVariableRequest{
                variable: m,
        }

        if err := req.Valid(); err != nil </span><span class="cov8" title="1">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  err.Error(),
                }
        }</span>

        <span class="cov8" title="1">return req, nil</span>
}

func (h *VariableHandler) handlePatchVariable(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodePatchVariableRequest(ctx, r)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">variable, err := h.VariableService.UpdateVariable(ctx, req.id, req.variableUpdate)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: variable.ID, ResourceType: influxdb.VariablesResourceType})
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Variable updated", zap.String("var", fmt.Sprint(variable)))
        err = encodeResponse(ctx, w, http.StatusOK, newVariableResponse(variable, labels))
        if err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type patchVariableRequest struct {
        id             platform.ID
        variableUpdate *influxdb.VariableUpdate
}

func (r *patchVariableRequest) Valid() error <span class="cov8" title="1">{
        return r.variableUpdate.Valid()
}</span>

func decodePatchVariableRequest(ctx context.Context, r *http.Request) (*patchVariableRequest, error) <span class="cov8" title="1">{
        u := &amp;influxdb.VariableUpdate{}

        err := json.NewDecoder(r.Body).Decode(u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  err.Error(),
                }
        }</span>

        <span class="cov8" title="1">id, err := requestVariableID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req := &amp;patchVariableRequest{
                id:             id,
                variableUpdate: u,
        }

        if err := req.Valid(); err != nil </span><span class="cov8" title="1">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Msg:  err.Error(),
                }
        }</span>

        <span class="cov8" title="1">return req, nil</span>
}

func (h *VariableHandler) handlePutVariable(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        req, err := decodePutVariableRequest(ctx, r)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">v := req.variable
        v.ID = req.id

        err = h.VariableService.ReplaceVariable(ctx, v)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">labels, err := h.LabelService.FindResourceLabels(ctx, influxdb.LabelMappingFilter{ResourceID: v.ID, ResourceType: influxdb.VariablesResourceType})
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Variable replaced", zap.String("var", fmt.Sprint(req.variable)))
        err = encodeResponse(ctx, w, http.StatusOK, newVariableResponse(req.variable, labels))
        if err != nil </span><span class="cov0" title="0">{
                logEncodingError(h.log, r, err)
                return
        }</span>
}

type putVariableRequest struct {
        id       platform.ID
        variable *influxdb.Variable
}

func (r *putVariableRequest) Valid() error <span class="cov8" title="1">{
        return r.variable.Valid()
}</span>

func decodePutVariableRequest(ctx context.Context, r *http.Request) (*putVariableRequest, error) <span class="cov8" title="1">{
        m := &amp;influxdb.Variable{}

        err := json.NewDecoder(r.Body).Decode(m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>

        <span class="cov8" title="1">id, err := requestVariableID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req := &amp;putVariableRequest{
                variable: m,
                id:       id,
        }

        if err := req.Valid(); err != nil </span><span class="cov8" title="1">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>

        <span class="cov8" title="1">return req, nil</span>
}

func (h *VariableHandler) handleDeleteVariable(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        ctx := r.Context()
        id, err := requestVariableID(ctx)
        if err != nil </span><span class="cov0" title="0">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">err = h.VariableService.DeleteVariable(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">h.log.Debug("Variable deleted", zap.String("variableID", fmt.Sprint(id)))
        w.WriteHeader(http.StatusNoContent)</span>
}

// VariableService is a variable service over HTTP to the influxdb server
type VariableService struct {
        Client *httpc.Client
}

// FindVariableByID finds a single variable from the store by its ID
func (s *VariableService) FindVariableByID(ctx context.Context, id platform.ID) (*influxdb.Variable, error) <span class="cov8" title="1">{
        var mr variableResponse
        err := s.Client.
                Get(prefixVariables, id.String()).
                DecodeJSON(&amp;mr).
                Do(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return mr.Variable, nil</span>
}

// FindVariables returns a list of variables that match filter.
// Additional options provide pagination &amp; sorting.
func (s *VariableService) FindVariables(ctx context.Context, filter influxdb.VariableFilter, opts ...influxdb.FindOptions) ([]*influxdb.Variable, error) <span class="cov8" title="1">{
        params := influxdb.FindOptionParams(opts...)
        if filter.OrganizationID != nil </span><span class="cov8" title="1">{
                params = append(params, [2]string{"orgID", filter.OrganizationID.String()})
        }</span>
        <span class="cov8" title="1">if filter.Organization != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"org", *filter.Organization})
        }</span>
        <span class="cov8" title="1">if filter.ID != nil </span><span class="cov0" title="0">{
                params = append(params, [2]string{"id", filter.ID.String()})
        }</span>

        <span class="cov8" title="1">var ms getVariablesResponse
        err := s.Client.
                Get(prefixVariables).
                QueryParams(params...).
                DecodeJSON(&amp;ms).
                Do(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return ms.Toinfluxdb(), nil</span>
}

// CreateVariable creates a new variable and assigns it an influxdb.ID
func (s *VariableService) CreateVariable(ctx context.Context, m *influxdb.Variable) error <span class="cov8" title="1">{
        m.Name = strings.TrimSpace(m.Name)
        if err := m.Valid(); err != nil </span><span class="cov0" title="0">{
                return &amp;errors.Error{
                        Code: errors.EInvalid,
                        Err:  err,
                }
        }</span>

        <span class="cov8" title="1">return s.Client.
                PostJSON(m, prefixVariables).
                DecodeJSON(m).
                Do(ctx)</span>
}

// UpdateVariable updates a single variable with a changeset
func (s *VariableService) UpdateVariable(ctx context.Context, id platform.ID, update *influxdb.VariableUpdate) (*influxdb.Variable, error) <span class="cov8" title="1">{
        var m influxdb.Variable
        err := s.Client.
                PatchJSON(update, prefixVariables, id.String()).
                DecodeJSON(&amp;m).
                Do(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;m, nil</span>
}

// ReplaceVariable replaces a single variable
func (s *VariableService) ReplaceVariable(ctx context.Context, variable *influxdb.Variable) error <span class="cov8" title="1">{
        return s.Client.
                PutJSON(variable, prefixVariables, variable.ID.String()).
                DecodeJSON(variable).
                Do(ctx)
}</span>

// DeleteVariable removes a variable from the store
func (s *VariableService) DeleteVariable(ctx context.Context, id platform.ID) error <span class="cov8" title="1">{
        return s.Client.
                Delete(prefixVariables, id.String()).
                Do(ctx)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package http

import (
        "compress/gzip"
        "context"
        "fmt"
        "io"
        "net/http"

        "github.com/influxdata/httprouter"
        "github.com/influxdata/influxdb/v2"
        pcontext "github.com/influxdata/influxdb/v2/context"
        "github.com/influxdata/influxdb/v2/http/metric"
        "github.com/influxdata/influxdb/v2/http/points"
        "github.com/influxdata/influxdb/v2/kit/platform"
        "github.com/influxdata/influxdb/v2/kit/platform/errors"
        "github.com/influxdata/influxdb/v2/kit/tracing"
        kithttp "github.com/influxdata/influxdb/v2/kit/transport/http"
        "github.com/influxdata/influxdb/v2/models"
        "github.com/influxdata/influxdb/v2/storage"
        "github.com/influxdata/influxdb/v2/tsdb"
        "go.uber.org/zap"
)

// WriteBackend is all services and associated parameters required to construct
// the WriteHandler.
type WriteBackend struct {
        errors.HTTPErrorHandler
        log                *zap.Logger
        WriteEventRecorder metric.EventRecorder

        PointsWriter        storage.PointsWriter
        BucketService       influxdb.BucketService
        OrganizationService influxdb.OrganizationService
}

// NewWriteBackend returns a new instance of WriteBackend.
func NewWriteBackend(log *zap.Logger, b *APIBackend) *WriteBackend <span class="cov8" title="1">{
        return &amp;WriteBackend{
                HTTPErrorHandler:   b.HTTPErrorHandler,
                log:                log,
                WriteEventRecorder: b.WriteEventRecorder,

                PointsWriter:        b.PointsWriter,
                BucketService:       b.BucketService,
                OrganizationService: b.OrganizationService,
        }
}</span>

// WriteHandler receives line protocol and sends to a publish function.
type WriteHandler struct {
        errors.HTTPErrorHandler
        BucketService       influxdb.BucketService
        OrganizationService influxdb.OrganizationService
        PointsWriter        storage.PointsWriter
        EventRecorder       metric.EventRecorder

        router            *httprouter.Router
        log               *zap.Logger
        maxBatchSizeBytes int64
        // parserOptions     []models.ParserOption
}

// WriteHandlerOption is a functional option for a *WriteHandler
type WriteHandlerOption func(*WriteHandler)

// WithMaxBatchSizeBytes configures the maximum size for a
// (decompressed) points batch allowed by the write handler
func WithMaxBatchSizeBytes(n int64) WriteHandlerOption <span class="cov8" title="1">{
        return func(w *WriteHandler) </span><span class="cov8" title="1">{
                w.maxBatchSizeBytes = n
        }</span>
}

//func WithParserOptions(opts ...models.ParserOption) WriteHandlerOption {
//        return func(w *WriteHandler) {
//                w.parserOptions = opts
//        }
//}

// Prefix provides the route prefix.
func (*WriteHandler) Prefix() string <span class="cov0" title="0">{
        return prefixWrite
}</span>

const (
        prefixWrite          = "/api/v2/write"
        msgInvalidGzipHeader = "gzipped HTTP body contains an invalid header"
        msgInvalidPrecision  = "invalid precision; valid precision units are ns, us, ms, and s"

        opWriteHandler = "http/writeHandler"
)

// NewWriteHandler creates a new handler at /api/v2/write to receive line protocol.
func NewWriteHandler(log *zap.Logger, b *WriteBackend, opts ...WriteHandlerOption) *WriteHandler <span class="cov8" title="1">{
        h := &amp;WriteHandler{
                HTTPErrorHandler:    b.HTTPErrorHandler,
                PointsWriter:        b.PointsWriter,
                BucketService:       b.BucketService,
                OrganizationService: b.OrganizationService,
                EventRecorder:       b.WriteEventRecorder,

                router: NewRouter(b.HTTPErrorHandler),
                log:    log,
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(h)
        }</span>

        <span class="cov8" title="1">h.router.HandlerFunc(http.MethodPost, prefixWrite, h.handleWrite)
        return h</span>
}

func (h *WriteHandler) findBucket(ctx context.Context, orgID platform.ID, bucket string) (*influxdb.Bucket, error) <span class="cov8" title="1">{
        if id, err := platform.IDFromString(bucket); err == nil </span><span class="cov8" title="1">{
                b, err := h.BucketService.FindBucket(ctx, influxdb.BucketFilter{
                        OrganizationID: &amp;orgID,
                        ID:             id,
                })
                if err != nil &amp;&amp; errors.ErrorCode(err) != errors.ENotFound </span><span class="cov8" title="1">{
                        return nil, err
                }</span> else<span class="cov8" title="1"> if err == nil </span><span class="cov8" title="1">{
                        return b, err
                }</span>
        }

        <span class="cov8" title="1">return h.BucketService.FindBucket(ctx, influxdb.BucketFilter{
                OrganizationID: &amp;orgID,
                Name:           &amp;bucket,
        })</span>
}

func (h *WriteHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        h.router.ServeHTTP(w, r)
}</span>

func (h *WriteHandler) handleWrite(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        span, r := tracing.ExtractFromHTTPRequest(r, "WriteHandler")
        defer span.Finish()

        ctx := r.Context()
        auth, err := pcontext.GetAuthorizer(ctx)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">req, err := decodeWriteRequest(ctx, r, h.maxBatchSizeBytes)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>

        <span class="cov8" title="1">org, err := queryOrganization(ctx, r, h.OrganizationService)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, w)
                return
        }</span>
        <span class="cov8" title="1">span.LogKV("org_id", org.ID)

        sw := kithttp.NewStatusResponseWriter(w)
        recorder := NewWriteUsageRecorder(sw, h.EventRecorder)
        var requestBytes int
        defer func() </span><span class="cov8" title="1">{
                // Close around the requestBytes variable to placate the linter.
                recorder.Record(ctx, requestBytes, org.ID, r.URL.Path)
        }</span>()

        <span class="cov8" title="1">bucket, err := h.findBucket(ctx, org.ID, req.Bucket)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, sw)
                return
        }</span>
        <span class="cov8" title="1">span.LogKV("bucket_id", bucket.ID)

        if err := checkBucketWritePermissions(auth, org.ID, bucket.ID); err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, sw)
                return
        }</span>

        // TODO: Backport?
        //opts := append([]models.ParserOption{}, h.parserOptions...)
        //opts = append(opts, models.WithParserPrecision(req.Precision))
        <span class="cov8" title="1">parsed, err := points.NewParser(req.Precision).Parse(ctx, org.ID, bucket.ID, req.Body)
        if err != nil </span><span class="cov8" title="1">{
                h.HandleHTTPError(ctx, err, sw)
                return
        }</span>
        <span class="cov8" title="1">requestBytes = parsed.RawSize

        if err := h.PointsWriter.WritePoints(ctx, org.ID, bucket.ID, parsed.Points); err != nil </span><span class="cov8" title="1">{
                if partialErr, ok := err.(tsdb.PartialWriteError); ok </span><span class="cov8" title="1">{
                        h.HandleHTTPError(ctx, &amp;errors.Error{
                                Code: errors.EUnprocessableEntity,
                                Op:   opWriteHandler,
                                Msg:  "failure writing points to database",
                                Err:  partialErr,
                        }, sw)
                        return
                }</span>

                <span class="cov8" title="1">h.HandleHTTPError(ctx, &amp;errors.Error{
                        Code: errors.EInternal,
                        Op:   opWriteHandler,
                        Msg:  "unexpected error writing points to database",
                        Err:  err,
                }, sw)
                return</span>
        }

        <span class="cov8" title="1">sw.WriteHeader(http.StatusNoContent)</span>
}

// checkBucketWritePermissions checks an Authorizer for write permissions to a
// specific Bucket.
func checkBucketWritePermissions(auth influxdb.Authorizer, orgID, bucketID platform.ID) error <span class="cov8" title="1">{
        p, err := influxdb.NewPermissionAtID(bucketID, influxdb.WriteAction, influxdb.BucketsResourceType, orgID)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;errors.Error{
                        Code: errors.EInternal,
                        Op:   opWriteHandler,
                        Msg:  fmt.Sprintf("unable to create permission for bucket: %v", err),
                        Err:  err,
                }
        }</span>
        <span class="cov8" title="1">if pset, err := auth.PermissionSet(); err != nil || !pset.Allowed(*p) </span><span class="cov8" title="1">{
                return &amp;errors.Error{
                        Code: errors.EForbidden,
                        Op:   opWriteHandler,
                        Msg:  "insufficient permissions for write",
                        Err:  err,
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// writeRequest is a request object holding information about a batch of points
// to be written to a Bucket.
type writeRequest struct {
        Org       string
        Bucket    string
        Precision string
        Body      io.ReadCloser
}

// decodeWriteRequest extracts information from an http.Request object to
// produce a writeRequest.
func decodeWriteRequest(ctx context.Context, r *http.Request, maxBatchSizeBytes int64) (*writeRequest, error) <span class="cov8" title="1">{
        qp := r.URL.Query()
        precision := qp.Get("precision")
        if precision == "" </span><span class="cov8" title="1">{
                precision = "ns"
        }</span>

        <span class="cov8" title="1">if !models.ValidPrecision(precision) </span><span class="cov0" title="0">{
                return nil, &amp;errors.Error{
                        Code: errors.EInvalid,
                        Op:   "http/newWriteRequest",
                        Msg:  msgInvalidPrecision,
                }
        }</span>

        <span class="cov8" title="1">bucket := qp.Get("bucket")
        if bucket == "" </span><span class="cov8" title="1">{
                return nil, &amp;errors.Error{
                        Code: errors.ENotFound,
                        Op:   "http/newWriteRequest",
                        Msg:  "bucket not found",
                }
        }</span>

        <span class="cov8" title="1">encoding := r.Header.Get("Content-Encoding")
        body, err := points.BatchReadCloser(r.Body, encoding, maxBatchSizeBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;writeRequest{
                Bucket:    qp.Get("bucket"),
                Org:       qp.Get("org"),
                Precision: precision,
                Body:      body,
        }, nil</span>
}

// WriteService sends data over HTTP to influxdb via line protocol.
type WriteService struct {
        Addr               string
        Token              string
        Precision          string
        InsecureSkipVerify bool
}

var _ influxdb.WriteService = (*WriteService)(nil)

func compressWithGzip(data io.Reader) (io.Reader, error) <span class="cov8" title="1">{
        pr, pw := io.Pipe()
        gw := gzip.NewWriter(pw)
        var err error

        go func() </span><span class="cov8" title="1">{
                _, err = io.Copy(gw, data)
                gw.Close()
                pw.Close()
        }</span>()

        <span class="cov8" title="1">return pr, err</span>
}

// WriteTo writes to the bucket matching the filter.
func (s *WriteService) WriteTo(ctx context.Context, filter influxdb.BucketFilter, r io.Reader) error <span class="cov8" title="1">{
        precision := s.Precision
        if precision == "" </span><span class="cov8" title="1">{
                precision = "ns"
        }</span>

        <span class="cov8" title="1">if !models.ValidPrecision(precision) </span><span class="cov0" title="0">{
                return &amp;errors.Error{
                        Code: errors.EInvalid,
                        Op:   "http/Write",
                        Msg:  msgInvalidPrecision,
                }
        }</span>

        <span class="cov8" title="1">u, err := NewURL(s.Addr, prefixWrite)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">r, err = compressWithGzip(r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, u.String(), r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "text/plain; charset=utf-8")
        req.Header.Set("Content-Encoding", "gzip")
        SetToken(s.Token, req)

        params := req.URL.Query()

        // In other CLI commands that take either an ID or a name as input, the ID
        // is prioritized and used to short-circuit looking up the name. We simulate
        // the same behavior here for a consistent experience.
        if filter.OrganizationID != nil &amp;&amp; filter.OrganizationID.Valid() </span><span class="cov8" title="1">{
                params.Set("org", filter.OrganizationID.String())
        }</span> else<span class="cov8" title="1"> if filter.Org != nil &amp;&amp; *filter.Org != "" </span><span class="cov8" title="1">{
                params.Set("org", *filter.Org)
        }</span>
        <span class="cov8" title="1">if filter.ID != nil &amp;&amp; filter.ID.Valid() </span><span class="cov8" title="1">{
                params.Set("bucket", filter.ID.String())
        }</span> else<span class="cov8" title="1"> if filter.Name != nil &amp;&amp; *filter.Name != "" </span><span class="cov8" title="1">{
                params.Set("bucket", *filter.Name)
        }</span>
        <span class="cov8" title="1">params.Set("precision", precision)
        req.URL.RawQuery = params.Encode()

        hc := NewClient(u.Scheme, s.InsecureSkipVerify)

        resp, err := hc.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        return CheckError(resp)</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package http

import (
        "context"

        "github.com/influxdata/influxdb/v2/http/metric"
        "github.com/influxdata/influxdb/v2/kit/platform"
        kithttp "github.com/influxdata/influxdb/v2/kit/transport/http"
)

func NewWriteUsageRecorder(w *kithttp.StatusResponseWriter, recorder metric.EventRecorder) *WriteUsageRecorder <span class="cov8" title="1">{
        return &amp;WriteUsageRecorder{
                Writer:        w,
                EventRecorder: recorder,
        }
}</span>

type WriteUsageRecorder struct {
        Writer        *kithttp.StatusResponseWriter
        EventRecorder metric.EventRecorder
}

func (w *WriteUsageRecorder) Write(b []byte) (int, error) <span class="cov0" title="0">{
        return w.Writer.Write(b)
}</span>

func (w *WriteUsageRecorder) Record(ctx context.Context, requestBytes int, orgID platform.ID, endpoint string) <span class="cov8" title="1">{
        w.EventRecorder.Record(ctx, metric.Event{
                OrgID:         orgID,
                Endpoint:      endpoint,
                RequestBytes:  requestBytes,
                ResponseBytes: w.Writer.ResponseBytes(),
                Status:        w.Writer.Code(),
        })
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
