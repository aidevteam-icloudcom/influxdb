package protocol;

message FieldValue {
  optional string string_value = 1;
  optional double double_value = 3;
  optional bool bool_value = 4;
  optional int64 int64_value = 5;
}

message Point {
  repeated FieldValue values = 1;
  optional int64 timestamp = 2;
  optional uint64 sequence_number = 3;
}

message Series {
  repeated Point points = 1;
  required string name = 2;
  repeated string fields = 3;
}

message Request {
  enum Type {
    QUERY = 1;
    REPLICATION_WRITE = 2;
    PROXY_WRITE = 3;
    REPLICATION_DELETE = 4;
    PROXY_DELETE = 5;
  }
  required uint32 id = 1;
  required Type type = 2;
  required string database = 3;
  optional Series series = 4;
  optional string query = 5;
  optional string userName = 6;
  // ringLocationsToQuery tells the server what data it should be returning.
  // for example, if the number is 1, it will only return data that is owned by 
  // this server on the hash ring. If 2, it will return this server and data replicated
  // from the server directly before it on the ring. 3, etc.
  // If this field is left out, we assume that we'll be returning all data the server has
  // for the query.
  optional uint32 ringLocationsToQuery = 7;
}

message Response {
  enum Type {
    QUERY = 1;
    WRITE_OK = 2;
    END_STREAM = 3;
  }
  enum ErrorCode {
    REQUEST_TOO_LARGE = 1;
  }
  required Type type = 1;
  required uint32 request_id = 2;
  optional Series series = 3;
  optional ErrorCode error_code = 4;
  optional string error_message = 5;
  optional int64 nextPointTime = 6;
}
