// Generated by tmpl
// https://github.com/benbjohnson/tmpl
//
// DO NOT EDIT!
// Source: functions.gen.go.tmpl

package influxql

// FloatPointAggregator aggregates points to produce a single point.
type FloatPointAggregator interface {
	Aggregate(p *FloatPoint)
}

// FloatPointEmitter produces a single point from an aggregate.
type FloatPointEmitter interface {
	Emit() *FloatPoint
}

// FloatReduceFunc is the function called by a FloatPoint reducer.
type FloatReduceFunc func(prev, curr *FloatPoint) (t int64, v float64, aux []interface{})

type FloatFuncReducer struct {
	prev *FloatPoint
	fn   FloatReduceFunc
}

func NewFloatFuncReducer(fn FloatReduceFunc) *FloatFuncReducer {
	return &FloatFuncReducer{fn: fn}
}

func (r *FloatFuncReducer) Aggregate(p *FloatPoint) {
	t, v, aux := r.fn(r.prev, p)
	if r.prev == nil {
		r.prev = &FloatPoint{}
	}
	r.prev.Time = t
	r.prev.Value = v
	r.prev.Aux = aux
	r.prev.Aggregated++
}

func (r *FloatFuncReducer) Emit() *FloatPoint {
	return r.prev
}

// IntegerPointAggregator aggregates points to produce a single point.
type IntegerPointAggregator interface {
	Aggregate(p *IntegerPoint)
}

// IntegerPointEmitter produces a single point from an aggregate.
type IntegerPointEmitter interface {
	Emit() *IntegerPoint
}

// IntegerReduceFunc is the function called by a IntegerPoint reducer.
type IntegerReduceFunc func(prev, curr *IntegerPoint) (t int64, v int64, aux []interface{})

type IntegerFuncReducer struct {
	prev *IntegerPoint
	fn   IntegerReduceFunc
}

func NewIntegerFuncReducer(fn IntegerReduceFunc) *IntegerFuncReducer {
	return &IntegerFuncReducer{fn: fn}
}

func (r *IntegerFuncReducer) Aggregate(p *IntegerPoint) {
	t, v, aux := r.fn(r.prev, p)
	if r.prev == nil {
		r.prev = &IntegerPoint{}
	}
	r.prev.Time = t
	r.prev.Value = v
	r.prev.Aux = aux
	r.prev.Aggregated++
}

func (r *IntegerFuncReducer) Emit() *IntegerPoint {
	return r.prev
}

// StringPointAggregator aggregates points to produce a single point.
type StringPointAggregator interface {
	Aggregate(p *StringPoint)
}

// StringPointEmitter produces a single point from an aggregate.
type StringPointEmitter interface {
	Emit() *StringPoint
}

// StringReduceFunc is the function called by a StringPoint reducer.
type StringReduceFunc func(prev, curr *StringPoint) (t int64, v string, aux []interface{})

type StringFuncReducer struct {
	prev *StringPoint
	fn   StringReduceFunc
}

func NewStringFuncReducer(fn StringReduceFunc) *StringFuncReducer {
	return &StringFuncReducer{fn: fn}
}

func (r *StringFuncReducer) Aggregate(p *StringPoint) {
	t, v, aux := r.fn(r.prev, p)
	if r.prev == nil {
		r.prev = &StringPoint{}
	}
	r.prev.Time = t
	r.prev.Value = v
	r.prev.Aux = aux
	r.prev.Aggregated++
}

func (r *StringFuncReducer) Emit() *StringPoint {
	return r.prev
}

// BooleanPointAggregator aggregates points to produce a single point.
type BooleanPointAggregator interface {
	Aggregate(p *BooleanPoint)
}

// BooleanPointEmitter produces a single point from an aggregate.
type BooleanPointEmitter interface {
	Emit() *BooleanPoint
}

// BooleanReduceFunc is the function called by a BooleanPoint reducer.
type BooleanReduceFunc func(prev, curr *BooleanPoint) (t int64, v bool, aux []interface{})

type BooleanFuncReducer struct {
	prev *BooleanPoint
	fn   BooleanReduceFunc
}

func NewBooleanFuncReducer(fn BooleanReduceFunc) *BooleanFuncReducer {
	return &BooleanFuncReducer{fn: fn}
}

func (r *BooleanFuncReducer) Aggregate(p *BooleanPoint) {
	t, v, aux := r.fn(r.prev, p)
	if r.prev == nil {
		r.prev = &BooleanPoint{}
	}
	r.prev.Time = t
	r.prev.Value = v
	r.prev.Aux = aux
	r.prev.Aggregated++
}

func (r *BooleanFuncReducer) Emit() *BooleanPoint {
	return r.prev
}
